// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.
import { CompositeLayer, _GPUGridAggregator as GPUGridAggregator } from '@deck.gl/core';
import GPUGridCellLayer from './gpu-grid-cell-layer';
import { pointToDensityGridData } from './gpu-grid-utils';
const MINCOLOR = [0, 0, 0, 255];
const MAXCOLOR = [0, 255, 0, 255];
const defaultProps = {
  // elevation
  elevationScale: 1,
  // grid
  cellSize: {
    type: 'number',
    min: 0,
    max: 1000,
    value: 1000
  },
  coverage: {
    type: 'number',
    min: 0,
    max: 1,
    value: 1
  },
  getPosition: x => x.position,
  extruded: false,
  fp64: false,
  pickable: false,
  // TODO: Enable picking with GPU Aggregation
  // Optional settings for 'lighting' shader module
  lightSettings: {},
  // GPU Aggregation
  gpuAggregation: true
};
export default class GPUGridLayer extends CompositeLayer {
  initializeState() {
    const gl = this.context.gl;
    const options = {
      id: `${this.id}-gpu-aggregator`,
      shaderCache: this.context.shaderCache
    };
    this.state = {
      gpuGridAggregator: new GPUGridAggregator(gl, options)
    };
  }

  updateState({
    oldProps,
    props,
    changeFlags
  }) {
    const reprojectNeeded = this.needsReProjectPoints(oldProps, props);

    if (changeFlags.dataChanged || reprojectNeeded) {
      // project data into hexagons, and get sortedBins
      this.getLayerData();
    }
  }

  needsReProjectPoints(oldProps, props) {
    return oldProps.cellSize !== props.cellSize || oldProps.gpuAggregation !== props.gpuAggregation || oldProps.getPosition !== props.getPosition;
  }

  getLayerData() {
    const _this$props = this.props,
          data = _this$props.data,
          cellSize = _this$props.cellSize,
          getPosition = _this$props.getPosition,
          gpuAggregation = _this$props.gpuAggregation;

    const _pointToDensityGridDa = pointToDensityGridData({
      data,
      cellSizeMeters: cellSize,
      getPosition,
      gpuAggregation,
      gpuGridAggregator: this.state.gpuGridAggregator
    }),
          countsBuffer = _pointToDensityGridDa.countsBuffer,
          maxCountBuffer = _pointToDensityGridDa.maxCountBuffer,
          gridSize = _pointToDensityGridDa.gridSize,
          gridOrigin = _pointToDensityGridDa.gridOrigin,
          gridOffset = _pointToDensityGridDa.gridOffset;

    this.setState({
      countsBuffer,
      maxCountBuffer,
      gridSize,
      gridOrigin,
      gridOffset
    });
  } // for subclassing, override this method to return
  // customized sub layer props


  getSubLayerProps() {
    const _this$props2 = this.props,
          elevationScale = _this$props2.elevationScale,
          fp64 = _this$props2.fp64,
          extruded = _this$props2.extruded,
          cellSize = _this$props2.cellSize,
          coverage = _this$props2.coverage,
          lightSettings = _this$props2.lightSettings;
    const _this$state = this.state,
          countsBuffer = _this$state.countsBuffer,
          maxCountBuffer = _this$state.maxCountBuffer,
          gridSize = _this$state.gridSize,
          gridOrigin = _this$state.gridOrigin,
          gridOffset = _this$state.gridOffset;
    const minColor = MINCOLOR;
    const maxColor = MAXCOLOR; // return props to the sublayer constructor

    return super.getSubLayerProps({
      id: 'grid-cell',
      data: this.state.layerData,
      countsBuffer,
      maxCountBuffer,
      gridSize,
      gridOrigin,
      gridOffset,
      numInstances: gridSize[0] * gridSize[1],
      minColor,
      maxColor,
      fp64,
      cellSize,
      coverage,
      lightSettings,
      elevationScale,
      extruded,
      pickable: false
    });
  } // for subclassing, override this method to return
  // customized sub layer class


  getSubLayerClass() {
    return GPUGridCellLayer;
  }

  renderLayers() {
    const SubLayerClass = this.getSubLayerClass();
    return new SubLayerClass(this.getSubLayerProps());
  }

}
GPUGridLayer.layerName = 'GridLayer';
GPUGridLayer.defaultProps = defaultProps;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9ncHUtZ3JpZC1sYXllci9ncHUtZ3JpZC1sYXllci5qcyJdLCJuYW1lcyI6WyJDb21wb3NpdGVMYXllciIsIl9HUFVHcmlkQWdncmVnYXRvciIsIkdQVUdyaWRBZ2dyZWdhdG9yIiwiR1BVR3JpZENlbGxMYXllciIsInBvaW50VG9EZW5zaXR5R3JpZERhdGEiLCJNSU5DT0xPUiIsIk1BWENPTE9SIiwiZGVmYXVsdFByb3BzIiwiZWxldmF0aW9uU2NhbGUiLCJjZWxsU2l6ZSIsInR5cGUiLCJtaW4iLCJtYXgiLCJ2YWx1ZSIsImNvdmVyYWdlIiwiZ2V0UG9zaXRpb24iLCJ4IiwicG9zaXRpb24iLCJleHRydWRlZCIsImZwNjQiLCJwaWNrYWJsZSIsImxpZ2h0U2V0dGluZ3MiLCJncHVBZ2dyZWdhdGlvbiIsIkdQVUdyaWRMYXllciIsImluaXRpYWxpemVTdGF0ZSIsImdsIiwiY29udGV4dCIsIm9wdGlvbnMiLCJpZCIsInNoYWRlckNhY2hlIiwic3RhdGUiLCJncHVHcmlkQWdncmVnYXRvciIsInVwZGF0ZVN0YXRlIiwib2xkUHJvcHMiLCJwcm9wcyIsImNoYW5nZUZsYWdzIiwicmVwcm9qZWN0TmVlZGVkIiwibmVlZHNSZVByb2plY3RQb2ludHMiLCJkYXRhQ2hhbmdlZCIsImdldExheWVyRGF0YSIsImRhdGEiLCJjZWxsU2l6ZU1ldGVycyIsImNvdW50c0J1ZmZlciIsIm1heENvdW50QnVmZmVyIiwiZ3JpZFNpemUiLCJncmlkT3JpZ2luIiwiZ3JpZE9mZnNldCIsInNldFN0YXRlIiwiZ2V0U3ViTGF5ZXJQcm9wcyIsIm1pbkNvbG9yIiwibWF4Q29sb3IiLCJsYXllckRhdGEiLCJudW1JbnN0YW5jZXMiLCJnZXRTdWJMYXllckNsYXNzIiwicmVuZGVyTGF5ZXJzIiwiU3ViTGF5ZXJDbGFzcyIsImxheWVyTmFtZSJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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TUMsZ0JBQWdCLEtBQUtGLGdCQUFMLEVBQXRCO0FBRUEsV0FBTyxJQUFJRSxhQUFKLENBQWtCLEtBQUtQLGdCQUFMLEVBQWxCLENBQVA7QUFDRDs7QUF2RnNEO0FBMEZ6RHpCLGFBQWFpQyxTQUFiLEdBQXlCLFdBQXpCO0FBQ0FqQyxhQUFhaEIsWUFBYixHQUE0QkEsWUFBNUIiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKGMpIDIwMTUgLSAyMDE3IFViZXIgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuLy8gaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuLy8gdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuLy8gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuLy8gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuLy8gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbi8vIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbi8vIFRIRSBTT0ZUV0FSRS5cblxuaW1wb3J0IHtDb21wb3NpdGVMYXllciwgX0dQVUdyaWRBZ2dyZWdhdG9yIGFzIEdQVUdyaWRBZ2dyZWdhdG9yfSBmcm9tICdAZGVjay5nbC9jb3JlJztcblxuaW1wb3J0IEdQVUdyaWRDZWxsTGF5ZXIgZnJvbSAnLi9ncHUtZ3JpZC1jZWxsLWxheWVyJztcblxuaW1wb3J0IHtwb2ludFRvRGVuc2l0eUdyaWREYXRhfSBmcm9tICcuL2dwdS1ncmlkLXV0aWxzJztcblxuY29uc3QgTUlOQ09MT1IgPSBbMCwgMCwgMCwgMjU1XTtcbmNvbnN0IE1BWENPTE9SID0gWzAsIDI1NSwgMCwgMjU1XTtcblxuY29uc3QgZGVmYXVsdFByb3BzID0ge1xuICAvLyBlbGV2YXRpb25cbiAgZWxldmF0aW9uU2NhbGU6IDEsXG5cbiAgLy8gZ3JpZFxuICBjZWxsU2l6ZToge3R5cGU6ICdudW1iZXInLCBtaW46IDAsIG1heDogMTAwMCwgdmFsdWU6IDEwMDB9LFxuICBjb3ZlcmFnZToge3R5cGU6ICdudW1iZXInLCBtaW46IDAsIG1heDogMSwgdmFsdWU6IDF9LFxuICBnZXRQb3NpdGlvbjogeCA9PiB4LnBvc2l0aW9uLFxuICBleHRydWRlZDogZmFsc2UsXG4gIGZwNjQ6IGZhbHNlLFxuICBwaWNrYWJsZTogZmFsc2UsIC8vIFRPRE86IEVuYWJsZSBwaWNraW5nIHdpdGggR1BVIEFnZ3JlZ2F0aW9uXG5cbiAgLy8gT3B0aW9uYWwgc2V0dGluZ3MgZm9yICdsaWdodGluZycgc2hhZGVyIG1vZHVsZVxuICBsaWdodFNldHRpbmdzOiB7fSxcblxuICAvLyBHUFUgQWdncmVnYXRpb25cbiAgZ3B1QWdncmVnYXRpb246IHRydWVcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEdQVUdyaWRMYXllciBleHRlbmRzIENvbXBvc2l0ZUxheWVyIHtcbiAgaW5pdGlhbGl6ZVN0YXRlKCkge1xuICAgIGNvbnN0IHtnbH0gPSB0aGlzLmNvbnRleHQ7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgIGlkOiBgJHt0aGlzLmlkfS1ncHUtYWdncmVnYXRvcmAsXG4gICAgICBzaGFkZXJDYWNoZTogdGhpcy5jb250ZXh0LnNoYWRlckNhY2hlXG4gICAgfTtcbiAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgZ3B1R3JpZEFnZ3JlZ2F0b3I6IG5ldyBHUFVHcmlkQWdncmVnYXRvcihnbCwgb3B0aW9ucylcbiAgICB9O1xuICB9XG5cbiAgdXBkYXRlU3RhdGUoe29sZFByb3BzLCBwcm9wcywgY2hhbmdlRmxhZ3N9KSB7XG4gICAgY29uc3QgcmVwcm9qZWN0TmVlZGVkID0gdGhpcy5uZWVkc1JlUHJvamVjdFBvaW50cyhvbGRQcm9wcywgcHJvcHMpO1xuXG4gICAgaWYgKGNoYW5nZUZsYWdzLmRhdGFDaGFuZ2VkIHx8IHJlcHJvamVjdE5lZWRlZCkge1xuICAgICAgLy8gcHJvamVjdCBkYXRhIGludG8gaGV4YWdvbnMsIGFuZCBnZXQgc29ydGVkQmluc1xuICAgICAgdGhpcy5nZXRMYXllckRhdGEoKTtcbiAgICB9XG4gIH1cblxuICBuZWVkc1JlUHJvamVjdFBvaW50cyhvbGRQcm9wcywgcHJvcHMpIHtcbiAgICByZXR1cm4gKFxuICAgICAgb2xkUHJvcHMuY2VsbFNpemUgIT09IHByb3BzLmNlbGxTaXplIHx8XG4gICAgICBvbGRQcm9wcy5ncHVBZ2dyZWdhdGlvbiAhPT0gcHJvcHMuZ3B1QWdncmVnYXRpb24gfHxcbiAgICAgIG9sZFByb3BzLmdldFBvc2l0aW9uICE9PSBwcm9wcy5nZXRQb3NpdGlvblxuICAgICk7XG4gIH1cblxuICBnZXRMYXllckRhdGEoKSB7XG4gICAgY29uc3Qge2RhdGEsIGNlbGxTaXplLCBnZXRQb3NpdGlvbiwgZ3B1QWdncmVnYXRpb259ID0gdGhpcy5wcm9wcztcbiAgICBjb25zdCB7Y291bnRzQnVmZmVyLCBtYXhDb3VudEJ1ZmZlciwgZ3JpZFNpemUsIGdyaWRPcmlnaW4sIGdyaWRPZmZzZXR9ID0gcG9pbnRUb0RlbnNpdHlHcmlkRGF0YShcbiAgICAgIHtcbiAgICAgICAgZGF0YSxcbiAgICAgICAgY2VsbFNpemVNZXRlcnM6IGNlbGxTaXplLFxuICAgICAgICBnZXRQb3NpdGlvbixcbiAgICAgICAgZ3B1QWdncmVnYXRpb24sXG4gICAgICAgIGdwdUdyaWRBZ2dyZWdhdG9yOiB0aGlzLnN0YXRlLmdwdUdyaWRBZ2dyZWdhdG9yXG4gICAgICB9XG4gICAgKTtcblxuICAgIHRoaXMuc2V0U3RhdGUoe2NvdW50c0J1ZmZlciwgbWF4Q291bnRCdWZmZXIsIGdyaWRTaXplLCBncmlkT3JpZ2luLCBncmlkT2Zmc2V0fSk7XG4gIH1cblxuICAvLyBmb3Igc3ViY2xhc3NpbmcsIG92ZXJyaWRlIHRoaXMgbWV0aG9kIHRvIHJldHVyblxuICAvLyBjdXN0b21pemVkIHN1YiBsYXllciBwcm9wc1xuICBnZXRTdWJMYXllclByb3BzKCkge1xuICAgIGNvbnN0IHtlbGV2YXRpb25TY2FsZSwgZnA2NCwgZXh0cnVkZWQsIGNlbGxTaXplLCBjb3ZlcmFnZSwgbGlnaHRTZXR0aW5nc30gPSB0aGlzLnByb3BzO1xuXG4gICAgY29uc3Qge2NvdW50c0J1ZmZlciwgbWF4Q291bnRCdWZmZXIsIGdyaWRTaXplLCBncmlkT3JpZ2luLCBncmlkT2Zmc2V0fSA9IHRoaXMuc3RhdGU7XG4gICAgY29uc3QgbWluQ29sb3IgPSBNSU5DT0xPUjtcbiAgICBjb25zdCBtYXhDb2xvciA9IE1BWENPTE9SO1xuXG4gICAgLy8gcmV0dXJuIHByb3BzIHRvIHRoZSBzdWJsYXllciBjb25zdHJ1Y3RvclxuICAgIHJldHVybiBzdXBlci5nZXRTdWJMYXllclByb3BzKHtcbiAgICAgIGlkOiAnZ3JpZC1jZWxsJyxcbiAgICAgIGRhdGE6IHRoaXMuc3RhdGUubGF5ZXJEYXRhLFxuXG4gICAgICBjb3VudHNCdWZmZXIsXG4gICAgICBtYXhDb3VudEJ1ZmZlcixcbiAgICAgIGdyaWRTaXplLFxuICAgICAgZ3JpZE9yaWdpbixcbiAgICAgIGdyaWRPZmZzZXQsXG4gICAgICBudW1JbnN0YW5jZXM6IGdyaWRTaXplWzBdICogZ3JpZFNpemVbMV0sXG4gICAgICBtaW5Db2xvcixcbiAgICAgIG1heENvbG9yLFxuXG4gICAgICBmcDY0LFxuICAgICAgY2VsbFNpemUsXG4gICAgICBjb3ZlcmFnZSxcbiAgICAgIGxpZ2h0U2V0dGluZ3MsXG4gICAgICBlbGV2YXRpb25TY2FsZSxcbiAgICAgIGV4dHJ1ZGVkLFxuICAgICAgcGlja2FibGU6IGZhbHNlXG4gICAgfSk7XG4gIH1cblxuICAvLyBmb3Igc3ViY2xhc3NpbmcsIG92ZXJyaWRlIHRoaXMgbWV0aG9kIHRvIHJldHVyblxuICAvLyBjdXN0b21pemVkIHN1YiBsYXllciBjbGFzc1xuICBnZXRTdWJMYXllckNsYXNzKCkge1xuICAgIHJldHVybiBHUFVHcmlkQ2VsbExheWVyO1xuICB9XG5cbiAgcmVuZGVyTGF5ZXJzKCkge1xuICAgIGNvbnN0IFN1YkxheWVyQ2xhc3MgPSB0aGlzLmdldFN1YkxheWVyQ2xhc3MoKTtcblxuICAgIHJldHVybiBuZXcgU3ViTGF5ZXJDbGFzcyh0aGlzLmdldFN1YkxheWVyUHJvcHMoKSk7XG4gIH1cbn1cblxuR1BVR3JpZExheWVyLmxheWVyTmFtZSA9ICdHcmlkTGF5ZXInO1xuR1BVR3JpZExheWVyLmRlZmF1bHRQcm9wcyA9IGRlZmF1bHRQcm9wcztcbiJdfQ==