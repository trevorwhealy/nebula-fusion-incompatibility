"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getCode = getCode;
exports.getVertices = getVertices;

var _assert = _interopRequireDefault(require("assert"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// All utility mehtods needed to implement Marching Squres algorithm
// Ref: https://en.wikipedia.org/wiki/Marching_squares
// Table to map code to the intersection offsets
// All offsets are relative to the center of marching cell (which is top right corner of grid-cell)
var OFFSET = {
  N: [0, 0.5],
  E: [0.5, 0],
  S: [0, -0.5],
  W: [-0.5, 0]
}; // Note: above wiki page invertes white/black dots for generating the code, we don't

var CODE_OFFSET_MAP = {
  0: [],
  1: [[OFFSET.W, OFFSET.S]],
  2: [[OFFSET.S, OFFSET.E]],
  3: [[OFFSET.W, OFFSET.E]],
  4: [[OFFSET.N, OFFSET.E]],
  5: [[OFFSET.W, OFFSET.N], [OFFSET.S, OFFSET.E]],
  6: [[OFFSET.N, OFFSET.S]],
  7: [[OFFSET.W, OFFSET.N]],
  8: [[OFFSET.W, OFFSET.N]],
  9: [[OFFSET.N, OFFSET.S]],
  10: [[OFFSET.W, OFFSET.S], [OFFSET.N, OFFSET.E]],
  11: [[OFFSET.N, OFFSET.E]],
  12: [[OFFSET.W, OFFSET.E]],
  13: [[OFFSET.S, OFFSET.E]],
  14: [[OFFSET.W, OFFSET.S]],
  15: []
}; // Returns marching square code for given cell

function getCode(params) {
  // Assumptions
  // Origin is on bottom-left , and X increase to right, Y to top
  // When processing one cell, we process 4 cells, by extending row to top and on column to right
  // to create a 2X2 cell grid
  var cellWeights = params.cellWeights,
      thresholdValue = params.thresholdValue,
      cellIndex = params.cellIndex,
      gridSize = params.gridSize;
  var numRows = gridSize[1];
  var numCols = gridSize[0]; // TODO: duplicate top row and right column
  // We shouldn't process the right column

  (0, _assert.default)((cellIndex + 1) % numCols); // We shouldn't process the topmost row

  (0, _assert.default)(cellIndex + 1 < (numRows - 1) * numCols);
  var top = cellWeights[cellIndex + numCols] - thresholdValue >= 0 ? 1 : 0;
  var topRight = cellWeights[cellIndex + numCols + 1] - thresholdValue >= 0 ? 1 : 0;
  var right = cellWeights[cellIndex + 1] - thresholdValue >= 0 ? 1 : 0;
  var current = cellWeights[cellIndex] - thresholdValue >= 0 ? 1 : 0;
  var code = top << 3 | topRight << 2 | right << 1 | current;
  (0, _assert.default)(code >= 0 && code < 16);
  return code;
} // Returns intersection vertices for given cellindex


function getVertices(params) {
  var gridOrigin = params.gridOrigin,
      cellIndex = params.cellIndex,
      cellSize = params.cellSize,
      gridSize = params.gridSize,
      code = params.code;
  var offsets = CODE_OFFSET_MAP[code]; // Reference vertex is top-right its co-ordinates are stored at index 0(X) and 1(Y)

  var row = Math.floor(cellIndex / gridSize[0]);
  var col = cellIndex - row * gridSize[0]; // Move to top-right corner

  var rX = (col + 1) * cellSize[0];
  var rY = (row + 1) * cellSize[1];
  var refVertexX = gridOrigin[0] + rX;
  var refVertexY = gridOrigin[1] + rY;
  var vertices = [];
  offsets.forEach(function (xyOffsets) {
    xyOffsets.forEach(function (offset) {
      var x = refVertexX + offset[0] * cellSize[0];
      var y = refVertexY + offset[1] * cellSize[1];
      vertices.push([x, y]);
    });
  });
  return vertices;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9jb250b3VyLWxheWVyL21hcmNoaW5nLXNxdWFyZXMuanMiXSwibmFtZXMiOlsiT0ZGU0VUIiwiTiIsIkUiLCJTIiwiVyIsIkNPREVfT0ZGU0VUX01BUCIsImdldENvZGUiLCJwYXJhbXMiLCJjZWxsV2VpZ2h0cyIsInRocmVzaG9sZFZhbHVlIiwiY2VsbEluZGV4IiwiZ3JpZFNpemUiLCJudW1Sb3dzIiwibnVtQ29scyIsInRvcCIsInRvcFJpZ2h0IiwicmlnaHQiLCJjdXJyZW50IiwiY29kZSIsImdldFZlcnRpY2VzIiwiZ3JpZE9yaWdpbiIsImNlbGxTaXplIiwib2Zmc2V0cyIsInJvdyIsIk1hdGgiLCJmbG9vciIsImNvbCIsInJYIiwiclkiLCJyZWZWZXJ0ZXhYIiwicmVmVmVydGV4WSIsInZlcnRpY2VzIiwiZm9yRWFjaCIsInh5T2Zmc2V0cyIsIngiLCJvZmZzZXQiLCJ5IiwicHVzaCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFFQTs7OztBQUZBO0FBQ0E7QUFHQTtBQUNBO0FBQ0EsSUFBTUEsU0FBUztBQUNiQyxLQUFHLENBQUMsQ0FBRCxFQUFJLEdBQUosQ0FEVTtBQUViQyxLQUFHLENBQUMsR0FBRCxFQUFNLENBQU4sQ0FGVTtBQUdiQyxLQUFHLENBQUMsQ0FBRCxFQUFJLENBQUMsR0FBTCxDQUhVO0FBSWJDLEtBQUcsQ0FBQyxDQUFDLEdBQUYsRUFBTyxDQUFQO0FBSlUsQ0FBZixDLENBT0E7O0FBQ0EsSUFBTUMsa0JBQWtCO0FBQ3RCLEtBQUcsRUFEbUI7QUFFdEIsS0FBRyxDQUFDLENBQUNMLE9BQU9JLENBQVIsRUFBV0osT0FBT0csQ0FBbEIsQ0FBRCxDQUZtQjtBQUd0QixLQUFHLENBQUMsQ0FBQ0gsT0FBT0csQ0FBUixFQUFXSCxPQUFPRSxDQUFsQixDQUFELENBSG1CO0FBSXRCLEtBQUcsQ0FBQyxDQUFDRixPQUFPSSxDQUFSLEVBQVdKLE9BQU9FLENBQWxCLENBQUQsQ0FKbUI7QUFLdEIsS0FBRyxDQUFDLENBQUNG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Q0FDZkcsU0FEZTtBQUFBLE1BQ0pXLFFBREksR0FDd0JkLE1BRHhCLENBQ0pjLFFBREk7QUFBQSxNQUNNVixRQUROLEdBQ3dCSixNQUR4QixDQUNNSSxRQUROO0FBQUEsTUFDZ0JPLElBRGhCLEdBQ3dCWCxNQUR4QixDQUNnQlcsSUFEaEI7QUFHbEMsTUFBTUksVUFBVWpCLGdCQUFnQmEsSUFBaEIsQ0FBaEIsQ0FIa0MsQ0FJbEM7O0FBQ0EsTUFBTUssTUFBTUMsS0FBS0MsS0FBTCxDQUFXZixZQUFZQyxTQUFTLENBQVQsQ0FBdkIsQ0FBWjtBQUNBLE1BQU1lLE1BQU1oQixZQUFZYSxNQUFNWixTQUFTLENBQVQsQ0FBOUIsQ0FOa0MsQ0FRbEM7O0FBQ0EsTUFBTWdCLEtBQUssQ0FBQ0QsTUFBTSxDQUFQLElBQVlMLFNBQVMsQ0FBVCxDQUF2QjtBQUNBLE1BQU1PLEtBQUssQ0FBQ0wsTUFBTSxDQUFQLElBQVlGLFNBQVMsQ0FBVCxDQUF2QjtBQUVBLE1BQU1RLGFBQWFULFdBQVcsQ0FBWCxJQUFnQk8sRUFBbkM7QUFDQSxNQUFNRyxhQUFhVixXQUFXLENBQVgsSUFBZ0JRLEVBQW5DO0FBRUEsTUFBTUcsV0FBVyxFQUFqQjtBQUNBVCxVQUFRVSxPQUFSLENBQWdCLHFCQUFhO0FBQzNCQyxjQUFVRCxPQUFWLENBQWtCLGtCQUFVO0FBQzFCLFVBQU1FLElBQUlMLGFBQWFNLE9BQU8sQ0FBUCxJQUFZZCxTQUFTLENBQVQsQ0FBbkM7QUFDQSxVQUFNZSxJQUFJTixhQUFhSyxPQUFPLENBQVAsSUFBWWQsU0FBUyxDQUFULENBQW5DO0FBQ0FVLGVBQVNNLElBQVQsQ0FBYyxDQUFDSCxDQUFELEVBQUlFLENBQUosQ0FBZDtBQUNELEtBSkQ7QUFLRCxHQU5EO0FBUUEsU0FBT0wsUUFBUDtBQUNEIiwic291cmNlc0NvbnRlbnQiOlsiLy8gQWxsIHV0aWxpdHkgbWVodG9kcyBuZWVkZWQgdG8gaW1wbGVtZW50IE1hcmNoaW5nIFNxdXJlcyBhbGdvcml0aG1cbi8vIFJlZjogaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTWFyY2hpbmdfc3F1YXJlc1xuaW1wb3J0IGFzc2VydCBmcm9tICdhc3NlcnQnO1xuXG4vLyBUYWJsZSB0byBtYXAgY29kZSB0byB0aGUgaW50ZXJzZWN0aW9uIG9mZnNldHNcbi8vIEFsbCBvZmZzZXRzIGFyZSByZWxhdGl2ZSB0byB0aGUgY2VudGVyIG9mIG1hcmNoaW5nIGNlbGwgKHdoaWNoIGlzIHRvcCByaWdodCBjb3JuZXIgb2YgZ3JpZC1jZWxsKVxuY29uc3QgT0ZGU0VUID0ge1xuICBOOiBbMCwgMC41XSxcbiAgRTogWzAuNSwgMF0sXG4gIFM6IFswLCAtMC41XSxcbiAgVzogWy0wLjUsIDBdXG59O1xuXG4vLyBOb3RlOiBhYm92ZSB3aWtpIHBhZ2UgaW52ZXJ0ZXMgd2hpdGUvYmxhY2sgZG90cyBmb3IgZ2VuZXJhdGluZyB0aGUgY29kZSwgd2UgZG9uJ3RcbmNvbnN0IENPREVfT0ZGU0VUX01BUCA9IHtcbiAgMDogW10sXG4gIDE6IFtbT0ZGU0VULlcsIE9GRlNFVC5TXV0sXG4gIDI6IFtbT0ZGU0VULlMsIE9GRlNFVC5FXV0sXG4gIDM6IFtbT0ZGU0VULlcsIE9GRlNFVC5FXV0sXG4gIDQ6IFtbT0ZGU0VULk4sIE9GRlNFVC5FXV0sXG4gIDU6IFtbT0ZGU0VULlcsIE9GRlNFVC5OXSwgW09GRlNFVC5TLCBPRkZTRVQuRV1dLFxuICA2OiBbW09GRlNFVC5OLCBPRkZTRVQuU11dLFxuICA3OiBbW09GRlNFVC5XLCBPRkZTRVQuTl1dLFxuICA4OiBbW09GRlNFVC5XLCBPRkZTRVQuTl1dLFxuICA5OiBbW09GRlNFVC5OLCBPRkZTRVQuU11dLFxuICAxMDogW1tPRkZTRVQuVywgT0ZGU0VULlNdLCBbT0ZGU0VULk4sIE9GRlNFVC5FXV0sXG4gIDExOiBbW09GRlNFVC5OLCBPRkZTRVQuRV1dLFxuICAxMjogW1tPRkZTRVQuVywgT0ZGU0VULkVdXSxcbiAgMTM6IFtbT0ZGU0VULlMsIE9GRlNFVC5FXV0sXG4gIDE0OiBbW09GRlNFVC5XLCBPRkZTRVQuU11dLFxuICAxNTogW11cbn07XG5cbi8vIFJldHVybnMgbWFyY2hpbmcgc3F1YXJlIGNvZGUgZm9yIGdpdmVuIGNlbGxcbmV4cG9ydCBmdW5jdGlvbiBnZXRDb2RlKHBhcmFtcykge1xuICAvLyBBc3N1bXB0aW9uc1xuICAvLyBPcmlnaW4gaXMgb24gYm90dG9tLWxlZnQgLCBhbmQgWCBpbmNyZWFzZSB0byByaWdodCwgWSB0byB0b3BcbiAgLy8gV2hlbiBwcm9jZXNzaW5nIG9uZSBjZWxsLCB3ZSBwcm9jZXNzIDQgY2VsbHMsIGJ5IGV4dGVuZGluZyByb3cgdG8gdG9wIGFuZCBvbiBjb2x1bW4gdG8gcmlnaHRcbiAgLy8gdG8gY3JlYXRlIGEgMlgyIGNlbGwgZ3JpZFxuXG4gIGNvbnN0IHtjZWxsV2VpZ2h0cywgdGhyZXNob2xkVmFsdWUsIGNlbGxJbmRleCwgZ3JpZFNpemV9ID0gcGFyYW1zO1xuXG4gIGNvbnN0IG51bVJvd3MgPSBncmlkU2l6ZVsxXTtcbiAgY29uc3QgbnVtQ29scyA9IGdyaWRTaXplWzBdO1xuXG4gIC8vIFRPRE86IGR1cGxpY2F0ZSB0b3Agcm93IGFuZCByaWdodCBjb2x1bW5cbiAgLy8gV2Ugc2hvdWxkbid0IHByb2Nlc3MgdGhlIHJpZ2h0IGNvbHVtblxuICBhc3NlcnQoKGNlbGxJbmRleCArIDEpICUgbnVtQ29scyk7XG4gIC8vIFdlIHNob3VsZG4ndCBwcm9jZXNzIHRoZSB0b3Btb3N0IHJvd1xuICBhc3NlcnQoY2VsbEluZGV4ICsgMSA8IChudW1Sb3dzIC0gMSkgKiBudW1Db2xzKTtcblxuICBjb25zdCB0b3AgPSBjZWxsV2VpZ2h0c1tjZWxsSW5kZXggKyBudW1Db2xzXSAtIHRocmVzaG9sZFZhbHVlID49IDAgPyAxIDogMDtcbiAgY29uc3QgdG9wUmlnaHQgPSBjZWxsV2VpZ2h0c1tjZWxsSW5kZXggKyBudW1Db2xzICsgMV0gLSB0aHJlc2hvbGRWYWx1ZSA+PSAwID8gMSA6IDA7XG4gIGNvbnN0IHJpZ2h0ID0gY2VsbFdlaWdodHNbY2VsbEluZGV4ICsgMV0gLSB0aHJlc2hvbGRWYWx1ZSA+PSAwID8gMSA6IDA7XG4gIGNvbnN0IGN1cnJlbnQgPSBjZWxsV2VpZ2h0c1tjZWxsSW5kZXhdIC0gdGhyZXNob2xkVmFsdWUgPj0gMCA/IDEgOiAwO1xuXG4gIGNvbnN0IGNvZGUgPSAodG9wIDw8IDMpIHwgKHRvcFJpZ2h0IDw8IDIpIHwgKHJpZ2h0IDw8IDEpIHwgY3VycmVudDtcblxuICBhc3NlcnQoY29kZSA+PSAwICYmIGNvZGUgPCAxNik7XG5cbiAgcmV0dXJuIGNvZGU7XG59XG5cbi8vIFJldHVybnMgaW50ZXJzZWN0aW9uIHZlcnRpY2VzIGZvciBnaXZlbiBjZWxsaW5kZXhcbmV4cG9ydCBmdW5jdGlvbiBnZXRWZXJ0aWNlcyhwYXJhbXMpIHtcbiAgY29uc3Qge2dyaWRPcmlnaW4sIGNlbGxJbmRleCwgY2VsbFNpemUsIGdyaWRTaXplLCBjb2RlfSA9IHBhcmFtcztcblxuICBjb25zdCBvZmZzZXRzID0gQ09ERV9PRkZTRVRfTUFQW2NvZGVdO1xuICAvLyBSZWZlcmVuY2UgdmVydGV4IGlzIHRvcC1yaWdodCBpdHMgY28tb3JkaW5hdGVzIGFyZSBzdG9yZWQgYXQgaW5kZXggMChYKSBhbmQgMShZKVxuICBjb25zdCByb3cgPSBNYXRoLmZsb29yKGNlbGxJbmRleCAvIGdyaWRTaXplWzBdKTtcbiAgY29uc3QgY29sID0gY2VsbEluZGV4IC0gcm93ICogZ3JpZFNpemVbMF07XG5cbiAgLy8gTW92ZSB0byB0b3AtcmlnaHQgY29ybmVyXG4gIGNvbnN0IHJYID0gKGNvbCArIDEpICogY2VsbFNpemVbMF07XG4gIGNvbnN0IHJZID0gKHJvdyArIDEpICogY2VsbFNpemVbMV07XG5cbiAgY29uc3QgcmVmVmVydGV4WCA9IGdyaWRPcmlnaW5bMF0gKyByWDtcbiAgY29uc3QgcmVmVmVydGV4WSA9IGdyaWRPcmlnaW5bMV0gKyByWTtcblxuICBjb25zdCB2ZXJ0aWNlcyA9IFtdO1xuICBvZmZzZXRzLmZvckVhY2goeHlPZmZzZXRzID0+IHtcbiAgICB4eU9mZnNldHMuZm9yRWFjaChvZmZzZXQgPT4ge1xuICAgICAgY29uc3QgeCA9IHJlZlZlcnRleFggKyBvZmZzZXRbMF0gKiBjZWxsU2l6ZVswXTtcbiAgICAgIGNvbnN0IHkgPSByZWZWZXJ0ZXhZICsgb2Zmc2V0WzFdICogY2VsbFNpemVbMV07XG4gICAgICB2ZXJ0aWNlcy5wdXNoKFt4LCB5XSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIHJldHVybiB2ZXJ0aWNlcztcbn1cbiJdfQ==