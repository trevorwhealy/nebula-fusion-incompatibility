"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.generateContours = generateContours;

var MarchingSquares = _interopRequireWildcard(require("./marching-squares"));

var _assert = _interopRequireDefault(require("assert"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

// Given all the cell weights, generates contours for each threshold.
function generateContours(_ref) {
  var thresholds = _ref.thresholds,
      colors = _ref.colors,
      cellWeights = _ref.cellWeights,
      gridSize = _ref.gridSize,
      gridOrigin = _ref.gridOrigin,
      cellSize = _ref.cellSize;
  var contourSegments = [];
  thresholds.forEach(function (threshold, index) {
    var numCols = gridSize[0];

    for (var cellIndex = 0; cellIndex < gridSize[0] * (gridSize[1] - 1); cellIndex++) {
      if (cellIndex === 0 || (cellIndex + 1) % numCols !== 0) {
        // Get the MarchingSquares code based on neighbor cell weights.
        var code = MarchingSquares.getCode({
          cellWeights: cellWeights,
          thresholdValue: threshold,
          cellIndex: cellIndex,
          gridSize: gridSize
        }); // Get the intersection vertices based on MarchingSquares code.

        var vertices = MarchingSquares.getVertices({
          gridOrigin: gridOrigin,
          cellIndex: cellIndex,
          cellSize: cellSize,
          gridSize: gridSize,
          code: code
        }); // We should always get even number of vertices

        (0, _assert.default)(vertices.length % 2 === 0);

        for (var i = 0; i < vertices.length; i += 2) {
          contourSegments.push({
            start: vertices[i],
            end: vertices[i + 1],
            threshold: threshold
          });
        }
      }
    }
  });
  return contourSegments;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9jb250b3VyLWxheWVyL2NvbnRvdXItdXRpbHMuanMiXSwibmFtZXMiOlsiZ2VuZXJhdGVDb250b3VycyIsInRocmVzaG9sZHMiLCJjb2xvcnMiLCJjZWxsV2VpZ2h0cyIsImdyaWRTaXplIiwiZ3JpZE9yaWdpbiIsImNlbGxTaXplIiwiY29udG91clNlZ21lbnRzIiwiZm9yRWFjaCIsInRocmVzaG9sZCIsImluZGV4IiwibnVtQ29scyIsImNlbGxJbmRleCIsImNvZGUiLCJNYXJjaGluZ1NxdWFyZXMiLCJnZXRDb2RlIiwidGhyZXNob2xkVmFsdWUiLCJ2ZXJ0aWNlcyIsImdldFZlcnRpY2VzIiwibGVuZ3RoIiwiaSIsInB1c2giLCJzdGFydCIsImVuZCJdLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBOztBQUNBOzs7Ozs7QUFFQTtBQUNPLFNBQVNBLGdCQUFULE9BT0o7QUFBQSxNQU5EQyxVQU1DLFFBTkRBLFVBTUM7QUFBQSxNQUxEQyxNQUtDLFFBTERBLE1BS0M7QUFBQSxNQUpEQyxXQUlDLFFBSkRBLFdBSUM7QUFBQSxNQUhEQyxRQUdDLFFBSERBLFFBR0M7QUFBQSxNQUZEQyxVQUVDLFFBRkRBLFVBRUM7QUFBQSxNQUREQyxRQUNDLFFBRERBLFFBQ0M7QUFDRCxNQUFNQyxrQkFBa0IsRUFBeEI7QUFFQU4sYUFBV08sT0FBWCxDQUFtQixVQUFDQyxTQUFELEVBQVlDLEtBQVosRUFBc0I7QUFDdkMsUUFBTUMsVUFBVVAsU0FBUyxDQUFULENBQWhCOztBQUNBLFNBQUssSUFBSVEsWUFBWSxDQUFyQixFQUF3QkEsWUFBWVIsU0FBUyxDQUFULEtBQWVBLFNBQVMsQ0FBVCxJQUFjLENBQTdCLENBQXBDLEVBQXFFUSxXQUFyRSxFQUFrRjtBQUNoRixVQUFJQSxjQUFjLENBQWQsSUFBbUIsQ0FBQ0EsWUFBWSxDQUFiLElBQWtCRCxPQUFsQixLQUE4QixDQUFyRCxFQUF3RDtBQUN0RDtBQUNBLFlBQU1FLE9BQU9DLGdCQUFnQkMsT0FBaEIsQ0FBd0I7QUFDbkNaLGtDQURtQztBQUVuQ2EsMEJBQWdCUCxTQUZtQjtBQUduQ0csOEJBSG1DO0FBSW5DUjtBQUptQyxTQUF4QixDQUFiLENBRnNELENBUXREOztBQUNBLFlBQU1hLFdBQVdILGdCQUFnQkksV0FBaEIsQ0FBNEI7QUFDM0NiLGdDQUQyQztBQUUzQ08sOEJBRjJDO0FBRzNDTiw0QkFIMkM7QUFJM0NGLDRCQUoyQztBQUszQ1M7QUFMMkMsU0FBNUIsQ0FBakIsQ0FUc0QsQ0FnQnREOztBQUNBLDZCQUFPSSxTQUFTRSxNQUFULEdBQWtCLENBQWxCLEtBQXdCLENBQS9COztBQUNBLGFBQUssSUFBSUMsSUFBSSxDQUFiLEVBQWdCQSxJQUFJSCxTQUFTRSxNQUE3QixFQUFxQ0MsS0FBSyxDQUExQyxFQUE2QztBQUMzQ2IsMEJBQWdCYyxJQUFoQixDQUFxQjtBQUNuQkMsbUJBQU9MLFNBQVNHLENBQVQsQ0FEWTtBQUVuQkcsaUJBQUtOLFNBQVNHLElBQUksQ0FBYixDQUZjO0FBR25CWDtBQUhtQixXQUFyQjtBQUtEO0FBQ0Y7QUFDRjtBQUNGLEdBOUJEO0FBK0JBLFNBQU9GLGVBQVA7QUFDRCIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIE1hcmNoaW5nU3F1YXJlcyBmcm9tICcuL21hcmNoaW5nLXNxdWFyZXMnO1xuaW1wb3J0IGFzc2VydCBmcm9tICdhc3NlcnQnO1xuXG4vLyBHaXZlbiBhbGwgdGhlIGNlbGwgd2VpZ2h0cywgZ2VuZXJhdGVzIGNvbnRvdXJzIGZvciBlYWNoIHRocmVzaG9sZC5cbmV4cG9ydCBmdW5jdGlvbiBnZW5lcmF0ZUNvbnRvdXJzKHtcbiAgdGhyZXNob2xkcyxcbiAgY29sb3JzLFxuICBjZWxsV2VpZ2h0cyxcbiAgZ3JpZFNpemUsXG4gIGdyaWRPcmlnaW4sXG4gIGNlbGxTaXplXG59KSB7XG4gIGNvbnN0IGNvbnRvdXJTZWdtZW50cyA9IFtdO1xuXG4gIHRocmVzaG9sZHMuZm9yRWFjaCgodGhyZXNob2xkLCBpbmRleCkgPT4ge1xuICAgIGNvbnN0IG51bUNvbHMgPSBncmlkU2l6ZVswXTtcbiAgICBmb3IgKGxldCBjZWxsSW5kZXggPSAwOyBjZWxsSW5kZXggPCBncmlkU2l6ZVswXSAqIChncmlkU2l6ZVsxXSAtIDEpOyBjZWxsSW5kZXgrKykge1xuICAgICAgaWYgKGNlbGxJbmRleCA9PT0gMCB8fCAoY2VsbEluZGV4ICsgMSkgJSBudW1Db2xzICE9PSAwKSB7XG4gICAgICAgIC8vIEdldCB0aGUgTWFyY2hpbmdTcXVhcmVzIGNvZGUgYmFzZWQgb24gbmVpZ2hib3IgY2VsbCB3ZWlnaHRzLlxuICAgICAgICBjb25zdCBjb2RlID0gTWFyY2hpbmdTcXVhcmVzLmdldENvZGUoe1xuICAgICAgICAgIGNlbGxXZWlnaHRzLFxuICAgICAgICAgIHRocmVzaG9sZFZhbHVlOiB0aHJlc2hvbGQsXG4gICAgICAgICAgY2VsbEluZGV4LFxuICAgICAgICAgIGdyaWRTaXplXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBHZXQgdGhlIGludGVyc2VjdGlvbiB2ZXJ0aWNlcyBiYXNlZCBvbiBNYXJjaGluZ1NxdWFyZXMgY29kZS5cbiAgICAgICAgY29uc3QgdmVydGljZXMgPSBNYXJjaGluZ1NxdWFyZXMuZ2V0VmVydGljZXMoe1xuICAgICAgICAgIGdyaWRPcmlnaW4sXG4gICAgICAgICAgY2VsbEluZGV4LFxuICAgICAgICAgIGNlbGxTaXplLFxuICAgICAgICAgIGdyaWRTaXplLFxuICAgICAgICAgIGNvZGVcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFdlIHNob3VsZCBhbHdheXMgZ2V0IGV2ZW4gbnVtYmVyIG9mIHZlcnRpY2VzXG4gICAgICAgIGFzc2VydCh2ZXJ0aWNlcy5sZW5ndGggJSAyID09PSAwKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2ZXJ0aWNlcy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICAgIGNvbnRvdXJTZWdtZW50cy5wdXNoKHtcbiAgICAgICAgICAgIHN0YXJ0OiB2ZXJ0aWNlc1tpXSxcbiAgICAgICAgICAgIGVuZDogdmVydGljZXNbaSArIDFdLFxuICAgICAgICAgICAgdGhyZXNob2xkXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICByZXR1cm4gY29udG91clNlZ21lbnRzO1xufVxuIl19