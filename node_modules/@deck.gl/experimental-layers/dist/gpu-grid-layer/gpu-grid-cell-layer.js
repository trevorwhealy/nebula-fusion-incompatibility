"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _core = require("@deck.gl/core");

var _constants = _interopRequireDefault(require("luma.gl/constants"));

var _luma = require("luma.gl");

var _gpuGridCellLayerVertex = _interopRequireDefault(require("./gpu-grid-cell-layer-vertex.glsl"));

var _gpuGridCellLayerFragment = _interopRequireDefault(require("./gpu-grid-cell-layer-fragment.glsl"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _instanceof(left, right) { if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) { return right[Symbol.hasInstance](left); } else { return left instanceof right; } }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!_instanceof(instance, Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var fp64LowPart = _luma.fp64.fp64LowPart;
var DEFAULT_MINCOLOR = [0, 0, 0, 255];
var DEFAULT_MAXCOLOR = [0, 255, 0, 255];
var AGGREGATION_DATA_UBO_INDEX = 0;
var defaultProps = {
  cellSize: {
    type: 'number',
    min: 0,
    max: 20,
    value: 20
  },
  coverage: {
    type: 'number',
    min: 0,
    max: 1,
    value: 1
  },
  elevationScale: {
    type: 'number',
    min: 0,
    value: 1
  },
  extruded: true,
  fp64: false,
  pickable: false,
  // TODO: add picking support (read from aggregated texture)
  minColor: DEFAULT_MINCOLOR,
  maxColor: DEFAULT_MAXCOLOR,
  lightSettings: {}
};

var GPUGridCellLayer =
/*#__PURE__*/
function (_Layer) {
  _inherits(GPUGridCellLayer, _Layer);

  function GPUGridCellLayer() {
    _classCallCheck(this, GPUGridCellLayer);

    return _possibleConstructorReturn(this, (GPUGridCellLayer.__proto__ || Object.getPrototypeOf(GPUGridCellLayer)).apply(this, arguments));
  }

  _createClass(GPUGridCellLayer, [{
    key: "getShaders",
    value: function getShaders() {
      return {
        vs: _gpuGridCellLayerVertex.default,
        fs: _gpuGridCellLayerFragment.default,
        modules: ['project32', 'lighting', 'picking', 'fp64']
      };
    }
  }, {
    key: "initializeState",
    value: function initializeState() {
      var attributeManager = this.getAttributeManager();
      attributeManager.addInstanced({
        instanceCounts: {
          size: 4,
          update: this.calculateInstanceCounts,
          noAlloc: true
        }
      });
    }
  }, {
    key: "updateState",
    value: function updateState(_ref) {
      var props = _ref.props,
          oldProps = _ref.oldProps,
          changeFlags = _ref.changeFlags;

      _get(GPUGridCellLayer.prototype.__proto__ || Object.getPrototypeOf(GPUGridCellLayer.prototype), "updateState", this).call(this, {
        props: props,
        oldProps: oldProps,
        changeFlags: changeFlags
      }); // Re-generate model if geometry changed


      if (props.fp64 !== oldProps.fp64) {
        var gl = this.context.gl;

        if (this.state.model) {
          this.state.model.delete();
        }

        var model = this._getModel(gl);

        this._setupUniformBuffer(model);

        this.setState({
          model: model
        });
        this.state.attributeManager.invalidate('instanceCounts');
      }

      if (props.countsBuffer !== oldProps.countsBuffer) {
        this.state.attributeManager.invalidate('instanceCounts');
      }
    }
  }, {
    key: "_getModel",
    value: function _getModel(gl) {
      return new _luma.Model(gl, Object.assign({}, this.getShaders(), {
        id: this.props.id,
        geometry: new _luma.CubeGeometry(),
        isInstanced: true,
        shaderCache: this.context.shaderCache
      }));
    }
  }, {
    key: "draw",
    value: function draw(_ref2) {
      var uniforms = _ref2.uniforms;
      var _this$props = this.props,
          cellSize = _this$props.cellSize,
          extruded = _this$props.extruded,
          elevationScale = _this$props.elevationScale,
          coverage = _this$props.coverage,
          gridSize = _this$props.gridSize,
          gridOrigin = _this$props.gridOrigin,
          gridOffset = _this$props.gridOffset,
          minColor = _this$props.minColor,
          maxColor = _this$props.maxColor,
          maxCountBuffer = _this$props.maxCountBuffer;
      var gridOriginLow = [fp64LowPart(gridOrigin[0]), fp64LowPart(gridOrigin[1])];
      var gridOffsetLow = [fp64LowPart(gridOffset[0]), fp64LowPart(gridOffset[1])];
      maxCountBuffer.bind({
        target: _constants.default.UNIFORM_BUFFER,
        index: AGGREGATION_DATA_UBO_INDEX
      });
      this.state.model.render(Object.assign({}, uniforms, {
        cellSize: cellSize,
        extruded: extruded,
        elevationScale: elevationScale,
        coverage: coverage,
        gridSize: gridSize,
        gridOrigin: gridOrigin,
        gridOriginLow: gridOriginLow,
        gridOffset: gridOffset,
        gridOffsetLow: gridOffsetLow,
        minColor: minColor,
        maxColor: maxColor
      }));
      maxCountBuffer.unbind({
        target: _constants.default.UNIFORM_BUFFER,
        index: AGGREGATION_DATA_UBO_INDEX
      });
    }
  }, {
    key: "calculateInstanceCounts",
    value: function calculateInstanceCounts(attribute) {
      var countsBuffer = this.props.countsBuffer;
      attribute.update({
        buffer: countsBuffer
      });
    }
  }, {
    key: "_setupUniformBuffer",
    value: function _setupUniformBuffer(model) {
      var gl = this.context.gl;
      var programHandle = model.program.handle;
      var uniformBlockIndex = gl.getUniformBlockIndex(programHandle, 'AggregationData');
      gl.uniformBlockBinding(programHandle, uniformBlockIndex, AGGREGATION_DATA_UBO_INDEX);
    }
  }]);

  return GPUGridCellLayer;
}(_core.Layer);

exports.default = GPUGridCellLayer;
GPUGridCellLayer.layerName = 'GridCellLayer';
GPUGridCellLayer.defaultProps = defaultProps;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9ncHUtZ3JpZC1sYXllci9ncHUtZ3JpZC1jZWxsLWxheWVyLmpzIl0sIm5hbWVzIjpbImZwNjRMb3dQYXJ0IiwiZnA2NCIsIkRFRkFVTFRfTUlOQ09MT1IiLCJERUZBVUxUX01BWENPTE9SIiwiQUdHUkVHQVRJT05fREFUQV9VQk9fSU5ERVgiLCJkZWZhdWx0UHJvcHMiLCJjZWxsU2l6ZSIsInR5cGUiLCJtaW4iLCJtYXgiLCJ2YWx1ZSIsImNvdmVyYWdlIiwiZWxldmF0aW9uU2NhbGUiLCJleHRydWRlZCIsInBpY2thYmxlIiwibWluQ29sb3IiLCJtYXhDb2xvciIsImxpZ2h0U2V0dGluZ3MiLCJHUFVHcmlkQ2VsbExheWVyIiwidnMiLCJmcyIsIm1vZHVsZXMiLCJhdHRyaWJ1dGVNYW5hZ2VyIiwiZ2V0QXR0cmlidXRlTWFuYWdlciIsImFkZEluc3RhbmNlZCIsImluc3RhbmNlQ291bnRzIiwic2l6ZSIsInVwZGF0ZSIsImNhbGN1bGF0ZUluc3RhbmNlQ291bnRzIiwibm9BbGxvYyIsInByb3BzIiwib2xkUHJvcHMiLCJjaGFuZ2VGbGFncyIsImdsIiwiY29udGV4dCIsInN0YXRlIiwibW9kZWwiLCJkZWxldGUiLCJfZ2V0TW9kZWwiLCJfc2V0dXBVbmlmb3JtQnVmZmVyIiwic2V0U3RhdGUiLCJpbnZhbGlkYXRlIiwiY291bnRzQnVmZmVyIiwiTW9kZWwiLCJPYmplY3QiLCJhc3NpZ24iLCJnZXRTaGFkZXJzIiwiaWQiLCJnZW9tZXRyeSIsIkN1YmVHZW9tZXRyeSIsImlzSW5zdGFuY2VkIiwic2hhZGVyQ2FjaGUiLCJ1bmlmb3JtcyIsImdyaWRTaXplIiwiZ3JpZE9yaWdpbiIsImdyaWRPZmZzZXQiLCJtYXhDb3VudEJ1ZmZlciIsImdyaWRPcmlnaW5Mb3ciLCJncmlkT2Zmc2V0TG93IiwiYmluZCIsInRhcmdldCIsIkdMIiwiVU5JRk9STV9CVUZGRVIiLCJpbmRleCIsInJlbmRlciIsInVuYmluZCIsImF0dHJpYnV0ZSIsImJ1ZmZlciIsInByb2dyYW1IYW5kbGUiLCJwcm9ncmFtIiwiaGFuZGxlIiwidW5pZm9ybUJsb2NrSW5kZXgiLCJnZXRVbmlmb3JtQmxvY2tJbmRleCIsInVuaWZvcm1CbG9ja0JpbmRpbmciLCJMYXllciIsImxheWVyTmFtZSJdLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQW9CQTs7QUFDQTs7QUFDQTs7QUFHQTs7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztJQUhPQSxXLEdBQWVDLFUsQ0FBZkQsVztBQUtQLElBQU1FLG1CQUFtQixDQUFDLENBQUQsRUFBSSxDQUFKLEVBQU8sQ0FBUCxFQUFVLEdBQVYsQ0FBekI7QUFDQSxJQUFNQyxtQkFBbUIsQ0FBQyxDQUFELEVBQUksR0FBSixFQUFTLENBQVQsRUFBWSxHQUFaLENBQXpCO0FBQ0EsSUFBTUMsNkJBQTZCLENBQW5DO0FBRUEsSUFBTUMsZUFBZTtBQUNuQkMsWUFBVTtBQUFDQyxVQUFNLFFBQVA7QUFBaUJDLFNBQUssQ0FBdEI7QUFBeUJDLFNBQUssRUFBOUI7QUFBa0NDLFdBQU87QUFBekMsR0FEUztBQUVuQkMsWUFBVTtBQUFDSixVQUFNLFFBQVA7QUFBaUJDLFNBQUssQ0FBdEI7QUFBeUJDLFNBQUssQ0FBOUI7QUFBaUNDLFdBQU87QUFBeEMsR0FGUztBQUduQkUsa0JBQWdCO0FBQUNMLFVBQU0sUUFBUDtBQUFpQkMsU0FBSyxDQUF0QjtBQUF5QkUsV0FBTztBQUFoQyxHQUhHO0FBSW5CRyxZQUFVLElBSlM7QUFLbkJaLFFBQU0sS0FMYTtBQU1uQmEsWUFBVSxLQU5TO0FBTUY7QUFFakJDLFlBQVViLGdCQVJTO0FBU25CYyxZQUFVYixnQkFUUztBQVduQmMsaUJBQWU7QUFYSSxDQUFyQjs7SUFjcUJDLGdCOzs7Ozs7Ozs7Ozs7O2lDQUNOO0FBQ1gsYUFBTztBQUFDQywyQ0FBRDtBQUFLQyw2Q0FBTDtBQUFTQyxpQkFBUyxDQUFDLFdBQUQsRUFBYyxVQUFkLEVBQTBCLFNBQTFCLEVBQXFDLE1BQXJDO0FBQWxCLE9BQVA7QUFDRDs7O3NDQUVpQjtB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QkMsOEJBTjBCO0FBTzFCRyxvQ0FQMEI7QUFRMUJGLDhCQVIwQjtBQVMxQkcsb0NBVDBCO0FBVTFCM0MsMEJBVjBCO0FBVzFCQztBQVgwQixPQUE1QixDQURGO0FBZUF3QyxxQkFBZVMsTUFBZixDQUFzQjtBQUFDTCxnQkFBUUMsbUJBQUdDLGNBQVo7QUFBNEJDLGVBQU8zRDtBQUFuQyxPQUF0QjtBQUNEOzs7NENBRXVCOEQsUyxFQUFXO0FBQUEsVUFDMUJ4QixZQUQwQixHQUNWLEtBQUtaLEtBREssQ0FDMUJZLFlBRDBCO0FBRWpDd0IsZ0JBQVV2QyxNQUFWLENBQWlCO0FBQ2Z3QyxnQkFBUXpCO0FBRE8sT0FBakI7QUFHRDs7O3dDQUVtQk4sSyxFQUFPO0FBQ3pCLFVBQU1ILEtBQUssS0FBS0MsT0FBTCxDQUFhRCxFQUF4QjtBQUNBLFVBQU1tQyxnQkFBZ0JoQyxNQUFNaUMsT0FBTixDQUFjQyxNQUFwQztBQUVBLFVBQU1DLG9CQUFvQnRDLEdBQUd1QyxvQkFBSCxDQUF3QkosYUFBeEIsRUFBdUMsaUJBQXZDLENBQTFCO0FBQ0FuQyxTQUFHd0MsbUJBQUgsQ0FBdUJMLGFBQXZCLEVBQXNDRyxpQkFBdEMsRUFBeURuRSwwQkFBekQ7QUFDRDs7OztFQS9GMkNzRSxXOzs7QUFrRzlDeEQsaUJBQWlCeUQsU0FBakIsR0FBNkIsZUFBN0I7QUFDQXpELGlCQUFpQmIsWUFBakIsR0FBZ0NBLFlBQWhDIiwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChjKSAyMDE1IC0gMjAxNyBVYmVyIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbi8vIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbi8vIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbi8vIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbi8vIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuLy8gZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuLy8gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuLy8gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbi8vIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbi8vIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4vLyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4vLyBUSEUgU09GVFdBUkUuXG5cbmltcG9ydCB7TGF5ZXJ9IGZyb20gJ0BkZWNrLmdsL2NvcmUnO1xuaW1wb3J0IEdMIGZyb20gJ2x1bWEuZ2wvY29uc3RhbnRzJztcbmltcG9ydCB7TW9kZWwsIEN1YmVHZW9tZXRyeSwgZnA2NH0gZnJvbSAnbHVtYS5nbCc7XG5jb25zdCB7ZnA2NExvd1BhcnR9ID0gZnA2NDtcblxuaW1wb3J0IHZzIGZyb20gJy4vZ3B1LWdyaWQtY2VsbC1sYXllci12ZXJ0ZXguZ2xzbCc7XG5pbXBvcnQgZnMgZnJvbSAnLi9ncHUtZ3JpZC1jZWxsLWxheWVyLWZyYWdtZW50Lmdsc2wnO1xuXG5jb25zdCBERUZBVUxUX01JTkNPTE9SID0gWzAsIDAsIDAsIDI1NV07XG5jb25zdCBERUZBVUxUX01BWENPTE9SID0gWzAsIDI1NSwgMCwgMjU1XTtcbmNvbnN0IEFHR1JFR0FUSU9OX0RBVEFfVUJPX0lOREVYID0gMDtcblxuY29uc3QgZGVmYXVsdFByb3BzID0ge1xuICBjZWxsU2l6ZToge3R5cGU6ICdudW1iZXInLCBtaW46IDAsIG1heDogMjAsIHZhbHVlOiAyMH0sXG4gIGNvdmVyYWdlOiB7dHlwZTogJ251bWJlcicsIG1pbjogMCwgbWF4OiAxLCB2YWx1ZTogMX0sXG4gIGVsZXZhdGlvblNjYWxlOiB7dHlwZTogJ251bWJlcicsIG1pbjogMCwgdmFsdWU6IDF9LFxuICBleHRydWRlZDogdHJ1ZSxcbiAgZnA2NDogZmFsc2UsXG4gIHBpY2thYmxlOiBmYWxzZSwgLy8gVE9ETzogYWRkIHBpY2tpbmcgc3VwcG9ydCAocmVhZCBmcm9tIGFnZ3JlZ2F0ZWQgdGV4dHVyZSlcblxuICBtaW5Db2xvcjogREVGQVVMVF9NSU5DT0xPUixcbiAgbWF4Q29sb3I6IERFRkFVTFRfTUFYQ09MT1IsXG5cbiAgbGlnaHRTZXR0aW5nczoge31cbn07XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEdQVUdyaWRDZWxsTGF5ZXIgZXh0ZW5kcyBMYXllciB7XG4gIGdldFNoYWRlcnMoKSB7XG4gICAgcmV0dXJuIHt2cywgZnMsIG1vZHVsZXM6IFsncHJvamVjdDMyJywgJ2xpZ2h0aW5nJywgJ3BpY2tpbmcnLCAnZnA2NCddfTtcbiAgfVxuXG4gIGluaXRpYWxpemVTdGF0ZSgpIHtcbiAgICBjb25zdCBhdHRyaWJ1dGVNYW5hZ2VyID0gdGhpcy5nZXRBdHRyaWJ1dGVNYW5hZ2VyKCk7XG4gICAgYXR0cmlidXRlTWFuYWdlci5hZGRJbnN0YW5jZWQoe1xuICAgICAgaW5zdGFuY2VDb3VudHM6IHtcbiAgICAgICAgc2l6ZTogNCxcbiAgICAgICAgdXBkYXRlOiB0aGlzLmNhbGN1bGF0ZUluc3RhbmNlQ291bnRzLFxuICAgICAgICBub0FsbG9jOiB0cnVlXG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICB1cGRhdGVTdGF0ZSh7cHJvcHMsIG9sZFByb3BzLCBjaGFuZ2VGbGFnc30pIHtcbiAgICBzdXBlci51cGRhdGVTdGF0ZSh7cHJvcHMsIG9sZFByb3BzLCBjaGFuZ2VGbGFnc30pO1xuICAgIC8vIFJlLWdlbmVyYXRlIG1vZGVsIGlmIGdlb21ldHJ5IGNoYW5nZWRcbiAgICBpZiAocHJvcHMuZnA2NCAhPT0gb2xkUHJvcHMuZnA2NCkge1xuICAgICAgY29uc3Qge2dsfSA9IHRoaXMuY29udGV4dDtcbiAgICAgIGlmICh0aGlzLnN0YXRlLm1vZGVsKSB7XG4gICAgICAgIHRoaXMuc3RhdGUubW9kZWwuZGVsZXRlKCk7XG4gICAgICB9XG4gICAgICBjb25zdCBtb2RlbCA9IHRoaXMuX2dldE1vZGVsKGdsKTtcbiAgICAgIHRoaXMuX3NldHVwVW5pZm9ybUJ1ZmZlcihtb2RlbCk7XG4gICAgICB0aGlzLnNldFN0YXRlKHttb2RlbH0pO1xuICAgICAgdGhpcy5zdGF0ZS5hdHRyaWJ1dGVNYW5hZ2VyLmludmFsaWRhdGUoJ2luc3RhbmNlQ291bnRzJyk7XG4gICAgfVxuICAgIGlmIChwcm9wcy5jb3VudHNCdWZmZXIgIT09IG9sZFByb3BzLmNvdW50c0J1ZmZlcikge1xuICAgICAgdGhpcy5zdGF0ZS5hdHRyaWJ1dGVNYW5hZ2VyLmludmFsaWRhdGUoJ2luc3RhbmNlQ291bnRzJyk7XG4gICAgfVxuICB9XG5cbiAgX2dldE1vZGVsKGdsKSB7XG4gICAgcmV0dXJuIG5ldyBNb2RlbChcbiAgICAgIGdsLFxuICAgICAgT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5nZXRTaGFkZXJzKCksIHtcbiAgICAgICAgaWQ6IHRoaXMucHJvcHMuaWQsXG4gICAgICAgIGdlb21ldHJ5OiBuZXcgQ3ViZUdlb21ldHJ5KCksXG4gICAgICAgIGlzSW5zdGFuY2VkOiB0cnVlLFxuICAgICAgICBzaGFkZXJDYWNoZTogdGhpcy5jb250ZXh0LnNoYWRlckNhY2hlXG4gICAgICB9KVxuICAgICk7XG4gIH1cblxuICBkcmF3KHt1bmlmb3Jtc30pIHtcbiAgICBjb25zdCB7XG4gICAgICBjZWxsU2l6ZSxcbiAgICAgIGV4dHJ1ZGVkLFxuICAgICAgZWxldmF0aW9uU2NhbGUsXG4gICAgICBjb3ZlcmFnZSxcbiAgICAgIGdyaWRTaXplLFxuICAgICAgZ3JpZE9yaWdpbixcbiAgICAgIGdyaWRPZmZzZXQsXG4gICAgICBtaW5Db2xvcixcbiAgICAgIG1heENvbG9yLFxuICAgICAgbWF4Q291bnRCdWZmZXJcbiAgICB9ID0gdGhpcy5wcm9wcztcblxuICAgIGNvbnN0IGdyaWRPcmlnaW5Mb3cgPSBbZnA2NExvd1BhcnQoZ3JpZE9yaWdpblswXSksIGZwNjRMb3dQYXJ0KGdyaWRPcmlnaW5bMV0pXTtcbiAgICBjb25zdCBncmlkT2Zmc2V0TG93ID0gW2ZwNjRMb3dQYXJ0KGdyaWRPZmZzZXRbMF0pLCBmcDY0TG93UGFydChncmlkT2Zmc2V0WzFdKV07XG5cbiAgICBtYXhDb3VudEJ1ZmZlci5iaW5kKHt0YXJnZXQ6IEdMLlVOSUZPUk1fQlVGRkVSLCBpbmRleDogQUdHUkVHQVRJT05fREFUQV9VQk9fSU5ERVh9KTtcbiAgICB0aGlzLnN0YXRlLm1vZGVsLnJlbmRlcihcbiAgICAgIE9iamVjdC5hc3NpZ24oe30sIHVuaWZvcm1zLCB7XG4gICAgICAgIGNlbGxTaXplLFxuICAgICAgICBleHRydWRlZCxcbiAgICAgICAgZWxldmF0aW9uU2NhbGUsXG4gICAgICAgIGNvdmVyYWdlLFxuICAgICAgICBncmlkU2l6ZSxcbiAgICAgICAgZ3JpZE9yaWdpbixcbiAgICAgICAgZ3JpZE9yaWdpbkxvdyxcbiAgICAgICAgZ3JpZE9mZnNldCxcbiAgICAgICAgZ3JpZE9mZnNldExvdyxcbiAgICAgICAgbWluQ29sb3IsXG4gICAgICAgIG1heENvbG9yXG4gICAgICB9KVxuICAgICk7XG4gICAgbWF4Q291bnRCdWZmZXIudW5iaW5kKHt0YXJnZXQ6IEdMLlVOSUZPUk1fQlVGRkVSLCBpbmRleDogQUdHUkVHQVRJT05fREFUQV9VQk9fSU5ERVh9KTtcbiAgfVxuXG4gIGNhbGN1bGF0ZUluc3RhbmNlQ291bnRzKGF0dHJpYnV0ZSkge1xuICAgIGNvbnN0IHtjb3VudHNCdWZmZXJ9ID0gdGhpcy5wcm9wcztcbiAgICBhdHRyaWJ1dGUudXBkYXRlKHtcbiAgICAgIGJ1ZmZlcjogY291bnRzQnVmZmVyXG4gICAgfSk7XG4gIH1cblxuICBfc2V0dXBVbmlmb3JtQnVmZmVyKG1vZGVsKSB7XG4gICAgY29uc3QgZ2wgPSB0aGlzLmNvbnRleHQuZ2w7XG4gICAgY29uc3QgcHJvZ3JhbUhhbmRsZSA9IG1vZGVsLnByb2dyYW0uaGFuZGxlO1xuXG4gICAgY29uc3QgdW5pZm9ybUJsb2NrSW5kZXggPSBnbC5nZXRVbmlmb3JtQmxvY2tJbmRleChwcm9ncmFtSGFuZGxlLCAnQWdncmVnYXRpb25EYXRhJyk7XG4gICAgZ2wudW5pZm9ybUJsb2NrQmluZGluZyhwcm9ncmFtSGFuZGxlLCB1bmlmb3JtQmxvY2tJbmRleCwgQUdHUkVHQVRJT05fREFUQV9VQk9fSU5ERVgpO1xuICB9XG59XG5cbkdQVUdyaWRDZWxsTGF5ZXIubGF5ZXJOYW1lID0gJ0dyaWRDZWxsTGF5ZXInO1xuR1BVR3JpZENlbGxMYXllci5kZWZhdWx0UHJvcHMgPSBkZWZhdWx0UHJvcHM7XG4iXX0=