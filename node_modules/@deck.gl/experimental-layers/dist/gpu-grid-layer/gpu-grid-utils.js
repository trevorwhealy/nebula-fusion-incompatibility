"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.pointToDensityGridData = pointToDensityGridData;
exports.alignToCellBoundary = alignToCellBoundary;

var _math = require("math.gl");

var _luma = require("luma.gl");

// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.
var R_EARTH = 6378000;
var fp64LowPart = _luma.fp64.fp64LowPart;
/**
 * Calculate density grid from an array of points
 * @param {array} points
 * @param {function} getPosition - position accessor
 * @param {number} cellSizeMeters - cell size in meters
 * @param {object} gpuGridAggregator - gpu aggregator
 * @param {bool} gpuAggregation - flag to enable gpu aggregation
 * @returns {object} - grid data, cell dimension
 */

function pointToDensityGridData(_ref) {
  var data = _ref.data,
      getPosition = _ref.getPosition,
      cellSizeMeters = _ref.cellSizeMeters,
      gpuGridAggregator = _ref.gpuGridAggregator,
      gpuAggregation = _ref.gpuAggregation,
      _ref$fp = _ref.fp64,
      fp64 = _ref$fp === void 0 ? false : _ref$fp;

  var gridData = _parseData(data, getPosition);

  var gridOffset = _getGridOffset(gridData, cellSizeMeters);

  var opts = _getGPUAggregationParams(gridData, gridOffset);

  var aggregatedData = gpuGridAggregator.run({
    positions: opts.positions,
    positions64xyLow: opts.positions64xyLow,
    weights: opts.weights,
    cellSize: opts.cellSize,
    width: opts.width,
    height: opts.height,
    gridTransformMatrix: opts.gridTransformMatrix,
    useGPU: gpuAggregation,
    fp64: fp64
  });
  var gridSizeX = Math.ceil(opts.width / opts.cellSize[0]);
  var gridSizeY = Math.ceil(opts.height / opts.cellSize[1]);
  return {
    countsBuffer: aggregatedData.countsBuffer,
    maxCountBuffer: aggregatedData.maxCountBuffer,
    gridSize: [gridSizeX, gridSizeY],
    gridOrigin: opts.gridOrigin,
    gridOffset: [opts.gridOffset.xOffset, opts.gridOffset.yOffset]
  };
} // Aligns `inValue` to given `cellSize`


function alignToCellBoundary(inValue, cellSize) {
  var sign = inValue < 0 ? -1 : 1;
  var value = sign < 0 ? Math.abs(inValue) + cellSize : Math.abs(inValue);
  value = Math.floor(value / cellSize) * cellSize;
  return value * sign;
} // Calculate grid parameters


function _getGPUAggregationParams(gridData, gridOffset) {
  var latMin = gridData.latMin,
      latMax = gridData.latMax,
      lngMin = gridData.lngMin,
      lngMax = gridData.lngMax,
      positions = gridData.positions,
      positions64xyLow = gridData.positions64xyLow,
      weights = gridData.weights; // NOTE: this alignment will match grid cell boundaries with existing CPU implementation
  // this gurantees identical aggregation results between current and new layer.
  // We align the origin to cellSize in positive space lng:[0 360], lat:[0 180]
  // After alignment we move it back to original range
  // Origin = [minX, minY]
  // Origin = Origin + [180, 90] // moving to +ve space
  // Origin = Align(Origin, cellSize) //Align to cell boundary
  // Origin = Origin - [180, 90]

  var originY = alignToCellBoundary(latMin + 90, gridOffset.yOffset) - 90;
  var originX = alignToCellBoundary(lngMin + 180, gridOffset.xOffset) - 180; // Setup transformation matrix so that every point is in +ve range

  var gridTransformMatrix = new _math.Matrix4().translate([-1 * originX, -1 * originY, 0]);
  var cellSize = [gridOffset.xOffset, gridOffset.yOffset];
  var gridOrigin = [originX, originY];
  var width = lngMax - lngMin + gridOffset.xOffset;
  var height = latMax - latMin + gridOffset.yOffset;
  return {
    positions: positions,
    positions64xyLow: positions64xyLow,
    weights: weights,
    cellSize: cellSize,
    gridOrigin: gridOrigin,
    width: width,
    height: height,
    gridTransformMatrix: gridTransformMatrix,
    gridOffset: gridOffset
  };
}
/**
 * Based on geometric center of sample points, calculate cellSize in lng/lat (degree) space
 * @param {array} points
 * @param {number} cellSize - unit size in meters
 * @param {function} getPosition - position accessor
 * @returns {yOffset, xOffset} - cellSize size lng/lat (degree) space.
 */


function _getGridOffset(gridData, cellSize) {
  var latMin = gridData.latMin,
      latMax = gridData.latMax;
  var centerLat = (latMin + latMax) / 2;
  return _calculateGridLatLonOffset(cellSize, centerLat);
}
/**
 * calculate grid layer cell size in lat lon based on world unit size
 * and current latitude
 * @param {number} cellSize
 * @param {number} latitude
 * @returns {object} - lat delta and lon delta
 */


function _calculateGridLatLonOffset(cellSize, latitude) {
  var yOffset = _calculateLatOffset(cellSize);

  var xOffset = _calculateLonOffset(latitude, cellSize);

  return {
    yOffset: yOffset,
    xOffset: xOffset
  };
}
/**
 * with a given x-km change, calculate the increment of latitude
 * based on stackoverflow http://stackoverflow.com/questions/7477003
 * @param {number} dy - change in km
 * @return {number} - increment in latitude
 */


function _calculateLatOffset(dy) {
  return dy / R_EARTH * (180 / Math.PI);
}
/**
 * with a given x-km change, and current latitude
 * calculate the increment of longitude
 * based on stackoverflow http://stackoverflow.com/questions/7477003
 * @param {number} lat - latitude of current location (based on city)
 * @param {number} dx - change in km
 * @return {number} - increment in longitude
 */


function _calculateLonOffset(lat, dx) {
  return dx / R_EARTH * (180 / Math.PI) / Math.cos(lat * Math.PI / 180);
} // Parse input data to build positions and boundaries.


function _parseData(data, getPosition) {
  var positions = [];
  var positions64xyLow = [];
  var weights = [];
  var latMin = Infinity;
  var latMax = -Infinity;
  var lngMin = Infinity;
  var lngMax = -Infinity;
  var pLat;
  var pLng;

  for (var p = 0; p < data.length; p++) {
    pLng = getPosition(data[p])[0];
    pLat = getPosition(data[p])[1];
    positions.push(pLng, pLat);
    positions64xyLow.push(fp64LowPart(pLng), fp64LowPart(pLat));
    weights.push(1.0);

    if (Number.isFinite(pLat) && Number.isFinite(pLng)) {
      latMin = pLat < latMin ? pLat : latMin;
      latMax = pLat > latMax ? pLat : latMax;
      lngMin = pLng < lngMin ? pLng : lngMin;
      lngMax = pLng > lngMax ? pLng : lngMax;
    }
  }

  return {
    positions: positions,
    positions64xyLow: positions64xyLow,
    weights: weights,
    latMin: latMin,
    latMax: latMax,
    lngMin: lngMin,
    lngMax: lngMax
  };
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9ncHUtZ3JpZC1sYXllci9ncHUtZ3JpZC11dGlscy5qcyJdLCJuYW1lcyI6WyJSX0VBUlRIIiwiZnA2NExvd1BhcnQiLCJmcDY0VXRpbHMiLCJwb2ludFRvRGVuc2l0eUdyaWREYXRhIiwiZGF0YSIsImdldFBvc2l0aW9uIiwiY2VsbFNpemVNZXRlcnMiLCJncHVHcmlkQWdncmVnYXRvciIsImdwdUFnZ3JlZ2F0aW9uIiwiZnA2NCIsImdyaWREYXRhIiwiX3BhcnNlRGF0YSIsImdyaWRPZmZzZXQiLCJfZ2V0R3JpZE9mZnNldCIsIm9wdHMiLCJfZ2V0R1BVQWdncmVnYXRpb25QYXJhbXMiLCJhZ2dyZWdhdGVkRGF0YSIsInJ1biIsInBvc2l0aW9ucyIsInBvc2l0aW9uczY0eHlMb3ciLCJ3ZWlnaHRzIiwiY2VsbFNpemUiLCJ3aWR0aCIsImhlaWdodCIsImdyaWRUcmFuc2Zvcm1NYXRyaXgiLCJ1c2VHUFUiLCJncmlkU2l6ZVgiLCJNYXRoIiwiY2VpbCIsImdyaWRTaXplWSIsImNvdW50c0J1ZmZlciIsIm1heENvdW50QnVmZmVyIiwiZ3JpZFNpemUiLCJncmlkT3JpZ2luIiwieE9mZnNldCIsInlPZmZzZXQiLCJhbGlnblRvQ2VsbEJvdW5kYXJ5IiwiaW5WYWx1ZSIsInNpZ24iLCJ2YWx1ZSIsImFicyIsImZsb29yIiwibGF0TWluIiwibGF0TWF4IiwibG5nTWluIiwibG5nTWF4Iiwib3JpZ2luWSIsIm9yaWdpblgiLCJNYXRyaXg0IiwidHJhbnNsYXRlIiwiY2VudGVyTGF0IiwiX2NhbGN1bGF0ZUdyaWRMYXRMb25PZmZzZXQiLCJsYXRpdHVkZSIsIl9jYWxjdWxhdGVMYXRPZmZzZXQiLCJfY2FsY3VsYXRlTG9uT2Zmc2V0IiwiZHkiLCJQSSIsImxhdCIsImR4IiwiY29zIiwiSW5maW5pdHkiLCJwTGF0IiwicExuZyIsInAiLCJsZW5ndGgiLCJwdXNoIiwiTnVtYmVyIiwiaXNGaW5pdGUiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBc0JB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TCxDQUFaLEVBQXFCLENBQXJCLENBQVA7QUFDQUYsV0FBT3hELFlBQVlELEtBQUsyRCxDQUFMLENBQVosRUFBcUIsQ0FBckIsQ0FBUDtBQUVBN0MsY0FBVStDLElBQVYsQ0FBZUgsSUFBZixFQUFxQkQsSUFBckI7QUFDQTFDLHFCQUFpQjhDLElBQWpCLENBQXNCaEUsWUFBWTZELElBQVosQ0FBdEIsRUFBeUM3RCxZQUFZNEQsSUFBWixDQUF6QztBQUNBekMsWUFBUTZDLElBQVIsQ0FBYSxHQUFiOztBQUVBLFFBQUlDLE9BQU9DLFFBQVAsQ0FBZ0JOLElBQWhCLEtBQXlCSyxPQUFPQyxRQUFQLENBQWdCTCxJQUFoQixDQUE3QixFQUFvRDtBQUNsRHBCLGVBQVNtQixPQUFPbkIsTUFBUCxHQUFnQm1CLElBQWhCLEdBQXVCbkIsTUFBaEM7QUFDQUMsZUFBU2tCLE9BQU9sQixNQUFQLEdBQWdCa0IsSUFBaEIsR0FBdUJsQixNQUFoQztBQUVBQyxlQUFTa0IsT0FBT2xCLE1BQVAsR0FBZ0JrQixJQUFoQixHQUF1QmxCLE1BQWhDO0FBQ0FDLGVBQVNpQixPQUFPakIsTUFBUCxHQUFnQmlCLElBQWhCLEdBQXVCakIsTUFBaEM7QUFDRDtBQUNGOztBQUVELFNBQU87QUFDTDNCLHdCQURLO0FBRUxDLHNDQUZLO0FBR0xDLG9CQUhLO0FBSUxzQixrQkFKSztBQUtMQyxrQkFMSztBQU1MQyxrQkFOSztBQU9MQztBQVBLLEdBQVA7QUFTRCIsInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAoYykgMjAxNSAtIDIwMTcgVWJlciBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4vLyBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4vLyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4vLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4vLyBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuLy8gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuLy8gVEhFIFNPRlRXQVJFLlxuXG5jb25zdCBSX0VBUlRIID0gNjM3ODAwMDtcblxuaW1wb3J0IHtNYXRyaXg0fSBmcm9tICdtYXRoLmdsJztcbmltcG9ydCB7ZnA2NCBhcyBmcDY0VXRpbHN9IGZyb20gJ2x1bWEuZ2wnO1xuY29uc3Qge2ZwNjRMb3dQYXJ0fSA9IGZwNjRVdGlscztcblxuLyoqXG4gKiBDYWxjdWxhdGUgZGVuc2l0eSBncmlkIGZyb20gYW4gYXJyYXkgb2YgcG9pbnRzXG4gKiBAcGFyYW0ge2FycmF5fSBwb2ludHNcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGdldFBvc2l0aW9uIC0gcG9zaXRpb24gYWNjZXNzb3JcbiAqIEBwYXJhbSB7bnVtYmVyfSBjZWxsU2l6ZU1ldGVycyAtIGNlbGwgc2l6ZSBpbiBtZXRlcnNcbiAqIEBwYXJhbSB7b2JqZWN0fSBncHVHcmlkQWdncmVnYXRvciAtIGdwdSBhZ2dyZWdhdG9yXG4gKiBAcGFyYW0ge2Jvb2x9IGdwdUFnZ3JlZ2F0aW9uIC0gZmxhZyB0byBlbmFibGUgZ3B1IGFnZ3JlZ2F0aW9uXG4gKiBAcmV0dXJucyB7b2JqZWN0fSAtIGdyaWQgZGF0YSwgY2VsbCBkaW1lbnNpb25cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBvaW50VG9EZW5zaXR5R3JpZERhdGEoe1xuICBkYXRhLFxuICBnZXRQb3NpdGlvbixcbiAgY2VsbFNpemVNZXRlcnMsXG4gIGdwdUdyaWRBZ2dyZWdhdG9yLFxuICBncHVBZ2dyZWdhdGlvbixcbiAgZnA2NCA9IGZhbHNlXG59KSB7XG4gIGNvbnN0IGdyaWREYXRhID0gX3BhcnNlRGF0YShkYXRhLCBnZXRQb3NpdGlvbik7XG4gIGNvbnN0IGdyaWRPZmZzZXQgPSBfZ2V0R3JpZE9mZnNldChncmlkRGF0YSwgY2VsbFNpemVNZXRlcnMpO1xuXG4gIGNvbnN0IG9wdHMgPSBfZ2V0R1BVQWdncmVnYXRpb25QYXJhbXMoZ3JpZERhdGEsIGdyaWRPZmZzZXQpO1xuXG4gIGNvbnN0IGFnZ3JlZ2F0ZWREYXRhID0gZ3B1R3JpZEFnZ3JlZ2F0b3IucnVuKHtcbiAgICBwb3NpdGlvbnM6IG9wdHMucG9zaXRpb25zLFxuICAgIHBvc2l0aW9uczY0eHlMb3c6IG9wdHMucG9zaXRpb25zNjR4eUxvdyxcbiAgICB3ZWlnaHRzOiBvcHRzLndlaWdodHMsXG4gICAgY2VsbFNpemU6IG9wdHMuY2VsbFNpemUsXG4gICAgd2lkdGg6IG9wdHMud2lkdGgsXG4gICAgaGVpZ2h0OiBvcHRzLmhlaWdodCxcbiAgICBncmlkVHJhbnNmb3JtTWF0cml4OiBvcHRzLmdyaWRUcmFuc2Zvcm1NYXRyaXgsXG4gICAgdXNlR1BVOiBncHVBZ2dyZWdhdGlvbixcbiAgICBmcDY0XG4gIH0pO1xuXG4gIGNvbnN0IGdyaWRTaXplWCA9IE1hdGguY2VpbChvcHRzLndpZHRoIC8gb3B0cy5jZWxsU2l6ZVswXSk7XG4gIGNvbnN0IGdyaWRTaXplWSA9IE1hdGguY2VpbChvcHRzLmhlaWdodCAvIG9wdHMuY2VsbFNpemVbMV0pO1xuXG4gIHJldHVybiB7XG4gICAgY291bnRzQnVmZmVyOiBhZ2dyZWdhdGVkRGF0YS5jb3VudHNCdWZmZXIsXG4gICAgbWF4Q291bnRCdWZmZXI6IGFnZ3JlZ2F0ZWREYXRhLm1heENvdW50QnVmZmVyLFxuICAgIGdyaWRTaXplOiBbZ3JpZFNpemVYLCBncmlkU2l6ZVldLFxuICAgIGdyaWRPcmlnaW46IG9wdHMuZ3JpZE9yaWdpbixcbiAgICBncmlkT2Zmc2V0OiBbb3B0cy5ncmlkT2Zmc2V0LnhPZmZzZXQsIG9wdHMuZ3JpZE9mZnNldC55T2Zmc2V0XVxuICB9O1xufVxuXG4vLyBBbGlnbnMgYGluVmFsdWVgIHRvIGdpdmVuIGBjZWxsU2l6ZWBcbmV4cG9ydCBmdW5jdGlvbiBhbGlnblRvQ2VsbEJvdW5kYXJ5KGluVmFsdWUsIGNlbGxTaXplKSB7XG4gIGNvbnN0IHNpZ24gPSBpblZhbHVlIDwgMCA/IC0xIDogMTtcblxuICBsZXQgdmFsdWUgPSBzaWduIDwgMCA/IE1hdGguYWJzKGluVmFsdWUpICsgY2VsbFNpemUgOiBNYXRoLmFicyhpblZhbHVlKTtcblxuICB2YWx1ZSA9IE1hdGguZmxvb3IodmFsdWUgLyBjZWxsU2l6ZSkgKiBjZWxsU2l6ZTtcblxuICByZXR1cm4gdmFsdWUgKiBzaWduO1xufVxuXG4vLyBDYWxjdWxhdGUgZ3JpZCBwYXJhbWV0ZXJzXG5mdW5jdGlvbiBfZ2V0R1BVQWdncmVnYXRpb25QYXJhbXMoZ3JpZERhdGEsIGdyaWRPZmZzZXQpIHtcbiAgY29uc3Qge2xhdE1pbiwgbGF0TWF4LCBsbmdNaW4sIGxuZ01heCwgcG9zaXRpb25zLCBwb3NpdGlvbnM2NHh5TG93LCB3ZWlnaHRzfSA9IGdyaWREYXRhO1xuXG4gIC8vIE5PVEU6IHRoaXMgYWxpZ25tZW50IHdpbGwgbWF0Y2ggZ3JpZCBjZWxsIGJvdW5kYXJpZXMgd2l0aCBleGlzdGluZyBDUFUgaW1wbGVtZW50YXRpb25cbiAgLy8gdGhpcyBndXJhbnRlZXMgaWRlbnRpY2FsIGFnZ3JlZ2F0aW9uIHJlc3VsdHMgYmV0d2VlbiBjdXJyZW50IGFuZCBuZXcgbGF5ZXIuXG4gIC8vIFdlIGFsaWduIHRoZSBvcmlnaW4gdG8gY2VsbFNpemUgaW4gcG9zaXRpdmUgc3BhY2UgbG5nOlswIDM2MF0sIGxhdDpbMCAxODBdXG4gIC8vIEFmdGVyIGFsaWdubWVudCB3ZSBtb3ZlIGl0IGJhY2sgdG8gb3JpZ2luYWwgcmFuZ2VcbiAgLy8gT3JpZ2luID0gW21pblgsIG1pblldXG4gIC8vIE9yaWdpbiA9IE9yaWdpbiArIFsxODAsIDkwXSAvLyBtb3ZpbmcgdG8gK3ZlIHNwYWNlXG4gIC8vIE9yaWdpbiA9IEFsaWduKE9yaWdpbiwgY2VsbFNpemUpIC8vQWxpZ24gdG8gY2VsbCBib3VuZGFyeVxuICAvLyBPcmlnaW4gPSBPcmlnaW4gLSBbMTgwLCA5MF1cbiAgY29uc3Qgb3JpZ2luWSA9IGFsaWduVG9DZWxsQm91bmRhcnkobGF0TWluICsgOTAsIGdyaWRPZmZzZXQueU9mZnNldCkgLSA5MDtcbiAgY29uc3Qgb3JpZ2luWCA9IGFsaWduVG9DZWxsQm91bmRhcnkobG5nTWluICsgMTgwLCBncmlkT2Zmc2V0LnhPZmZzZXQpIC0gMTgwO1xuXG4gIC8vIFNldHVwIHRyYW5zZm9ybWF0aW9uIG1hdHJpeCBzbyB0aGF0IGV2ZXJ5IHBvaW50IGlzIGluICt2ZSByYW5nZVxuICBjb25zdCBncmlkVHJhbnNmb3JtTWF0cml4ID0gbmV3IE1hdHJpeDQoKS50cmFuc2xhdGUoWy0xICogb3JpZ2luWCwgLTEgKiBvcmlnaW5ZLCAwXSk7XG5cbiAgY29uc3QgY2VsbFNpemUgPSBbZ3JpZE9mZnNldC54T2Zmc2V0LCBncmlkT2Zmc2V0LnlPZmZzZXRdO1xuICBjb25zdCBncmlkT3JpZ2luID0gW29yaWdpblgsIG9yaWdpblldO1xuICBjb25zdCB3aWR0aCA9IGxuZ01heCAtIGxuZ01pbiArIGdyaWRPZmZzZXQueE9mZnNldDtcbiAgY29uc3QgaGVpZ2h0ID0gbGF0TWF4IC0gbGF0TWluICsgZ3JpZE9mZnNldC55T2Zmc2V0O1xuXG4gIHJldHVybiB7XG4gICAgcG9zaXRpb25zLFxuICAgIHBvc2l0aW9uczY0eHlMb3csXG4gICAgd2VpZ2h0cyxcbiAgICBjZWxsU2l6ZSxcbiAgICBncmlkT3JpZ2luLFxuICAgIHdpZHRoLFxuICAgIGhlaWdodCxcbiAgICBncmlkVHJhbnNmb3JtTWF0cml4LFxuICAgIGdyaWRPZmZzZXRcbiAgfTtcbn1cblxuLyoqXG4gKiBCYXNlZCBvbiBnZW9tZXRyaWMgY2VudGVyIG9mIHNhbXBsZSBwb2ludHMsIGNhbGN1bGF0ZSBjZWxsU2l6ZSBpbiBsbmcvbGF0IChkZWdyZWUpIHNwYWNlXG4gKiBAcGFyYW0ge2FycmF5fSBwb2ludHNcbiAqIEBwYXJhbSB7bnVtYmVyfSBjZWxsU2l6ZSAtIHVuaXQgc2l6ZSBpbiBtZXRlcnNcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGdldFBvc2l0aW9uIC0gcG9zaXRpb24gYWNjZXNzb3JcbiAqIEByZXR1cm5zIHt5T2Zmc2V0LCB4T2Zmc2V0fSAtIGNlbGxTaXplIHNpemUgbG5nL2xhdCAoZGVncmVlKSBzcGFjZS5cbiAqL1xuXG5mdW5jdGlvbiBfZ2V0R3JpZE9mZnNldChncmlkRGF0YSwgY2VsbFNpemUpIHtcbiAgY29uc3Qge2xhdE1pbiwgbGF0TWF4fSA9IGdyaWREYXRhO1xuXG4gIGNvbnN0IGNlbnRlckxhdCA9IChsYXRNaW4gKyBsYXRNYXgpIC8gMjtcblxuICByZXR1cm4gX2NhbGN1bGF0ZUdyaWRMYXRMb25PZmZzZXQoY2VsbFNpemUsIGNlbnRlckxhdCk7XG59XG5cbi8qKlxuICogY2FsY3VsYXRlIGdyaWQgbGF5ZXIgY2VsbCBzaXplIGluIGxhdCBsb24gYmFzZWQgb24gd29ybGQgdW5pdCBzaXplXG4gKiBhbmQgY3VycmVudCBsYXRpdHVkZVxuICogQHBhcmFtIHtudW1iZXJ9IGNlbGxTaXplXG4gKiBAcGFyYW0ge251bWJlcn0gbGF0aXR1ZGVcbiAqIEByZXR1cm5zIHtvYmplY3R9IC0gbGF0IGRlbHRhIGFuZCBsb24gZGVsdGFcbiAqL1xuZnVuY3Rpb24gX2NhbGN1bGF0ZUdyaWRMYXRMb25PZmZzZXQoY2VsbFNpemUsIGxhdGl0dWRlKSB7XG4gIGNvbnN0IHlPZmZzZXQgPSBfY2FsY3VsYXRlTGF0T2Zmc2V0KGNlbGxTaXplKTtcbiAgY29uc3QgeE9mZnNldCA9IF9jYWxjdWxhdGVMb25PZmZzZXQobGF0aXR1ZGUsIGNlbGxTaXplKTtcbiAgcmV0dXJuIHt5T2Zmc2V0LCB4T2Zmc2V0fTtcbn1cblxuLyoqXG4gKiB3aXRoIGEgZ2l2ZW4geC1rbSBjaGFuZ2UsIGNhbGN1bGF0ZSB0aGUgaW5jcmVtZW50IG9mIGxhdGl0dWRlXG4gKiBiYXNlZCBvbiBzdGFja292ZXJmbG93IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNzQ3NzAwM1xuICogQHBhcmFtIHtudW1iZXJ9IGR5IC0gY2hhbmdlIGluIGttXG4gKiBAcmV0dXJuIHtudW1iZXJ9IC0gaW5jcmVtZW50IGluIGxhdGl0dWRlXG4gKi9cbmZ1bmN0aW9uIF9jYWxjdWxhdGVMYXRPZmZzZXQoZHkpIHtcbiAgcmV0dXJuIChkeSAvIFJfRUFSVEgpICogKDE4MCAvIE1hdGguUEkpO1xufVxuXG4vKipcbiAqIHdpdGggYSBnaXZlbiB4LWttIGNoYW5nZSwgYW5kIGN1cnJlbnQgbGF0aXR1ZGVcbiAqIGNhbGN1bGF0ZSB0aGUgaW5jcmVtZW50IG9mIGxvbmdpdHVkZVxuICogYmFzZWQgb24gc3RhY2tvdmVyZmxvdyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzc0NzcwMDNcbiAqIEBwYXJhbSB7bnVtYmVyfSBsYXQgLSBsYXRpdHVkZSBvZiBjdXJyZW50IGxvY2F0aW9uIChiYXNlZCBvbiBjaXR5KVxuICogQHBhcmFtIHtudW1iZXJ9IGR4IC0gY2hhbmdlIGluIGttXG4gKiBAcmV0dXJuIHtudW1iZXJ9IC0gaW5jcmVtZW50IGluIGxvbmdpdHVkZVxuICovXG5mdW5jdGlvbiBfY2FsY3VsYXRlTG9uT2Zmc2V0KGxhdCwgZHgpIHtcbiAgcmV0dXJuICgoZHggLyBSX0VBUlRIKSAqICgxODAgLyBNYXRoLlBJKSkgLyBNYXRoLmNvcygobGF0ICogTWF0aC5QSSkgLyAxODApO1xufVxuXG4vLyBQYXJzZSBpbnB1dCBkYXRhIHRvIGJ1aWxkIHBvc2l0aW9ucyBhbmQgYm91bmRhcmllcy5cbmZ1bmN0aW9uIF9wYXJzZURhdGEoZGF0YSwgZ2V0UG9zaXRpb24pIHtcbiAgY29uc3QgcG9zaXRpb25zID0gW107XG4gIGNvbnN0IHBvc2l0aW9uczY0eHlMb3cgPSBbXTtcbiAgY29uc3Qgd2VpZ2h0cyA9IFtdO1xuXG4gIGxldCBsYXRNaW4gPSBJbmZpbml0eTtcbiAgbGV0IGxhdE1heCA9IC1JbmZpbml0eTtcbiAgbGV0IGxuZ01pbiA9IEluZmluaXR5O1xuICBsZXQgbG5nTWF4ID0gLUluZmluaXR5O1xuICBsZXQgcExhdDtcbiAgbGV0IHBMbmc7XG4gIGZvciAobGV0IHAgPSAwOyBwIDwgZGF0YS5sZW5ndGg7IHArKykge1xuICAgIHBMbmcgPSBnZXRQb3NpdGlvbihkYXRhW3BdKVswXTtcbiAgICBwTGF0ID0gZ2V0UG9zaXRpb24oZGF0YVtwXSlbMV07XG5cbiAgICBwb3NpdGlvbnMucHVzaChwTG5nLCBwTGF0KTtcbiAgICBwb3NpdGlvbnM2NHh5TG93LnB1c2goZnA2NExvd1BhcnQocExuZyksIGZwNjRMb3dQYXJ0KHBMYXQpKTtcbiAgICB3ZWlnaHRzLnB1c2goMS4wKTtcblxuICAgIGlmIChOdW1iZXIuaXNGaW5pdGUocExhdCkgJiYgTnVtYmVyLmlzRmluaXRlKHBMbmcpKSB7XG4gICAgICBsYXRNaW4gPSBwTGF0IDwgbGF0TWluID8gcExhdCA6IGxhdE1pbjtcbiAgICAgIGxhdE1heCA9IHBMYXQgPiBsYXRNYXggPyBwTGF0IDogbGF0TWF4O1xuXG4gICAgICBsbmdNaW4gPSBwTG5nIDwgbG5nTWluID8gcExuZyA6IGxuZ01pbjtcbiAgICAgIGxuZ01heCA9IHBMbmcgPiBsbmdNYXggPyBwTG5nIDogbG5nTWF4O1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgcG9zaXRpb25zLFxuICAgIHBvc2l0aW9uczY0eHlMb3csXG4gICAgd2VpZ2h0cyxcbiAgICBsYXRNaW4sXG4gICAgbGF0TWF4LFxuICAgIGxuZ01pbixcbiAgICBsbmdNYXhcbiAgfTtcbn1cbiJdfQ==