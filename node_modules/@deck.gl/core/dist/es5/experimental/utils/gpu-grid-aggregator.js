"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _constants = _interopRequireDefault(require("luma.gl/constants"));

var _luma = require("luma.gl");

var _core = require("@deck.gl/core");

var _assert = _interopRequireDefault(require("assert"));

var _viewportMercatorProject = require("viewport-mercator-project");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _instanceof(left, right) { if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) { return right[Symbol.hasInstance](left); } else { return left instanceof right; } }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _classCallCheck(instance, Constructor) { if (!_instanceof(instance, Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var fp64ifyMatrix4 = _luma.fp64.fp64ifyMatrix4;
var IDENTITY_MATRIX = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
var PIXEL_SIZE = 4; // RGBA32F

var AGGREGATE_TO_GRID_VS = "attribute vec2 positions;\nattribute vec2 positions64xyLow;\nattribute float weights;\nuniform vec2 windowSize;\nuniform vec2 cellSize;\nuniform vec2 gridSize;\nuniform mat4 uProjectionMatrix;\nuniform bool projectPoints;\n\nvarying float vWeights;\n\nvec2 project_to_pixel(vec2 pos) {\n  vec4 position = vec4(pos, 0., 1.);\n  vec4 result =  uProjectionMatrix * position;\n  return result.xy/result.w;\n}\n\nvoid main(void) {\n\n  vWeights = weights;\n\n  vec2 windowPos = positions;\n  vec2 windowPos64xyLow = positions64xyLow;\n  if (projectPoints) {\n    windowPos = project_position(windowPos);\n  }\n\n  windowPos = project_to_pixel(windowPos);\n\n  // Transform (0,0):windowSize -> (0, 0): gridSize\n  vec2 pos = floor(windowPos / cellSize);\n\n  // Transform (0,0):gridSize -> (-1, -1):(1,1)\n  pos = (pos * (2., 2.) / (gridSize)) - (1., 1.);\n\n  // Move to pixel center, pixel-size in screen sapce (2/gridSize) * 0.5 => 1/gridSize\n  vec2 offset = 1.0 / gridSize;\n  pos = pos + offset;\n\n  gl_Position = vec4(pos, 0.0, 1.0);\n}\n";
var AGGREGATE_TO_GRID_VS_FP64 = "attribute vec2 positions;\nattribute vec2 positions64xyLow;\nattribute float weights;\nuniform vec2 windowSize;\nuniform vec2 cellSize;\nuniform vec2 gridSize;\nuniform vec2 uProjectionMatrixFP64[16];\nuniform bool projectPoints;\n\nvarying float vWeights;\n\nvoid project_to_pixel(vec2 pos, vec2 pos64xyLow, out vec2 pixelXY64[2]) {\n\n  vec2 result64[4];\n  vec2 position64[4];\n  position64[0] = vec2(pos.x, pos64xyLow.x);\n  position64[1] = vec2(pos.y, pos64xyLow.y);\n  position64[2] = vec2(0., 0.);\n  position64[3] = vec2(1., 0.);\n  mat4_vec4_mul_fp64(uProjectionMatrixFP64, position64,\n  result64);\n\n  pixelXY64[0] = div_fp64(result64[0], result64[3]);\n  pixelXY64[1] = div_fp64(result64[1], result64[3]);\n}\n\nvoid main(void) {\n\n  vWeights = weights;\n\n  vec2 windowPos = positions;\n  vec2 windowPos64xyLow = positions64xyLow;\n  if (projectPoints) {\n    vec2 projectedXY[2];\n    project_position_fp64(windowPos, windowPos64xyLow, projectedXY);\n    windowPos.x = projectedXY[0].x;\n    windowPos.y = projectedXY[1].x;\n    windowPos64xyLow.x = projectedXY[0].y;\n    windowPos64xyLow.y = projectedXY[1].y;\n  }\n\n  vec2 pixelXY64[2];\n  project_to_pixel(windowPos, windowPos64xyLow, pixelXY64);\n\n  // Transform (0,0):windowSize -> (0, 0): gridSize\n  vec2 gridXY64[2];\n  gridXY64[0] = div_fp64(pixelXY64[0], vec2(cellSize.x, 0));\n  gridXY64[1] = div_fp64(pixelXY64[1], vec2(cellSize.y, 0));\n  float x = floor(gridXY64[0].x);\n  float y = floor(gridXY64[1].x);\n  vec2 pos = vec2(x, y);\n\n  // Transform (0,0):gridSize -> (-1, -1):(1,1)\n  pos = (pos * (2., 2.) / (gridSize)) - (1., 1.);\n\n  // Move to pixel center, pixel-size in screen sapce (2/gridSize) * 0.5 => 1/gridSize\n  vec2 offset = 1.0 / gridSize;\n  pos = pos + offset;\n\n  gl_Position = vec4(pos, 0.0, 1.0);\n}\n";
var AGGREGATE_TO_GRID_FS = "precision highp float;\n\nvarying float vWeights;\n\nvoid main(void) {\n  gl_FragColor = vec4(1., vWeights, 0, 0.0);\n}\n";
var AGGREGATE_ALL_VS_FP64 = "#version 300 es\n\nin vec2 position;\nuniform vec2 gridSize;\n\nout vec2 vTextureCoord;\nvoid main(void) {\n  // Map each position to single pixel\n  vec2 pos = vec2(-1.0, -1.0);\n\n  // Move to pixel center, pixel-size in screen sapce (2/gridSize) * 0.5 => 1/gridSize\n  vec2 offset = 1.0 / gridSize;\n  pos = pos + offset;\n\n  gl_Position = vec4(pos, 0.0, 1.0);\n\n  float yIndex = floor(float(gl_InstanceID) / gridSize[0]);\n  float xIndex = float(gl_InstanceID) - (yIndex * gridSize[0]);\n\n  vec2 yIndexFP64 = vec2(yIndex, 0.);\n  vec2 xIndexFP64 = vec2(xIndex, 0.);\n  vec2 gridSizeYFP64 = vec2(gridSize[1], 0.);\n  vec2 gridSizeXFP64 = vec2(gridSize[0], 0.);\n\n  vec2 texCoordXFP64 = div_fp64(yIndexFP64, gridSizeYFP64);\n  vec2 texCoordYFP64 = div_fp64(xIndexFP64, gridSizeXFP64);\n\n  vTextureCoord = vec2(texCoordYFP64.x, texCoordXFP64.x);\n}\n";
var AGGREGATE_ALL_FS = "#version 300 es\nprecision highp float;\n\nin vec2 vTextureCoord;\nuniform sampler2D uSampler;\nout vec4 fragColor;\nvoid main(void) {\n  vec4 textureColor = texture(uSampler, vec2(vTextureCoord.s, vTextureCoord.t));\n  // Red: total count, Green: total weight, Alpha: maximum wieght\n  fragColor = vec4(textureColor.r, textureColor.g, 0., textureColor.g);\n}\n";
var DEFAULT_CHANGE_FLAGS = {
  dataChanged: true,
  viewportChanged: true,
  cellSizeChanged: true
};

var GPUGridAggregator =
/*#__PURE__*/
function () {
  _createClass(GPUGridAggregator, null, [{
    key: "getAggregationData",
    // Decode and return aggregation data of given pixel.
    value: function getAggregationData(_ref) {
      var countsData = _ref.countsData,
          maxCountData = _ref.maxCountData,
          pixelIndex = _ref.pixelIndex;
      (0, _assert.default)(countsData.length >= (pixelIndex + 1) * PIXEL_SIZE);
      (0, _assert.default)(maxCountData.length === PIXEL_SIZE);
      var index = pixelIndex * PIXEL_SIZE;
      var cellCount = countsData[index];
      var cellWeight = countsData[index + 1];
      var totalCount = maxCountData[0];
      var totalWeight = maxCountData[1];
      var maxCellWieght = maxCountData[3];
      return {
        cellCount: cellCount,
        cellWeight: cellWeight,
        totalCount: totalCount,
        totalWeight: totalWeight,
        maxCellWieght: maxCellWieght
      };
    } // Decodes and retuns counts and weights of all cells

  }, {
    key: "getCellData",
    value: function getCellData(_ref2) {
      var countsData = _ref2.countsData;
      var cellWeights = [];
      var cellCounts = [];

      for (var index = 0; index < countsData.length; index += 4) {
        cellCounts.push(countsData[index]);
        cellWeights.push(countsData[index + 1]);
      }

      return {
        cellCounts: cellCounts,
        cellWeights: cellWeights
      };
    }
  }]);

  function GPUGridAggregator(gl) {
    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, GPUGridAggregator);

    this.id = opts.id || 'gpu-grid-aggregator';
    this.shaderCache = opts.shaderCache || null;
    this.gl = gl;
    this.state = {};
    this._hasGPUSupport = (0, _luma.isWebGL2)(gl) && (0, _luma.hasFeatures)(this.gl, _luma.FEATURES.BLEND_EQUATION_MINMAX, _luma.FEATURES.COLOR_ATTACHMENT_RGBA32F, _luma.FEATURES.TEXTURE_FILTER_LINEAR_FLOAT);

    if (this._hasGPUSupport) {
      this._setupGPUResources();
    }
  } // Perform aggregation and retun the results


  _createClass(GPUGridAggregator, [{
    key: "run",
    value: function run() {
      var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          positions = _ref3.positions,
          positions64xyLow = _ref3.positions64xyLow,
          weights = _ref3.weights,
          _ref3$changeFlags = _ref3.changeFlags,
          changeFlags = _ref3$changeFlags === void 0 ? DEFAULT_CHANGE_FLAGS : _ref3$changeFlags,
          cellSize = _ref3.cellSize,
          viewport = _ref3.viewport,
          width = _ref3.width,
          height = _ref3.height,
          _ref3$countsBuffer = _ref3.countsBuffer,
          countsBuffer = _ref3$countsBuffer === void 0 ? null : _ref3$countsBuffer,
          _ref3$maxCountBuffer = _ref3.maxCountBuffer,
          maxCountBuffer = _ref3$maxCountBuffer === void 0 ? null : _ref3$maxCountBuffer,
          _ref3$gridTransformMa = _ref3.gridTransformMatrix,
          gridTransformMatrix = _ref3$gridTransformMa === void 0 ? null : _ref3$gridTransformMa,
          _ref3$projectPoints = _ref3.projectPoints,
          projectPoints = _ref3$projectPoints === void 0 ? false : _ref3$projectPoints,
          _ref3$useGPU = _ref3.useGPU,
          useGPU = _ref3$useGPU === void 0 ? true : _ref3$useGPU,
          _ref3$fp = _ref3.fp64,
          fp64 = _ref3$fp === void 0 ? false : _ref3$fp;

      if (this.state.useGPU !== useGPU) {
        changeFlags = DEFAULT_CHANGE_FLAGS;
      }

      this._setState({
        useGPU: useGPU
      });

      var transformMatrix = gridTransformMatrix || viewport && viewport.pixelProjectionMatrix || IDENTITY_MATRIX;
      var aggregationParams = {
        positions: positions,
        positions64xyLow: positions64xyLow,
        weights: weights,
        changeFlags: changeFlags,
        cellSize: cellSize,
        viewport: viewport,
        gridTransformMatrix: transformMatrix,
        countsBuffer: countsBuffer,
        maxCountBuffer: maxCountBuffer,
        projectPoints: projectPoints,
        fp64: fp64
      };

      this._updateGridSize({
        viewport: viewport,
        cellSize: cellSize,
        width: width,
        height: height
      });

      if (this._hasGPUSupport && useGPU) {
        return this._runAggregationOnGPU(aggregationParams);
      }

      if (useGPU) {
        _core.log.warn('ScreenGridAggregator: GPU Aggregation not supported, falling back to CPU');
      }

      return this._runAggregationOnCPU(aggregationParams);
    } // PRIVATE

  }, {
    key: "_getAggregateData",
    value: function _getAggregateData(opts) {
      var countsBuffer = opts.countsBuffer,
          maxCountBuffer = opts.maxCountBuffer;
      countsBuffer = this.gridAggregationFramebuffer.readPixelsToBuffer({
        buffer: countsBuffer,
        type: _constants.default.FLOAT
      });
      maxCountBuffer = this.allAggregrationFramebuffer.readPixelsToBuffer({
        width: 1,
        height: 1,
        type: _constants.default.FLOAT,
        buffer: maxCountBuffer
      });
      return {
        countsBuffer: countsBuffer,
        countsTexture: this.gridAggregationFramebuffer.texture,
        maxCountBuffer: maxCountBuffer,
        maxCountTexture: this.allAggregrationFramebuffer.texture
      };
    }
  }, {
    key: "_getAggregationModel",
    value: function _getAggregationModel() {
      var fp64 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      var gl = this.gl,
          shaderCache = this.shaderCache;
      return new _luma.Model(gl, {
        id: 'Gird-Aggregation-Model',
        vs: fp64 ? AGGREGATE_TO_GRID_VS_FP64 : AGGREGATE_TO_GRID_VS,
        fs: AGGREGATE_TO_GRID_FS,
        modules: fp64 ? ['fp64', 'project64'] : ['project32'],
        shaderCache: shaderCache,
        vertexCount: 0,
        drawMode: _constants.default.POINTS
      });
    }
  }, {
    key: "_getAllAggregationModel",
    value: function _getAllAggregationModel() {
      var fp64 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      var gl = this.gl,
          shaderCache = this.shaderCache;
      return new _luma.Model(gl, {
        id: 'All-Aggregation-Model',
        vs: AGGREGATE_ALL_VS_FP64,
        fs: AGGREGATE_ALL_FS,
        modules: ['fp64'],
        shaderCache: shaderCache,
        vertexCount: 1,
        drawMode: _constants.default.POINTS,
        isInstanced: true,
        instanceCount: 0,
        attributes: {
          position: new _luma.Buffer(gl, {
            size: 2,
            data: new Float32Array([0, 0])
          })
        }
      });
    }
  }, {
    key: "_projectPositions",
    value: function _projectPositions(opts) {
      var projectedPositions = this.state.projectedPositions;

      if (!projectedPositions || opts.changeFlags.dataChanged || opts.changeFlags.viewportChanged) {
        var positions = opts.positions,
            viewport = opts.viewport;
        projectedPositions = [];

        for (var index = 0; index < positions.length; index += 2) {
          var _viewport$projectFlat = viewport.projectFlat([positions[index], positions[index + 1]]),
              _viewport$projectFlat2 = _slicedToArray(_viewport$projectFlat, 2),
              x = _viewport$projectFlat2[0],
              y = _viewport$projectFlat2[1];

          projectedPositions.push(x, y);
        }

        this._setState({
          projectedPositions: projectedPositions
        });
      }
    }
  }, {
    key: "_renderAggregateData",
    value: function _renderAggregateData(opts) {
      var cellSize = opts.cellSize,
          viewport = opts.viewport,
          gridTransformMatrix = opts.gridTransformMatrix,
          projectPoints = opts.projectPoints;
      var _this$state = this.state,
          numCol = _this$state.numCol,
          numRow = _this$state.numRow,
          windowSize = _this$state.windowSize;
      var gl = this.gl,
          gridAggregationFramebuffer = this.gridAggregationFramebuffer,
          gridAggregationModel = this.gridAggregationModel,
          allAggregrationFramebuffer = this.allAggregrationFramebuffer,
          allAggregationModel = this.allAggregationModel;
      var uProjectionMatrixFP64 = fp64ifyMatrix4(gridTransformMatrix);
      var gridSize = [numCol, numRow];
      gridAggregationFramebuffer.bind();
      gl.viewport(0, 0, gridSize[0], gridSize[1]);
      gl.clear(gl.COLOR_BUFFER_BIT);
      gridAggregationModel.draw({
        parameters: {
          clearColor: [0, 0, 0, 0],
          clearDepth: 0,
          blend: true,
          depthTest: false,
          blendEquation: _constants.default.FUNC_ADD,
          blendFunc: [_constants.default.ONE, _constants.default.ONE]
        },
        moduleSettings: {
          viewport: viewport
        },
        uniforms: {
          windowSize: windowSize,
          cellSize: cellSize,
          gridSize: gridSize,
          uProjectionMatrix: gridTransformMatrix,
          uProjectionMatrixFP64: uProjectionMatrixFP64,
          projectPoints: projectPoints,
          ONE: 1.0
        }
      });
      gridAggregationFramebuffer.unbind();
      allAggregrationFramebuffer.bind();
      gl.viewport(0, 0, gridSize[0], gridSize[1]);
      gl.clear(gl.COLOR_BUFFER_BIT);
      allAggregationModel.draw({
        parameters: {
          clearColor: [0, 0, 0, 0],
          clearDepth: 0,
          blend: true,
          depthTest: false,
          blendEquation: [_constants.default.FUNC_ADD, _constants.default.MAX],
          blendFunc: [_constants.default.ONE, _constants.default.ONE]
        },
        uniforms: {
          uSampler: gridAggregationFramebuffer.texture,
          gridSize: gridSize,
          ONE: 1.0
        }
      });
      allAggregrationFramebuffer.unbind();
    }
    /* eslint-disable max-statements */

  }, {
    key: "_runAggregationOnCPU",
    value: function _runAggregationOnCPU(opts) {
      var ELEMENTCOUNT = 4;
      var positions = opts.positions,
          weights = opts.weights,
          cellSize = opts.cellSize,
          projectPoints = opts.projectPoints,
          gridTransformMatrix = opts.gridTransformMatrix;
      var countsBuffer = opts.countsBuffer,
          maxCountBuffer = opts.maxCountBuffer;
      var _this$state2 = this.state,
          numCol = _this$state2.numCol,
          numRow = _this$state2.numRow; // Each element contains 4 floats to match with GPU ouput

      var counts = new Float32Array(numCol * numRow * ELEMENTCOUNT);
      var pos = positions;

      if (projectPoints) {
        this._projectPositions(opts);

        pos = this.state.projectedPositions;
      }

      counts.fill(0);
      var maxWeight = 0;
      var totalCount = 0;
      var totalWeight = 0;

      for (var index = 0; index < pos.length; index += 2) {
        var gridPos = (0, _viewportMercatorProject.worldToPixels)([pos[index], pos[index + 1], 0], gridTransformMatrix);
        var x = gridPos[0];
        var y = gridPos[1];
        var weight = weights ? weights[index / 2] : 1;
        (0, _assert.default)(Number.isFinite(weight));
        var colId = Math.floor(x / cellSize[0]);
        var rowId = Math.floor(y / cellSize[1]);

        if (colId >= 0 && colId < numCol && rowId >= 0 && rowId < numRow) {
          var i = (colId + rowId * numCol) * ELEMENTCOUNT;
          counts[i]++;
          counts[i + 1] += weight;
          totalCount += 1;
          totalWeight += weight;

          if (counts[i + 1] > maxWeight) {
            maxWeight = counts[i + 1];
          }
        }
      }

      var maxCountBufferData = new Float32Array(ELEMENTCOUNT); // Store total count value in Red/X channel

      maxCountBufferData[0] = totalCount; // Store total weight value in Green/Y channel

      maxCountBufferData[1] = totalWeight; // Store max weight value in alpha/W channel.

      maxCountBufferData[3] = maxWeight; // Load data to WebGL buffer.

      if (countsBuffer) {
        countsBuffer.subData({
          data: counts
        });
      } else {
        countsBuffer = new _luma.Buffer(this.gl, {
          data: counts
        });
      }

      if (maxCountBuffer) {
        maxCountBuffer.subData({
          data: maxCountBufferData
        });
      } else {
        maxCountBuffer = new _luma.Buffer(this.gl, {
          data: maxCountBufferData
        });
      }

      return {
        countsBuffer: countsBuffer,
        maxCountBuffer: maxCountBuffer,
        // Return total aggregaton values to avoid UBO setup for WebGL1 cases
        totalCount: totalCount,
        totalWeight: totalWeight,
        maxWeight: maxWeight
      };
    }
    /* eslint-enable max-statements */

  }, {
    key: "_runAggregationOnGPU",
    value: function _runAggregationOnGPU(opts) {
      this._updateModels(opts);

      this._renderAggregateData(opts);

      return this._getAggregateData(opts);
    } // Update priveate state

  }, {
    key: "_setState",
    value: function _setState(updateObject) {
      Object.assign(this.state, updateObject);
    }
  }, {
    key: "_setupGPUResources",
    value: function _setupGPUResources() {
      var gl = this.gl;
      this.gridAggregationFramebuffer = setupFramebuffer(gl, {
        id: 'GridAggregation'
      });
      this.allAggregrationFramebuffer = setupFramebuffer(gl, {
        id: 'AllAggregation'
      });
    }
  }, {
    key: "_setupModels",
    value: function _setupModels() {
      var fp64 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

      if (this.gridAggregationModel) {
        this.gridAggregationModel.delete();
      }

      this.gridAggregationModel = this._getAggregationModel(fp64);

      if (this.allAggregationModel) {
        this.allAggregationModel.delete();
      }

      this.allAggregationModel = this._getAllAggregationModel(fp64);
    }
    /* eslint-disable max-statements */

  }, {
    key: "_updateModels",
    value: function _updateModels(opts) {
      var gl = this.gl;
      var positions = opts.positions,
          positions64xyLow = opts.positions64xyLow,
          weights = opts.weights,
          changeFlags = opts.changeFlags;
      var _this$state3 = this.state,
          numCol = _this$state3.numCol,
          numRow = _this$state3.numRow;
      var _this$state4 = this.state,
          positionsBuffer = _this$state4.positionsBuffer,
          positions64xyLowBuffer = _this$state4.positions64xyLowBuffer,
          weightsBuffer = _this$state4.weightsBuffer;
      var aggregationModelAttributes = {};
      var createPos64xyLow = false;

      if (opts.fp64 !== this.state.fp64) {
        this._setupModels(opts.fp64);

        this._setState({
          fp64: opts.fp64
        });

        if (opts.fp64) {
          createPos64xyLow = true;
        }
      }

      if (changeFlags.dataChanged || !positionsBuffer) {
        if (positionsBuffer) {
          positionsBuffer.delete();
        }

        if (weightsBuffer) {
          weightsBuffer.delete();
        }

        positionsBuffer = new _luma.Buffer(gl, {
          size: 2,
          data: new Float32Array(positions)
        });
        weightsBuffer = new _luma.Buffer(gl, {
          size: 1,
          data: new Float32Array(weights)
        });
        createPos64xyLow = opts.fp64;
        Object.assign(aggregationModelAttributes, {
          positions: positionsBuffer,
          weights: weightsBuffer
        });
        this.gridAggregationModel.setVertexCount(positions.length / 2);

        this._setState({
          positionsBuffer: positionsBuffer,
          weightsBuffer: weightsBuffer
        });
      }

      if (createPos64xyLow) {
        (0, _assert.default)(positions64xyLow);

        if (positions64xyLowBuffer) {
          positions64xyLowBuffer.delete();
        }

        positions64xyLowBuffer = new _luma.Buffer(gl, {
          size: 2,
          data: new Float32Array(positions64xyLow)
        });
        Object.assign(aggregationModelAttributes, {
          positions64xyLow: positions64xyLowBuffer
        });

        this._setState({
          positions64xyLowBuffer: positions64xyLowBuffer
        });
      }

      this.gridAggregationModel.setAttributes(aggregationModelAttributes);

      if (changeFlags.cellSizeChanged || changeFlags.viewportChanged) {
        this.allAggregationModel.setInstanceCount(numCol * numRow);
        var framebufferSize = {
          width: numCol,
          height: numRow
        };
        this.gridAggregationFramebuffer.resize(framebufferSize);
        this.allAggregrationFramebuffer.resize(framebufferSize);
      }
    }
    /* eslint-enable max-statements */

  }, {
    key: "_updateGridSize",
    value: function _updateGridSize(opts) {
      var viewport = opts.viewport,
          cellSize = opts.cellSize;
      var width = opts.width || viewport.width;
      var height = opts.height || viewport.height;
      var numCol = Math.ceil(width / cellSize[0]);
      var numRow = Math.ceil(height / cellSize[1]);

      this._setState({
        numCol: numCol,
        numRow: numRow,
        windowSize: [width, height]
      });
    }
  }]);

  return GPUGridAggregator;
}(); // Helper methods.


exports.default = GPUGridAggregator;

function setupFramebuffer(gl, opts) {
  var _parameters;

  var id = opts.id;
  var texture = new _luma.Texture2D(gl, {
    data: null,
    format: _constants.default.RGBA32F,
    type: _constants.default.FLOAT,
    border: 0,
    mipmaps: false,
    parameters: (_parameters = {}, _defineProperty(_parameters, _constants.default.TEXTURE_MAG_FILTER, _constants.default.NEAREST), _defineProperty(_parameters, _constants.default.TEXTURE_MIN_FILTER, _constants.default.NEAREST), _parameters),
    dataFormat: _constants.default.RGBA
  });
  var fb = new _luma.Framebuffer(gl, {
    id: id,
    attachments: _defineProperty({}, _constants.default.COLOR_ATTACHMENT0, texture)
  });
  return fb;
}
//# sourceMappingURL=gpu-grid-aggregator.js.map