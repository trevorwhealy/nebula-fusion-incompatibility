function _instanceof(left, right) { if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) { return right[Symbol.hasInstance](left); } else { return left instanceof right; } }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!_instanceof(instance, Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.
import { Layer } from '@deck.gl/core';
import GL from 'luma.gl/constants';
import { Model, Geometry, hasFeature, FEATURES } from 'luma.gl'; // Polygon geometry generation is managed by the polygon tesselator

import { PolygonTesselator } from './polygon-tesselator';
import vs from './solid-polygon-layer-vertex.glsl';
import fs from './solid-polygon-layer-fragment.glsl';
var defaultLineColor = [0, 0, 0, 255];
var defaultFillColor = [0, 0, 0, 255];
var defaultProps = {
  filled: true,
  // Whether to extrude
  extruded: false,
  // Whether to draw a GL.LINES wireframe of the polygon
  wireframe: false,
  fp64: false,
  // elevation multiplier
  elevationScale: 1,
  // Accessor for polygon geometry
  getPolygon: function getPolygon(f) {
    return f.polygon;
  },
  // Accessor for extrusion height
  getElevation: 1000,
  // Accessor for colors
  getFillColor: defaultFillColor,
  getLineColor: defaultLineColor,
  // Optional settings for 'lighting' shader module
  lightSettings: {}
}; // Side model attributes

var SIDE_FILL_POSITIONS = new Float32Array([// top left corner
0, 1, // bottom left corner
0, 0, // top right corner
1, 1, // bottom right corner
1, 0]);
var SIDE_WIRE_POSITIONS = new Float32Array([// top right corner
1, 1, // top left corner
0, 1, // bottom left corner
0, 0, // bottom right corner
1, 0]); // Model types

var ATTRIBUTE_OVERRIDES = {
  TOP: null,
  SIDE: {
    instanced: 1
  },
  WIRE: {
    instanced: 1
  }
};
var ATTRIBUTE_MAPS = {
  TOP: {
    indices: 'indices',
    positions: 'positions',
    positions64xyLow: 'positions64xyLow',
    elevations: 'elevations',
    colors: 'fillColors',
    pickingColors: 'pickingColors'
  },
  SIDE: {
    positions: 'positions',
    positions64xyLow: 'positions64xyLow',
    nextPositions: 'nextPositions',
    nextPositions64xyLow: 'nextPositions64xyLow',
    elevations: 'elevations',
    colors: 'fillColors',
    pickingColors: 'pickingColors'
  },
  WIRE: {
    positions: 'positions',
    positions64xyLow: 'positions64xyLow',
    nextPositions: 'nextPositions',
    nextPositions64xyLow: 'nextPositions64xyLow',
    elevations: 'elevations',
    colors: 'lineColors',
    pickingColors: 'pickingColors'
  }
};
var ATTRIBUTE_TRANSITION = {
  enter: function enter(value, chunk) {
    return chunk.length ? chunk.subarray(chunk.length - value.length) : value;
  }
};

var SolidPolygonLayer =
/*#__PURE__*/
function (_Layer) {
  _inherits(SolidPolygonLayer, _Layer);

  function SolidPolygonLayer() {
    _classCallCheck(this, SolidPolygonLayer);

    return _possibleConstructorReturn(this, (SolidPolygonLayer.__proto__ || Object.getPrototypeOf(SolidPolygonLayer)).apply(this, arguments));
  }

  _createClass(SolidPolygonLayer, [{
    key: "getShaders",
    value: function getShaders() {
      var projectModule = this.use64bitProjection() ? 'project64' : 'project32';
      return {
        vs: vs,
        fs: fs,
        modules: [projectModule, 'lighting', 'picking']
      };
    }
  }, {
    key: "initializeState",
    value: function initializeState() {
      var gl = this.context.gl;
      this.setState({
        numInstances: 0,
        IndexType: hasFeature(gl, FEATURES.ELEMENT_INDEX_UINT32) ? Uint32Array : Uint16Array
      });
      var attributeManager = this.getAttributeManager();
      var noAlloc = true;
      /* eslint-disable max-len */

      attributeManager.add({
        indices: {
          size: 1,
          isIndexed: true,
          update: this.calculateIndices,
          noAlloc: noAlloc
        },
        positions: {
          size: 3,
          transition: ATTRIBUTE_TRANSITION,
          accessor: 'getPolygon',
          update: this.calculatePositions,
          noAlloc: noAlloc
        },
        positions64xyLow: {
          size: 2,
          update: this.calculatePositionsLow
        },
        nextPositions: {
          size: 3,
          transition: ATTRIBUTE_TRANSITION,
          accessor: 'getPolygon',
          update: this.calculateNextPositions,
          noAlloc: noAlloc
        },
        nextPositions64xyLow: {
          size: 2,
          update: this.calculateNextPositionsLow
        },
        elevations: {
          size: 1,
          transition: ATTRIBUTE_TRANSITION,
          accessor: 'getElevation',
          update: this.calculateElevations,
          noAlloc: noAlloc
        },
        fillColors: {
          alias: 'colors',
          size: 4,
          type: GL.UNSIGNED_BYTE,
          transition: ATTRIBUTE_TRANSITION,
          accessor: 'getFillColor',
          update: this.calculateFillColors,
          defaultValue: defaultFillColor,
          noAlloc: noAlloc
        },
        lineColors: {
          alias: 'colors',
          size: 4,
          type: GL.UNSIGNED_BYTE,
          transition: ATTRIBUTE_TRANSITION,
          accessor: 'getLineColor',
          update: this.calculateLineColors,
          defaultValue: defaultLineColor,
          noAlloc: noAlloc
        },
        pickingColors: {
          size: 3,
          type: GL.UNSIGNED_BYTE,
          update: this.calculatePickingColors,
          noAlloc: noAlloc
        }
      });
      /* eslint-enable max-len */
    }
  }, {
    key: "draw",
    value: function draw(_ref) {
      var uniforms = _ref.uniforms;
      var _this$props = this.props,
          extruded = _this$props.extruded,
          elevationScale = _this$props.elevationScale;
      var renderUniforms = Object.assign({}, uniforms, {
        extruded: extruded ? 1.0 : 0.0,
        elevationScale: elevationScale
      });
      this.state.models.forEach(function (model) {
        model.render(renderUniforms);
      });
    }
  }, {
    key: "updateState",
    value: function updateState(updateParams) {
      _get(SolidPolygonLayer.prototype.__proto__ || Object.getPrototypeOf(SolidPolygonLayer.prototype), "updateState", this).call(this, updateParams);

      this.updateGeometry(updateParams);
      var props = updateParams.props,
          oldProps = updateParams.oldProps;
      var attributeManager = this.getAttributeManager();
      var regenerateModels = props.fp64 !== oldProps.fp64 || props.filled !== oldProps.filled || props.extruded !== oldProps.extruded || props.wireframe !== oldProps.wireframe;

      if (regenerateModels) {
        if (this.state.models) {
          this.state.models.forEach(function (model) {
            return model.delete();
          });
        }

        this.setState(this._getModels(this.context.gl));
        attributeManager.invalidateAll();
      }
    }
  }, {
    key: "updateGeometry",
    value: function updateGeometry(_ref2) {
      var props = _ref2.props,
          oldProps = _ref2.oldProps,
          changeFlags = _ref2.changeFlags;
      var geometryConfigChanged = changeFlags.dataChanged || changeFlags.updateTriggersChanged && (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getPolygon); // When the geometry config  or the data is changed,
      // tessellator needs to be invoked

      if (geometryConfigChanged) {
        // TODO - avoid creating a temporary array here: let the tesselator iterate
        var polygons = props.data.map(props.getPolygon);

        var polygonTesselator = this._getPolygonTesselator(polygons, this.state.IndexType);

        this.setState({
          polygonTesselator: polygonTesselator,
          numInstances: polygonTesselator.pointCount
        });
        this.getAttributeManager().invalidateAll();
      }

      if (geometryConfigChanged || props.extruded !== oldProps.extruded || props.fp64 !== oldProps.fp64) {
        this.state.polygonTesselator.updatePositions({
          fp64: this.use64bitPositions(),
          extruded: props.extruded
        });
      }
    } // "Experimental" method indended to make it easier to support non-nested arrays in subclasses

  }, {
    key: "_getPolygonTesselator",
    value: function _getPolygonTesselator(polygons, IndexType) {
      return new PolygonTesselator({
        polygons: polygons,
        IndexType: this.state.IndexType
      });
    }
  }, {
    key: "updateAttributes",
    value: function updateAttributes(props) {
      _get(SolidPolygonLayer.prototype.__proto__ || Object.getPrototypeOf(SolidPolygonLayer.prototype), "updateAttributes", this).call(this, props);

      var attributes = this.getAttributeManager().getChangedAttributes({
        clearChangedFlags: true
      });
      var modelsByName = this.state.modelsByName;

      for (var modelName in modelsByName) {
        var model = modelsByName[modelName];

        if (modelName === 'TOP') {
          model.setVertexCount(this.state.numVertex);
        } else {
          model.setInstanceCount(this.state.numInstances);
        }

        var attributeMap = ATTRIBUTE_MAPS[modelName];
        var attributeOverride = ATTRIBUTE_OVERRIDES[modelName];
        var newAttributes = {};

        for (var attributeName in attributeMap) {
          var attribute = attributes[attributeMap[attributeName]];

          if (attribute) {
            // Apply layout override to the attribute.
            newAttributes[attributeName] = attributeOverride ? Object.assign({}, attribute, attributeOverride, {
              buffer: attribute.getBuffer()
            }) : attribute;
          }
        }

        model.setAttributes(newAttributes);
      }
    }
  }, {
    key: "_getModels",
    value: function _getModels(gl) {
      var _this$props2 = this.props,
          id = _this$props2.id,
          filled = _this$props2.filled,
          extruded = _this$props2.extruded,
          wireframe = _this$props2.wireframe;
      var models = {};

      if (filled) {
        models.TOP = new Model(gl, Object.assign({}, this.getShaders(), {
          id: "".concat(id, "-top"),
          geometry: new Geometry({
            drawMode: GL.TRIANGLES,
            attributes: {
              vertexPositions: {
                size: 2,
                isInstanced: true,
                value: new Float32Array([0, 1])
              },
              nextPositions: {
                size: 3,
                isInstanced: true,
                value: new Float32Array(3)
              },
              nextPositions64xyLow: {
                size: 2,
                isInstanced: true,
                value: new Float32Array(2)
              }
            }
          }),
          uniforms: {
            isSideVertex: 0
          },
          vertexCount: 0,
          isIndexed: true,
          shaderCache: this.context.shaderCache
        }));
      }

      if (filled && extruded) {
        models.SIDE = new Model(gl, Object.assign({}, this.getShaders(), {
          id: "".concat(id, "-side"),
          geometry: new Geometry({
            drawMode: GL.TRIANGLE_STRIP,
            vertexCount: 4,
            attributes: {
              vertexPositions: {
                size: 2,
                value: SIDE_FILL_POSITIONS
              }
            }
          }),
          uniforms: {
            isSideVertex: 1
          },
          isInstanced: 1,
          shaderCache: this.context.shaderCache
        }));
      }

      if (extruded && wireframe) {
        models.WIRE = new Model(gl, Object.assign({}, this.getShaders(), {
          id: "".concat(id, "-wire"),
          geometry: new Geometry({
            drawMode: GL.LINE_STRIP,
            vertexCount: 4,
            attributes: {
              vertexPositions: {
                size: 2,
                value: SIDE_WIRE_POSITIONS
              }
            }
          }),
          uniforms: {
            isSideVertex: 1
          },
          isInstanced: 1,
          shaderCache: this.context.shaderCache
        }));
      }

      return {
        models: [models.WIRE, models.SIDE, models.TOP].filter(Boolean),
        modelsByName: models
      };
    }
  }, {
    key: "calculateIndices",
    value: function calculateIndices(attribute) {
      attribute.value = this.state.polygonTesselator.indices();
      var numVertex = attribute.value.length / attribute.size;
      this.setState({
        numVertex: numVertex
      });
    }
  }, {
    key: "calculatePositions",
    value: function calculatePositions(attribute) {
      var polygonTesselator = this.state.polygonTesselator;
      attribute.bufferLayout = polygonTesselator.bufferLayout;
      attribute.value = polygonTesselator.positions();
    }
  }, {
    key: "calculatePositionsLow",
    value: function calculatePositionsLow(attribute) {
      var isFP64 = this.use64bitPositions();
      attribute.constant = !isFP64;

      if (!isFP64) {
        attribute.value = new Float32Array(2);
        return;
      }

      attribute.value = this.state.polygonTesselator.positions64xyLow();
    }
  }, {
    key: "calculateNextPositions",
    value: function calculateNextPositions(attribute) {
      var polygonTesselator = this.state.polygonTesselator;
      attribute.bufferLayout = polygonTesselator.bufferLayout;
      attribute.value = polygonTesselator.nextPositions();
    }
  }, {
    key: "calculateNextPositionsLow",
    value: function calculateNextPositionsLow(attribute) {
      var isFP64 = this.use64bitPositions();
      attribute.constant = !isFP64;

      if (!isFP64) {
        attribute.value = new Float32Array(2);
        return;
      }

      attribute.value = this.state.polygonTesselator.nextPositions64xyLow();
    }
  }, {
    key: "calculateElevations",
    value: function calculateElevations(attribute) {
      var _this = this;

      var polygonTesselator = this.state.polygonTesselator;
      attribute.bufferLayout = polygonTesselator.bufferLayout;
      var _this$props3 = this.props,
          extruded = _this$props3.extruded,
          _getElevation = _this$props3.getElevation;

      if (extruded && typeof _getElevation === 'function') {
        attribute.constant = false;
        attribute.value = polygonTesselator.elevations({
          getElevation: function getElevation(polygonIndex) {
            return _getElevation(_this.props.data[polygonIndex]);
          }
        });
      } else {
        var elevation = extruded ? _getElevation : 0;
        attribute.constant = true;
        attribute.value = new Float32Array([elevation]);
      }
    }
  }, {
    key: "calculateFillColors",
    value: function calculateFillColors(attribute) {
      var _this2 = this;

      var polygonTesselator = this.state.polygonTesselator;
      attribute.bufferLayout = polygonTesselator.bufferLayout;
      attribute.value = polygonTesselator.colors({
        key: 'fillColors',
        getColor: function getColor(polygonIndex) {
          return _this2.props.getFillColor(_this2.props.data[polygonIndex]);
        }
      });
    }
  }, {
    key: "calculateLineColors",
    value: function calculateLineColors(attribute) {
      var _this3 = this;

      var polygonTesselator = this.state.polygonTesselator;
      attribute.bufferLayout = polygonTesselator.bufferLayout;
      attribute.value = polygonTesselator.colors({
        key: 'lineColors',
        getColor: function getColor(polygonIndex) {
          return _this3.props.getLineColor(_this3.props.data[polygonIndex]);
        }
      });
    } // Override the default picking colors calculation

  }, {
    key: "calculatePickingColors",
    value: function calculatePickingColors(attribute) {
      attribute.value = this.state.polygonTesselator.pickingColors();
    }
  }]);

  return SolidPolygonLayer;
}(Layer);

export { SolidPolygonLayer as default };
SolidPolygonLayer.layerName = 'SolidPolygonLayer';
SolidPolygonLayer.defaultProps = defaultProps;
//# sourceMappingURL=solid-polygon-layer.js.map