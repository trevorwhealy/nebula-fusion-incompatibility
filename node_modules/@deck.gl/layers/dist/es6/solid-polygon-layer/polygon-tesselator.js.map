{"version":3,"sources":["../../../src/solid-polygon-layer/polygon-tesselator.js"],"names":["Polygon","experimental","fillArray","fp64","fp64Module","fp64LowPart","getPickingColor","index","DEFAULT_COLOR","PolygonTesselator","constructor","polygons","IndexType","map","polygon","normalize","pointCount","getPointCount","bufferLayout","getVertexCount","Uint16Array","Error","attributes","pickingColors","calculatePickingColors","updatePositions","extruded","positions","Float32Array","nextPositions","positions64xyLow","nextPositions64xyLow","cache","indices","calculateIndices","elevations","key","getElevation","x","values","updateElevations","colors","getColor","updateColors","reduce","points","getTriangleCount","triangles","getPolygonOffsets","offsets","Array","length","offset","forEach","i","Uint32Array","indexCount","attribute","polygonIndex","getSurfaceIndices","nextI","startVertex","pushStartVertex","y","z","xLow","yLow","popStartVertex","forEachVertex","vertex","vertexIndex","complexPolygon","height","vertexCount","target","source","start","count","Uint8ClampedArray","color","isNaN"],"mappings":"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","sourcesContent":["// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n// Handles tesselation of polygons with holes\n// - 2D surfaces\n// - 2D outlines\n// - 3D surfaces (top and sides only)\n// - 3D wireframes (not yet)\nimport * as Polygon from './polygon';\nimport {experimental} from '@deck.gl/core';\nconst {fillArray} = experimental;\nimport {fp64 as fp64Module} from 'luma.gl';\nconst {fp64LowPart} = fp64Module;\n\n// Maybe deck.gl or luma.gl needs to export this\nfunction getPickingColor(index) {\n  index++;\n  return [index & 255, (index >> 8) & 255, (index >> 16) & 255];\n}\n\nconst DEFAULT_COLOR = [0, 0, 0, 255]; // Black\n\n// This class is set up to allow querying one attribute at a time\n// the way the AttributeManager expects it\nexport class PolygonTesselator {\n  constructor({polygons, IndexType}) {\n    // Normalize all polygons\n    polygons = polygons.map(polygon => Polygon.normalize(polygon));\n\n    // Count all polygon vertices\n    const pointCount = getPointCount(polygons);\n\n    this.polygons = polygons;\n    this.pointCount = pointCount;\n    this.bufferLayout = polygons.map(polygon => Polygon.getVertexCount(polygon));\n    this.IndexType = IndexType;\n\n    // TODO: dynamically decide IndexType in tesselator?\n    // Check if the vertex count excedes index type limit\n    if (IndexType === Uint16Array && pointCount > 65535) {\n      throw new Error(\"Vertex count exceeds browser's limit\");\n    }\n\n    this.attributes = {\n      pickingColors: calculatePickingColors({polygons, pointCount})\n    };\n  }\n\n  updatePositions({fp64, extruded}) {\n    const {attributes, polygons, pointCount} = this;\n\n    attributes.positions = attributes.positions || new Float32Array(pointCount * 3);\n    attributes.nextPositions = attributes.nextPositions || new Float32Array(pointCount * 3);\n\n    if (fp64) {\n      // We only need x, y component\n      attributes.positions64xyLow = attributes.positions64xyLow || new Float32Array(pointCount * 2);\n      attributes.nextPositions64xyLow =\n        attributes.nextPositions64xyLow || new Float32Array(pointCount * 2);\n    }\n\n    updatePositions({cache: attributes, polygons, extruded, fp64});\n  }\n\n  indices() {\n    const {polygons, IndexType} = this;\n    return calculateIndices({polygons, IndexType});\n  }\n\n  positions() {\n    return this.attributes.positions;\n  }\n  positions64xyLow() {\n    return this.attributes.positions64xyLow;\n  }\n\n  nextPositions() {\n    return this.attributes.nextPositions;\n  }\n  nextPositions64xyLow() {\n    return this.attributes.nextPositions64xyLow;\n  }\n\n  elevations({key = 'elevations', getElevation = x => 100} = {}) {\n    const {attributes, polygons, pointCount} = this;\n    const values = updateElevations({cache: attributes[key], polygons, pointCount, getElevation});\n    attributes[key] = values;\n    return values;\n  }\n\n  colors({key = 'colors', getColor = x => DEFAULT_COLOR} = {}) {\n    const {attributes, polygons, pointCount} = this;\n    const values = updateColors({cache: attributes[key], polygons, pointCount, getColor});\n    attributes[key] = values;\n    return values;\n  }\n\n  pickingColors() {\n    return this.attributes.pickingColors;\n  }\n}\n\n// Count number of points in a list of complex polygons\nfunction getPointCount(polygons) {\n  return polygons.reduce((points, polygon) => points + Polygon.getVertexCount(polygon), 0);\n}\n\n// COunt number of triangles in a list of complex polygons\nfunction getTriangleCount(polygons) {\n  return polygons.reduce((triangles, polygon) => triangles + Polygon.getTriangleCount(polygon), 0);\n}\n\n// Returns the offsets of each complex polygon in the combined array of all polygons\nfunction getPolygonOffsets(polygons) {\n  const offsets = new Array(polygons.length + 1);\n  offsets[0] = 0;\n  let offset = 0;\n  polygons.forEach((polygon, i) => {\n    offset += Polygon.getVertexCount(polygon);\n    offsets[i + 1] = offset;\n  });\n  return offsets;\n}\n\nfunction calculateIndices({polygons, IndexType = Uint32Array}) {\n  // Calculate length of index array (3 * number of triangles)\n  const indexCount = 3 * getTriangleCount(polygons);\n  const offsets = getPolygonOffsets(polygons);\n\n  // Allocate the attribute\n  const attribute = new IndexType(indexCount);\n\n  // 1. get triangulated indices for the internal areas\n  // 2. offset them by the number of indices in previous polygons\n  let i = 0;\n  polygons.forEach((polygon, polygonIndex) => {\n    for (const index of Polygon.getSurfaceIndices(polygon)) {\n      attribute[i++] = index + offsets[polygonIndex];\n    }\n  });\n\n  return attribute;\n}\n\nfunction updatePositions({\n  cache: {positions, positions64xyLow, nextPositions, nextPositions64xyLow},\n  polygons,\n  extruded,\n  fp64\n}) {\n  // Flatten out all the vertices of all the sub subPolygons\n  let i = 0;\n  let nextI = 0;\n  let startVertex = null;\n\n  const pushStartVertex = (x, y, z, xLow, yLow) => {\n    if (extruded) {\n      // Save first vertex for setting nextPositions at the end of the loop\n      startVertex = {x, y, z, xLow, yLow};\n    }\n  };\n\n  const popStartVertex = () => {\n    if (startVertex) {\n      nextPositions[nextI * 3] = startVertex.x;\n      nextPositions[nextI * 3 + 1] = startVertex.y;\n      nextPositions[nextI * 3 + 2] = startVertex.z;\n      if (fp64) {\n        nextPositions64xyLow[nextI * 2] = startVertex.xLow;\n        nextPositions64xyLow[nextI * 2 + 1] = startVertex.yLow;\n      }\n      nextI++;\n    }\n    startVertex = null;\n  };\n\n  polygons.forEach((polygon, polygonIndex) => {\n    Polygon.forEachVertex(polygon, (vertex, vertexIndex) => {\n      // eslint-disable-line\n      const x = vertex[0];\n      const y = vertex[1];\n      const z = vertex[2] || 0;\n      let xLow;\n      let yLow;\n\n      positions[i * 3] = x;\n      positions[i * 3 + 1] = y;\n      positions[i * 3 + 2] = z;\n      if (fp64) {\n        xLow = fp64LowPart(x);\n        yLow = fp64LowPart(y);\n        positions64xyLow[i * 2] = xLow;\n        positions64xyLow[i * 2 + 1] = yLow;\n      }\n      i++;\n\n      if (extruded && vertexIndex > 0) {\n        nextPositions[nextI * 3] = x;\n        nextPositions[nextI * 3 + 1] = y;\n        nextPositions[nextI * 3 + 2] = z;\n        if (fp64) {\n          nextPositions64xyLow[nextI * 2] = xLow;\n          nextPositions64xyLow[nextI * 2 + 1] = yLow;\n        }\n        nextI++;\n      }\n      if (vertexIndex === 0) {\n        popStartVertex();\n        pushStartVertex(x, y, z, xLow, yLow);\n      }\n    });\n  });\n  popStartVertex();\n}\n\nfunction updateElevations({cache, polygons, pointCount, getElevation}) {\n  const elevations = cache || new Float32Array(pointCount);\n  let i = 0;\n  polygons.forEach((complexPolygon, polygonIndex) => {\n    // Calculate polygon color\n    const height = getElevation(polygonIndex);\n\n    const vertexCount = Polygon.getVertexCount(complexPolygon);\n    fillArray({target: elevations, source: [height], start: i, count: vertexCount});\n    i += vertexCount;\n  });\n  return elevations;\n}\n\nfunction updateColors({cache, polygons, pointCount, getColor}) {\n  const colors = cache || new Uint8ClampedArray(pointCount * 4);\n  let i = 0;\n  polygons.forEach((complexPolygon, polygonIndex) => {\n    // Calculate polygon color\n    const color = getColor(polygonIndex);\n    if (isNaN(color[3])) {\n      color[3] = 255;\n    }\n\n    const vertexCount = Polygon.getVertexCount(complexPolygon);\n    fillArray({target: colors, source: color, start: i, count: vertexCount});\n    i += color.length * vertexCount;\n  });\n  return colors;\n}\n\nfunction calculatePickingColors({polygons, pointCount}) {\n  const attribute = new Uint8ClampedArray(pointCount * 3);\n  let i = 0;\n  polygons.forEach((complexPolygon, polygonIndex) => {\n    const color = getPickingColor(polygonIndex);\n    const vertexCount = Polygon.getVertexCount(complexPolygon);\n    fillArray({target: attribute, source: color, start: i, count: vertexCount});\n    i += color.length * vertexCount;\n  });\n  return attribute;\n}\n"],"file":"polygon-tesselator.js"}