{"version":3,"sources":["../../../src/geojson-layer/geojson.js"],"names":["assert","condition","message","Error","getGeojsonFeatures","geojson","Array","isArray","type","geometries","map","geometry","features","separateGeojsonFeatures","pointFeatures","lineFeatures","polygonFeatures","polygonOutlineFeatures","featureIndex","feature","coordinates","checkCoordinates","sourceFeature","index","push","forEach","point","path","polygon","length","unwrapSourceFeature","wrappedFeature","unwrapSourceFeatureIndex","COORDINATE_NEST_LEVEL","Point","MultiPoint","LineString","MultiLineString","Polygon","MultiPolygon","nestLevel","Number","isFinite"],"mappings":";;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACe,SAASA,MAAT,CAAgBC,SAAhB,EAA2BC,OAA3B,EAAoC;AACjD,MAAI,CAACD,SAAL,EAAgB;AACd,UAAM,IAAIE,KAAJ,oBAAsBD,OAAtB,EAAN;AACD;AACF;AAED;;;;;;;;;;;;;;AAYO,SAASE,kBAAT,CAA4BC,OAA5B,EAAqC;AAC1C;AACA,MAAIC,MAAMC,OAAN,CAAcF,OAAd,CAAJ,EAA4B;AAC1B,WAAOA,OAAP;AACD;;AAEDL,SAAOK,QAAQG,IAAf,EAAqB,4BAArB;;AAEA,UAAQH,QAAQG,IAAhB;AACE,SAAK,oBAAL;AACER,aAAOM,MAAMC,OAAN,CAAcF,QAAQI,UAAtB,CAAP,EAA0C,wCAA1C;AACA,aAAOJ,QAAQI,UAAR,CAAmBC,GAAnB,CAAuB;AAAA,eAAa;AAACC;AAAD,SAAb;AAAA,OAAvB,CAAP;;AACF,SAAK,SAAL;AACE;AACA,aAAO,CAACN,OAAD,CAAP;;AACF,SAAK,mBAAL;AACE;AACAL,aAAOM,MAAMC,OAAN,CAAcF,QAAQO,QAAtB,CAAP,EAAwC,sCAAxC;AACA,aAAOP,QAAQO,QAAf;;AACF;AACE;AACA;AACA,aAAO,CAAC;AAACD,kBAAUN;AAAX,OAAD,CAAP;AAdJ;AAgBD,C,CAED;;;AACO,SAASQ,uBAAT,CAAiCD,QAAjC,EAA2C;AAChD,MAAME,gBAAgB,EAAtB;AACA,MAAMC,eAAe,EAArB;AACA,MAAMC,kBAAkB,EAAxB;AACA,MAAMC,yBAAyB,EAA/B;;AAJgD,6BAMvCC,YANuC;AAO9C,QAAMC,UAAUP,SAASM,YAAT,CAAhB;AAEAlB,WAAOmB,WAAWA,QAAQR,QAA1B,EAAoC,gCAApC;AAT8C,4BAWlBQ,QAAQR,QAXU;AAAA,QAWvCH,IAXuC,qBAWvCA,IAXuC;AAAA,QAWjCY,WAXiC,qBAWjCA,WAXiC;AAY9CC,qBAAiBb,IAAjB,EAAuBY,WAAvB;AAEA,QAAME,gBAAgB;AACpBH,sBADoB;AAEpBI,aAAOL;AAFa,KAAtB,CAd8C,CAkB9C;;AACA,YAAQV,IAAR;AACE,WAAK,OAAL;AACEM,sBAAcU,IAAd,CAAmB;AACjBb,oBAAUQ,QAAQR,QADD;AAEjBW;AAFiB,SAAnB;AAIA;;AACF,WAAK,YAAL;AACEF,oBAAYK,OAAZ,CAAoB,iBAAS;AAC3BX,wBAAcU,IAAd,CAAmB;AACjBb,sBAAU;AAACH,oBAAM,OAAP;AAAgBY,2BAAaM;AAA7B,aADO;AAEjBJ;AAFiB,WAAnB;AAID,SALD;AAMA;;AACF,WAAK,YAAL;AACEP,qBAAaS,IAAb,CAAkB;AAChBb,oBAAUQ,QAAQR,QADF;AAEhBW;AAFgB,SAAlB;AAIA;;AACF,WAAK,iBAAL;AACE;AACAF,oBAAYK,OAAZ,CAAoB,gBAAQ;AAC1BV,uBAAaS,IAAb,CAAkB;AAChBb,sBAAU;AAACH,oBAAM,YAAP;AAAqBY,2BAAaO;AAAlC,aADM;AAEhBL;AAFgB,WAAlB;AAID,SALD;AAMA;;AACF,WAAK,SAAL;AACEN,wBAAgBQ,IAAhB,CAAqB;AACnBb,oBAAUQ,QAAQR,QADC;AAEnBW;AAFmB,SAArB,EADF,CAKE;;AACAF,oBAAYK,OAAZ,CAAoB,gBAAQ;AAC1BR,iCAAuBO,IAAvB,CAA4B;AAC1Bb,sBAAU;AAACH,oBAAM,YAAP;AAAqBY,2BAAaO;AAAlC,aADgB;AAE1BL;AAF0B,WAA5B;AAID,SALD;AAMA;;AACF,WAAK,cAAL;AACE;AACAF,oBAAYK,OAAZ,CAAoB,mBAAW;AAC7BT,0BAAgBQ,IAAhB,CAAqB;AACnBb,sBAAU;AAACH,oBAAM,SAAP;AAAkBY,2BAAaQ;AAA/B,aADS;AAEnBN;AAFmB,WAArB,EAD6B,CAK7B;;AACAM,kBAAQH,OAAR,CAAgB,gBAAQ;AACtBR,mCAAuBO,IAAvB,CAA4B;AAC1Bb,wBAAU;AAACH,sBAAM,YAAP;AAAqBY,6BAAaO;AAAlC,eADgB;AAE1BL;AAF0B,aAA5B;AAID,WALD;AAMD,SAZD;AAaA;;AACF;AA3DF;AAnB8C;;AAMhD,OAAK,IAAIJ,eAAe,CAAxB,EAA2BA,eAAeN,SAASiB,MAAnD,EAA2DX,cAA3D,EAA2E;AAAA,UAAlEA,YAAkE;AA0E1E;;AAED,SAAO;AACLJ,gCADK;AAELC,8BAFK;AAGLC,oCAHK;AAILC;AAJK,GAAP;AAMD;AAED;;;;;AAGO,SAASa,mBAAT,CAA6BC,cAA7B,EAA6C;AAClD;AACA,SAAOA,eAAeT,aAAf,CAA6BH,OAApC;AACD;AAED;;;;;AAGO,SAASa,wBAAT,CAAkCD,cAAlC,EAAkD;AACvD;AACA,SAAOA,eAAeT,aAAf,CAA6BC,KAApC;AACD;AAED;;;;;;;;AAMA,IAAMU,wBAAwB;AAC5BC,SAAO,CADqB;AAE5BC,cAAY,CAFgB;AAG5BC,cAAY,CAHgB;AAI5BC,mBAAiB,CAJW;AAK5BC,WAAS,CALmB;AAM5BC,gBAAc;AANc,CAA9B;;AASA,SAASlB,gBAAT,CAA0Bb,IAA1B,EAAgCY,WAAhC,EAA6C;AAC3C,MAAIoB,YAAYP,sBAAsBzB,IAAtB,CAAhB;AAEAR,SAAOwC,SAAP,iCAA0ChC,IAA1C;;AAEA,SAAOY,eAAe,EAAEoB,SAAF,GAAc,CAApC,EAAuC;AACrCpB,kBAAcA,YAAY,CAAZ,CAAd;AACD;;AACDpB,SAAOoB,eAAeqB,OAAOC,QAAP,CAAgBtB,YAAY,CAAZ,CAAhB,CAAtB,YAA0DZ,IAA1D;AACD","sourcesContent":["// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n// Replacement for the external assert method to reduce bundle size\n// Since GeoJSON format issues are common to users we do show messages in\n// this case\nexport default function assert(condition, message) {\n  if (!condition) {\n    throw new Error(`deck.gl: ${message}`);\n  }\n}\n\n/**\n * \"Normalizes\" complete or partial GeoJSON data into iterable list of features\n * Can accept GeoJSON geometry or \"Feature\", \"FeatureCollection\" in addition\n * to plain arrays and iterables.\n * Works by extracting the feature array or wrapping single objects in an array,\n * so that subsequent code can simply iterate over features.\n *\n * @param {object} geojson - geojson data\n * @param {Object|Array} data - geojson object (FeatureCollection, Feature or\n *  Geometry) or array of features\n * @return {Array|\"iteratable\"} - iterable list of features\n */\nexport function getGeojsonFeatures(geojson) {\n  // If array, assume this is a list of features\n  if (Array.isArray(geojson)) {\n    return geojson;\n  }\n\n  assert(geojson.type, 'GeoJSON does not have type');\n\n  switch (geojson.type) {\n    case 'GeometryCollection':\n      assert(Array.isArray(geojson.geometries), 'GeoJSON does not have geometries array');\n      return geojson.geometries.map(geometry => ({geometry}));\n    case 'Feature':\n      // Wrap the feature in a 'Features' array\n      return [geojson];\n    case 'FeatureCollection':\n      // Just return the 'Features' array from the collection\n      assert(Array.isArray(geojson.features), 'GeoJSON does not have features array');\n      return geojson.features;\n    default:\n      // Assume it's a geometry, we'll check type in separateGeojsonFeatures\n      // Wrap the geometry object in a 'Feature' object and wrap in an array\n      return [{geometry: geojson}];\n  }\n}\n\n// Linearize\nexport function separateGeojsonFeatures(features) {\n  const pointFeatures = [];\n  const lineFeatures = [];\n  const polygonFeatures = [];\n  const polygonOutlineFeatures = [];\n\n  for (let featureIndex = 0; featureIndex < features.length; featureIndex++) {\n    const feature = features[featureIndex];\n\n    assert(feature && feature.geometry, 'GeoJSON does not have geometry');\n\n    const {type, coordinates} = feature.geometry;\n    checkCoordinates(type, coordinates);\n\n    const sourceFeature = {\n      feature,\n      index: featureIndex\n    };\n    // Split each feature, but keep track of the source feature and index (for Multi* geometries)\n    switch (type) {\n      case 'Point':\n        pointFeatures.push({\n          geometry: feature.geometry,\n          sourceFeature\n        });\n        break;\n      case 'MultiPoint':\n        coordinates.forEach(point => {\n          pointFeatures.push({\n            geometry: {type: 'Point', coordinates: point},\n            sourceFeature\n          });\n        });\n        break;\n      case 'LineString':\n        lineFeatures.push({\n          geometry: feature.geometry,\n          sourceFeature\n        });\n        break;\n      case 'MultiLineString':\n        // Break multilinestrings into multiple lines\n        coordinates.forEach(path => {\n          lineFeatures.push({\n            geometry: {type: 'LineString', coordinates: path},\n            sourceFeature\n          });\n        });\n        break;\n      case 'Polygon':\n        polygonFeatures.push({\n          geometry: feature.geometry,\n          sourceFeature\n        });\n        // Break polygon into multiple lines\n        coordinates.forEach(path => {\n          polygonOutlineFeatures.push({\n            geometry: {type: 'LineString', coordinates: path},\n            sourceFeature\n          });\n        });\n        break;\n      case 'MultiPolygon':\n        // Break multipolygons into multiple polygons\n        coordinates.forEach(polygon => {\n          polygonFeatures.push({\n            geometry: {type: 'Polygon', coordinates: polygon},\n            sourceFeature\n          });\n          // Break polygon into multiple lines\n          polygon.forEach(path => {\n            polygonOutlineFeatures.push({\n              geometry: {type: 'LineString', coordinates: path},\n              sourceFeature\n            });\n          });\n        });\n        break;\n      default:\n    }\n  }\n\n  return {\n    pointFeatures,\n    lineFeatures,\n    polygonFeatures,\n    polygonOutlineFeatures\n  };\n}\n\n/**\n * Returns the source feature that was passed to `separateGeojsonFeatures`\n */\nexport function unwrapSourceFeature(wrappedFeature) {\n  // The feature provided by the user is under `sourceFeature.feature`\n  return wrappedFeature.sourceFeature.feature;\n}\n\n/**\n * Returns the index of the source feature that was passed to `separateGeojsonFeatures`\n */\nexport function unwrapSourceFeatureIndex(wrappedFeature) {\n  // The index of the feature provided by the user is under `sourceFeature.index`\n  return wrappedFeature.sourceFeature.index;\n}\n\n/**\n * Simple GeoJSON validation util. For perf reasons we do not validate against the full spec,\n * only the following:\n   - geometry.type is supported\n   - geometry.coordinate has correct nesting level\n */\nconst COORDINATE_NEST_LEVEL = {\n  Point: 1,\n  MultiPoint: 2,\n  LineString: 2,\n  MultiLineString: 3,\n  Polygon: 3,\n  MultiPolygon: 4\n};\n\nfunction checkCoordinates(type, coordinates) {\n  let nestLevel = COORDINATE_NEST_LEVEL[type];\n\n  assert(nestLevel, `Unknown GeoJSON type ${type}`);\n\n  while (coordinates && --nestLevel > 0) {\n    coordinates = coordinates[0];\n  }\n  assert(coordinates && Number.isFinite(coordinates[0]), `${type} coordinates are malformed`);\n}\n"],"file":"geojson.js"}