'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var path = _interopDefault(require('path'));
var assert = _interopDefault(require('assert'));
var uuidv4 = _interopDefault(require('uuid/v4'));
var UAParser = _interopDefault(require('ua-parser-js'));

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
// eslint-disable-next-line flowtype/generic-spacing
function createPlugin(opts) {
  return Object.assign({
    __plugin__: true
  }, opts);
}

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
const TokenType = {
  Required: 0,
  Optional: 1
};

function Ref() {}

class TokenImpl {
  constructor(name, ref) {
    this.name = name;
    this.ref = ref || new Ref();
    this.type = ref ? TokenType.Optional : TokenType.Required;

    if (!ref) {
      this.optional = new TokenImpl(name, this.ref);
    }
  }

}
function createToken(name) {
  // $FlowFixMe
  return new TokenImpl(name);
}

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
const RenderToken = createToken('RenderToken');
const ElementToken = createToken('ElementToken');
const SSRDeciderToken = createToken('SSRDeciderToken');
const HttpServerToken = createToken('HttpServerToken');

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

/*
We never want developers to be able to write `ctx.template.body.push(`<div>${stuff}</div>`)`
because that allows XSS attacks by default (e.g. if stuff === '<script>alert(1)</script>')
Instead, they should use html`<div>{stuff}</div>` so interpolated data gets automatically escaped
We trust the markup outside of interpolation because it's code written by a developer with commit permissions,
which can be audited via code reviews
*/
// eslint-disable-next-line import/no-mutable-exports
let html;
let dangerouslySetHTML;
let consumeSanitizedHTML;
let escape;

{
  const forbiddenChars = {
    '<': '\\u003C',
    '>': '\\u003E',
    '"': '\\u0022',
    '/': '\\u002F',
    '\u2028': '\\u2028',
    '\u2029': '\\u2029'
  };

  const replaceForbidden = c => forbiddenChars[c];

  const key = Symbol('sanitized html');

  html = ([head, ...rest], ...values) => {
    const obj = {};
    Object.defineProperty(obj, key, {
      enumerable: false,
      configurable: false,
      value: head + values.map((s, i) => escape(s) + rest[i]).join('')
    });
    return obj;
  };

  dangerouslySetHTML = str => html([str]);

  escape = str => {
    if (str && str[key]) return consumeSanitizedHTML(str);
    return String(str).replace(/[<>"/\u2028\u2029]/g, replaceForbidden);
  };

  consumeSanitizedHTML = h => {
    if (typeof h === 'string') {
      throw new Error(`Unsanitized html. Use html\`${h}\``);
    }

    return h[key];
  };
}

const replaceEscaped = c => String.fromCodePoint(parseInt(c.slice(2), 16));

const unescape = str => {
  return str.replace(/\\u003C|\\u003E|\\u0022|\\u002F|\\u2028|\\u2029/g, replaceEscaped);
}; // These types are necessary due to not having an assignment in the __BROWSER__ environment


const flowHtml = html;
const flowDangerouslySetHTML = dangerouslySetHTML;
const flowConsumeSanitizedHTML = consumeSanitizedHTML;
const flowEscape = escape;

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
const SSRDecider = createPlugin({
  provides: () => {
    return ctx => {
      // If the request has one of these extensions, we assume it's not something that requires server-side rendering of virtual dom
      // TODO(#46): this check should probably look at the asset manifest to ensure asset 404s are handled correctly
      if (ctx.path.match(/\.(js|gif|jpg|png|pdf|json)$/)) return false; // The Accept header is a good proxy for whether SSR should happen
      // Requesting an HTML page via the browser url bar generates a request with `text/html` in its Accept headers
      // XHR/fetch requests do not have `text/html` in the Accept headers

      if (!ctx.headers.accept) return false;
      if (!ctx.headers.accept.includes('text/html')) return false;
      return true;
    };
  }
});
function createSSRPlugin({
  element,
  ssrDecider
}) {
  return async function ssrPlugin(ctx, next) {
    if (!ssrDecider(ctx)) return next();
    const template = {
      htmlAttrs: {},
      bodyAttrs: {},
      title: '',
      head: [],
      body: []
    };
    ctx.element = element;
    ctx.rendered = '';
    ctx.template = template;
    ctx.type = 'text/html';
    await next(); // Allow someone to override the ssr by setting ctx.body
    // This is especially useful for things like ctx.redirect

    if (ctx.body && ctx.respond !== false) {
      return;
    }

    const {
      htmlAttrs,
      bodyAttrs,
      title,
      head,
      body
    } = ctx.template;
    const safeAttrs = Object.keys(htmlAttrs).map(attrKey => {
      return ` ${flowEscape(attrKey)}="${flowEscape(htmlAttrs[attrKey])}"`;
    }).join('');
    const safeBodyAttrs = Object.keys(bodyAttrs).map(attrKey => {
      return ` ${flowEscape(attrKey)}="${flowEscape(bodyAttrs[attrKey])}"`;
    }).join('');
    const safeTitle = flowEscape(title); // $FlowFixMe

    const safeHead = head.map(flowConsumeSanitizedHTML).join(''); // $FlowFixMe

    const safeBody = body.map(flowConsumeSanitizedHTML).join('');
    const preloadHintLinks = getPreloadHintLinks(ctx);
    const coreGlobals = getCoreGlobals(ctx);
    const chunkScripts = getChunkScripts(ctx);
    const bundleSplittingBootstrap = [preloadHintLinks, coreGlobals, chunkScripts].join('');
    const chunkPreloaderScript = getChunkPreloaderScript(ctx);
    ctx.body = ['<!doctype html>', `<html${safeAttrs}>`, `<head>`, `<meta charset="utf-8" />`, `<title>${safeTitle}</title>`, `${bundleSplittingBootstrap}${safeHead}`, `</head>`, `<body${safeBodyAttrs}>${ctx.rendered}${safeBody}${chunkPreloaderScript}</body>`, '</html>'].join('');
  };
}

function getCoreGlobals(ctx) {
  const {
    chunkUrlMap,
    webpackPublicPath,
    nonce
  } = ctx;
  const chunkManifest = {};
  Array.from(chunkUrlMap.entries()).forEach(([id, variant]) => {
    if (variant) {
      const filepath =
      /*variant.get(ctx.esVersion) || */
      variant.get('es5');
      chunkManifest[id] = path.basename(filepath);
    }
  }, {});
  const serializedManifest = JSON.stringify(chunkManifest);
  const hasManifest = Object.keys(chunkManifest).length > 0;
  const manifest = hasManifest ? `__MANIFEST__ = ${serializedManifest};` : ''; // consumed by webpack

  return [`<script nonce="${nonce}">`, `window.performance && window.performance.mark && window.performance.mark('firstRenderStart');`, `__ROUTE_PREFIX__ = ${JSON.stringify(ctx.prefix)};`, // consumed by ./client
  `__WEBPACK_PUBLIC_PATH__ = ${JSON.stringify(webpackPublicPath)};`, // consumed by fusion-clientries/client-entry
  manifest, `</script>`].join('');
}

function getUrls({
  chunkUrlMap,
  webpackPublicPath
}, chunks) {
  return chunks.map(id => {
    let url = chunkUrlMap.get(id).get('es5');

    if (webpackPublicPath.endsWith('/')) {
      url = webpackPublicPath + url;
    } else {
      url = webpackPublicPath + '/' + url;
    }

    return {
      id,
      url
    };
  });
}

function getChunkScripts(ctx) {
  const webpackPublicPath = ctx.webpackPublicPath || ''; // cross origin is needed to get meaningful errors in window.onerror

  const crossOrigin = webpackPublicPath.startsWith('https://') ? ' crossorigin="anonymous"' : '';
  const sync = getUrls(ctx, ctx.syncChunks).map(({
    url
  }) => {
    return `<script defer${crossOrigin} src="${url}"></script>`;
  });
  const preloaded = getUrls(ctx, ctx.preloadChunks).map(({
    id,
    url
  }) => {
    return `<script defer${crossOrigin} src="${url}" data-webpack-preload="${id}"></script>`;
  });
  return [...preloaded, ...sync].join('');
}

function getPreloadHintLinks(ctx) {
  const chunks = [...ctx.preloadChunks, ...ctx.syncChunks];
  const hints = getUrls(ctx, chunks).map(({
    url
  }) => {
    return `<link rel="preload" href="${url}" as="script" />`;
  });
  return hints.join('');
}

function getChunkPreloaderScript({
  nonce = '',
  preloadChunks
}) {
  // NOTE: the event listeners below are not needed if inline onerror event handlers are allowed by CSP.
  // However, this is disallowed currently.
  return trim(`
  <script nonce="${nonce}">
  (function(){
    __PRELOADED_CHUNKS__ = ${JSON.stringify(preloadChunks)};
    function onError(e) {
      var el = e.target;
      if (el.nodeName !== "SCRIPT") return;
      var val = el.getAttribute("data-webpack-preload");
      if (val === null) return;
      var id = parseInt(val, 10);
      if (__HANDLE_ERROR) return __HANDLE_ERROR(id);
      if (!__UNHANDLED_ERRORS__) __UNHANDLED_ERRORS__ = [];
      __UNHANDLED_ERRORS__.push(id);
    }
    addEventListener("error", onError, true);
    addEventListener("load", function() {
        removeEventListener("error", onError);
    });
  })();
  </script>`);
}

function trim(str) {
  return str.replace(/^\s+/gm, '');
}

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
class FusionApp {
  constructor(el, render) {
    this.registered = new Map(); // getTokenRef(token) -> {value, aliases, enhancers}

    this.enhancerToToken = new Map(); // enhancer -> token

    this.plugins = []; // Token

    this.cleanups = [];
    el && this.register(ElementToken, el);
    render && this.register(RenderToken, render);
    this.register(SSRDeciderToken, SSRDecider);
  } // eslint-disable-next-line


  register(token, value) {
    // $FlowFixMe
    if (token && token.__plugin__) {
      value = token;
      token = createToken('UnnamedPlugin');
    }

    if (!(token instanceof TokenImpl) && value === undefined) {
      throw new Error(process.env.NODE_ENV !== "production" ? `Cannot register ${String(token)} without a token. Did you accidentally register a ${'browser'} plugin on the ${'server'}?` : 'Invalid configuration registration');
    } // the renderer is a special case, since it needs to be always run last


    if (token === RenderToken) {
      this.renderer = value;
      return {
        alias: () => {
          throw new Error('Aliasing for RenderToken not supported.');
        }
      };
    }

    return this._register(token, value);
  }

  _register(token, value) {
    this.plugins.push(token);
    const {
      aliases,
      enhancers
    } = this.registered.get(getTokenRef(token)) || {
      aliases: new Map(),
      enhancers: []
    };
    this.registered.set(getTokenRef(token), {
      value,
      aliases,
      enhancers,
      token
    });

    function alias(sourceToken, destToken) {
      if (aliases) {
        aliases.set(sourceToken, destToken);
      }

      return {
        alias
      };
    }

    return {
      alias
    };
  }

  middleware(deps, middleware) {
    if (middleware === undefined) {
      middleware = () => deps;
    }

    this.register(createPlugin({
      deps,
      middleware
    }));
  }

  enhance(token, enhancer) {
    const {
      value,
      aliases,
      enhancers
    } = this.registered.get(getTokenRef(token)) || {
      aliases: new Map(),
      enhancers: [],
      value: undefined
    };
    this.enhancerToToken.set(enhancer, token);

    if (enhancers && Array.isArray(enhancers)) {
      enhancers.push(enhancer);
    }

    this.registered.set(getTokenRef(token), {
      value,
      aliases,
      enhancers,
      token
    });
  }

  cleanup() {
    return Promise.all(this.cleanups.map(fn => fn()));
  }

  resolve() {
    if (!this.renderer) {
      throw new Error('Missing registration for RenderToken');
    }

    this._register(RenderToken, this.renderer);

    const resolved = new Map(); // Token.ref || Token => Service

    const dependedOn = new Set(); // Token.ref || Token

    const nonPluginTokens = new Set(); // Token

    const resolving = new Set(); // Token.ref || Token

    const registered = this.registered; // Token.ref || Token -> {value, aliases, enhancers}

    const resolvedPlugins = []; // Plugins

    const allAliases = new Set(); // Token.ref || Token

    const appliedEnhancers = [];

    const resolveToken = (token, tokenAliases) => {
      // Base: if we have already resolved the type, return it
      if (tokenAliases && tokenAliases.has(token)) {
        const newToken = tokenAliases.get(token);
        allAliases.add([getTokenRef(token), getTokenRef(newToken)]);

        if (newToken) {
          token = newToken;
        }
      }

      if (resolved.has(getTokenRef(token))) {
        return resolved.get(getTokenRef(token));
      } // Base: if currently resolving the same type, we have a circular dependency


      if (resolving.has(getTokenRef(token))) {
        throw new Error(`Cannot resolve circular dependency: ${token.name}`);
      } // Base: the type was never registered, throw error or provide undefined if optional


      let {
        value,
        aliases,
        enhancers
      } = registered.get(getTokenRef(token)) || {};

      if (value === undefined) {
        // Attempt to get default value, if optional
        if (token instanceof TokenImpl && token.type === TokenType.Optional) {
          this.register(token, undefined);
        } else {
          const dependents = Array.from(this.registered.entries());
          /**
           * Iterate over the entire list of dependencies and find all
           * dependencies of a given token.
           */

          const findDependentTokens = () => {
            return dependents.filter(entry => {
              if (!entry[1].value || !entry[1].value.deps) {
                return false;
              }

              return Object.values(entry[1].value.deps).includes(token);
            }).map(entry => entry[1].token.name);
          };

          const findDependentEnhancers = () => {
            return appliedEnhancers.filter(([, provides]) => {
              if (!provides || !provides.deps) {
                return false;
              }

              return Object.values(provides.deps).includes(token);
            }).map(([enhancer]) => {
              const enhancedToken = this.enhancerToToken.get(enhancer);
              return `EnhancerOf<${enhancedToken ? enhancedToken.name : '(unknown)'}>`;
            });
          };

          const dependentTokens = [...findDependentTokens(), ...findDependentEnhancers()]; // otherwise, we cannot resolve this token

          throw new Error(`Could not resolve token: "${token ? token.name : '(unknown)'}", which is required by plugins registered with tokens: ${dependentTokens.map(token => `"${token}"`).join(', ')}. Did you forget to register a value for "${token ? token.name : '(unknown)'}"?`);
        }
      } // Recursive: get the registered type and resolve it


      resolving.add(getTokenRef(token));

      function resolvePlugin(plugin) {
        const registeredDeps = plugin && plugin.deps || {};
        const resolvedDeps = {};

        for (const key in registeredDeps) {
          const registeredToken = registeredDeps[key];
          dependedOn.add(getTokenRef(registeredToken));
          resolvedDeps[key] = resolveToken(registeredToken, aliases);
        } // `provides` should be undefined if the plugin does not have a `provides` function


        let provides = plugin && plugin.provides ? plugin.provides(resolvedDeps) : undefined;

        if (plugin && plugin.middleware) {
          resolvedPlugins.push(plugin.middleware(resolvedDeps, provides));
        }

        return provides;
      }

      let provides = value;

      if (value && value.__plugin__) {
        provides = resolvePlugin(provides);

        if (value.cleanup) {
          this.cleanups.push(function () {
            return typeof value.cleanup === 'function' ? value.cleanup(provides) : Promise.resolve();
          });
        }
      } else {
        nonPluginTokens.add(token);
      }

      if (enhancers && enhancers.length) {
        enhancers.forEach(e => {
          let nextProvides = e(provides);
          appliedEnhancers.push([e, nextProvides]);

          if (nextProvides && nextProvides.__plugin__) {
            nextProvides = resolvePlugin(nextProvides);
          }

          provides = nextProvides;
        });
      }

      resolved.set(getTokenRef(token), provides);
      resolving.delete(getTokenRef(token));
      return provides;
    };

    for (let i = 0; i < this.plugins.length; i++) {
      resolveToken(this.plugins[i]);
    }

    for (const aliasPair of allAliases) {
      const [sourceTokenRef, destTokenRef] = aliasPair;

      if (dependedOn.has(sourceTokenRef)) {
        dependedOn.add(destTokenRef);
      }
    }

    for (const token of nonPluginTokens) {
      if (!dependedOn.has(getTokenRef(token))) {
        throw new Error(`Registered token without depending on it: "${token.name}"`);
      }
    }

    this.plugins = resolvedPlugins;
  }

}
/* Helper functions */


function getTokenRef(token) {
  if (token instanceof TokenImpl) {
    return token.ref;
  }

  return token;
}

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
// inline version of koa-compose to get around Rollup/CUP commonjs-related issue
function compose(middleware) {
  if (!Array.isArray(middleware)) {
    throw new TypeError('Middleware stack must be an array!');
  }

  for (const fn of middleware) {
    if (typeof fn !== 'function') {
      throw new TypeError(`Expected middleware function, received: ${typeof fn}`);
    }
  }

  return function (context, next) {
    let index = -1;
    return dispatch(0);

    function dispatch(i) {
      if (i <= index) {
        return Promise.reject(new Error('next() called multiple times'));
      }

      index = i;
      let fn = middleware[i];
      if (i === middleware.length) fn = next;
      if (!fn) return Promise.resolve();

      try {
        // $FlowFixMe
        return fn(context, function next() {
          return dispatch(i + 1);
        });
      } catch (err) {
        return Promise.reject(err);
      }
    }
  };
}

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
function memoize(fn) {
  const memoizeKey = Symbol('memoize-key');
  return function memoized(ctx) {
    if (ctx.memoized.has(memoizeKey)) {
      return ctx.memoized.get(memoizeKey);
    }

    const result = fn(ctx);
    ctx.memoized.set(memoizeKey, result);
    return result;
  };
}

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
class Timing {
  constructor() {
    this.start = now();
    this.render = deferred();
    this.end = deferred();
    this.downstream = deferred();
    this.upstream = deferred();
    this.upstreamStart = -1;
  }

}

const timing = {
  from: memoize(() => new Timing())
};
const TimingToken = createToken('TimingToken');

function middleware(ctx, next) {
  ctx.memoized = new Map();
  const {
    start,
    render,
    end,
    downstream,
    upstream
  } = timing.from(ctx);
  ctx.timing = {
    start,
    render: render.promise,
    end: end.promise,
    downstream: downstream.promise,
    upstream: upstream.promise
  };
  return next().then(() => {
    const upstreamTime = now() - timing.from(ctx).upstreamStart;
    upstream.resolve(upstreamTime);
    const endTime = now() - ctx.timing.start;
    end.resolve(endTime);
  });
}

var timing$1 = createPlugin({
  provides: () => timing,
  middleware: () => middleware
});
function now() {
  {
    const [seconds, ns] = process.hrtime();
    return Math.round(seconds * 1000 + ns / 1e6);
  }
}

function deferred() {
  let resolve = () => {};

  let reject = () => {};

  const promise = new Promise((res, rej) => {
    resolve = res;
    reject = rej;
  });
  return {
    promise,
    resolve,
    reject
  };
}

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
function getRendererPlugin({
  render,
  timing
}) {
  return async function renderer(ctx, next) {
    const timer = timing.from(ctx);
    timer.downstream.resolve(now() - timer.start);
    let renderTime = null;

    if (ctx.element && !ctx.body && ctx.respond !== false) {
      const renderStart = now();
      ctx.rendered = await render(ctx.element);
      renderTime = now() - renderStart;
    }

    timer.upstreamStart = now();
    await next();

    if (ctx.element && typeof renderTime === 'number') {
      timer.render.resolve(renderTime);
    }
  };
}

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

/* eslint-env node */
var getEnv = loadEnv();

function load(key, value) {
  return process.env[key] || value;
}

function loadEnv() {
  const rootDir = load('ROOT_DIR', '.');
  const env = load('NODE_ENV', 'development');

  if (!(env === 'development' || env === 'production' || env === 'test')) {
    throw new Error(`Invalid NODE_ENV loaded: ${env}.`);
  }

  const prefix = load('ROUTE_PREFIX', '');
  assert(!prefix.endsWith('/'), 'ROUTE_PREFIX must not end with /');
  const baseAssetPath = load('FRAMEWORK_STATIC_ASSET_PATH', `/_static`);
  assert(!baseAssetPath.endsWith('/'), 'FRAMEWORK_STATIC_ASSET_PATH must not end with /');
  const cdnUrl = load('CDN_URL', '');
  assert(!cdnUrl.endsWith('/'), 'CDN_URL must not end with /');
  const assetPath = `${prefix}${baseAssetPath}`;
  return function loadEnv() {
    return {
      rootDir,
      env,
      prefix,
      assetPath,
      baseAssetPath,
      cdnUrl,
      webpackPublicPath: cdnUrl || assetPath
    };
  };
} // Handle flow-types for export so browser export is ignored.

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
const envVars = getEnv();
function middleware$1(ctx, next) {
  // env vars
  ctx.rootDir = envVars.rootDir;
  ctx.env = envVars.env;
  ctx.prefix = envVars.prefix;
  ctx.assetPath = envVars.assetPath;
  ctx.cdnUrl = envVars.cdnUrl; // webpack-related things

  ctx.preloadChunks = [];
  ctx.webpackPublicPath = ctx.webpackPublicPath || envVars.cdnUrl || envVars.assetPath; // these are set by fusion-cli, however since fusion-cli plugins are not added when
  // running simulation tests, it is good to default them here

  ctx.syncChunks = ctx.syncChunks || [];
  ctx.chunkUrlMap = ctx.chunkUrlMap || new Map(); // fusion-specific things

  ctx.nonce = uuidv4();
  ctx.useragent = new UAParser(ctx.headers['user-agent']).getResult();
  ctx.element = null;
  ctx.rendered = null;
  return next();
}

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

/* eslint-env node */
function serverApp () {
  const Koa = require('koa');

  return class ServerApp extends FusionApp {
    constructor(el, render) {
      super(el, render);
      this._app = new Koa();
      this.middleware(middleware$1);
      this.register(TimingToken, timing$1);
      this.middleware({
        element: ElementToken,
        ssrDecider: SSRDeciderToken
      }, createSSRPlugin);
    }

    resolve() {
      this.middleware({
        timing: TimingToken,
        render: RenderToken
      }, getRendererPlugin);
      return super.resolve();
    }

    callback() {
      this.resolve();

      this._app.use(compose(this.plugins));

      return this._app.callback();
    }

  };
}

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

/* eslint-env browser */

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

/* eslint-env browser */

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
function assetUrl(url) {
  /**
   * PLEASE NOTE: a build step transforms
   * the arguments provided to this function
   */
  return url;
}
function chunkId(filename) {
  /**
   * PLEASE NOTE: a build step transforms
   * the arguments provided to this function
   */
  return filename;
}
function syncChunkIds(argument) {
  /**
   * PLEASE NOTE: a build step transforms
   * the arguments provided to this function
   */
  return argument;
}
function syncChunkPaths(argument) {
  /**
   * PLEASE NOTE: a build step transforms
   * the arguments provided to this function
   */
  return argument;
}

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
var index = serverApp();

exports.default = index;
exports.getEnv = getEnv;
exports.compose = compose;
exports.memoize = memoize;
exports.html = flowHtml;
exports.dangerouslySetHTML = flowDangerouslySetHTML;
exports.consumeSanitizedHTML = flowConsumeSanitizedHTML;
exports.escape = flowEscape;
exports.unescape = unescape;
exports.assetUrl = assetUrl;
exports.chunkId = chunkId;
exports.syncChunkIds = syncChunkIds;
exports.syncChunkPaths = syncChunkPaths;
exports.RenderToken = RenderToken;
exports.ElementToken = ElementToken;
exports.SSRDeciderToken = SSRDeciderToken;
exports.HttpServerToken = HttpServerToken;
exports.createPlugin = createPlugin;
exports.createToken = createToken;
//# sourceMappingURL=index.js.map
