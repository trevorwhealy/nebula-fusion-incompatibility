'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
// eslint-disable-next-line flowtype/generic-spacing
function createPlugin(opts) {
  return Object.assign({
    __plugin__: true
  }, opts);
}

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
var TokenType = {
  Required: 0,
  Optional: 1
};

function Ref() {}

var TokenImpl = function TokenImpl(name, ref) {
  this.name = name;
  this.ref = ref || new Ref();
  this.type = ref ? TokenType.Optional : TokenType.Required;

  if (!ref) {
    this.optional = new TokenImpl(name, this.ref);
  }
};
function createToken(name) {
  // $FlowFixMe
  return new TokenImpl(name);
}

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
var RenderToken = createToken('RenderToken');
var ElementToken = createToken('ElementToken');
var SSRDeciderToken = createToken('SSRDeciderToken');
var HttpServerToken = createToken('HttpServerToken');

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

/*
We never want developers to be able to write `ctx.template.body.push(`<div>${stuff}</div>`)`
because that allows XSS attacks by default (e.g. if stuff === '<script>alert(1)</script>')
Instead, they should use html`<div>{stuff}</div>` so interpolated data gets automatically escaped
We trust the markup outside of interpolation because it's code written by a developer with commit permissions,
which can be audited via code reviews
*/
// eslint-disable-next-line import/no-mutable-exports
var html;
var dangerouslySetHTML;
var consumeSanitizedHTML;
var escape;

var replaceEscaped = function replaceEscaped(c) {
  return String.fromCodePoint(parseInt(c.slice(2), 16));
};

var unescape = function unescape(str) {
  return str.replace(/\\u003C|\\u003E|\\u0022|\\u002F|\\u2028|\\u2029/g, replaceEscaped);
}; // These types are necessary due to not having an assignment in the __BROWSER__ environment


var flowHtml = html;
var flowDangerouslySetHTML = dangerouslySetHTML;
var flowConsumeSanitizedHTML = consumeSanitizedHTML;
var flowEscape = escape;

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
var SSRDecider = createPlugin({
  provides: function provides() {
    return function (ctx) {
      // If the request has one of these extensions, we assume it's not something that requires server-side rendering of virtual dom
      // TODO(#46): this check should probably look at the asset manifest to ensure asset 404s are handled correctly
      if (ctx.path.match(/\.(js|gif|jpg|png|pdf|json)$/)) return false; // The Accept header is a good proxy for whether SSR should happen
      // Requesting an HTML page via the browser url bar generates a request with `text/html` in its Accept headers
      // XHR/fetch requests do not have `text/html` in the Accept headers

      if (!ctx.headers.accept) return false;
      if (!ctx.headers.accept.includes('text/html')) return false;
      return true;
    };
  }
});

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
var FusionApp =
/*#__PURE__*/
function () {
  function FusionApp(el, render) {
    this.registered = new Map(); // getTokenRef(token) -> {value, aliases, enhancers}

    this.enhancerToToken = new Map(); // enhancer -> token

    this.plugins = []; // Token

    this.cleanups = [];
    el && this.register(ElementToken, el);
    render && this.register(RenderToken, render);
    this.register(SSRDeciderToken, SSRDecider);
  } // eslint-disable-next-line


  var _proto = FusionApp.prototype;

  _proto.register = function register(token, value) {
    // $FlowFixMe
    if (token && token.__plugin__) {
      value = token;
      token = createToken('UnnamedPlugin');
    }

    if (!(token instanceof TokenImpl) && value === undefined) {
      throw new Error(process.env.NODE_ENV !== "production" ? "Cannot register " + String(token) + " without a token. Did you accidentally register a " + ('server') + " plugin on the " + ('browser') + "?" : 'Invalid configuration registration');
    } // the renderer is a special case, since it needs to be always run last


    if (token === RenderToken) {
      this.renderer = value;
      return {
        alias: function alias() {
          throw new Error('Aliasing for RenderToken not supported.');
        }
      };
    }

    return this._register(token, value);
  };

  _proto._register = function _register(token, value) {
    this.plugins.push(token);

    var _ref = this.registered.get(getTokenRef(token)) || {
      aliases: new Map(),
      enhancers: []
    },
        aliases = _ref.aliases,
        enhancers = _ref.enhancers;

    this.registered.set(getTokenRef(token), {
      value: value,
      aliases: aliases,
      enhancers: enhancers,
      token: token
    });

    function alias(sourceToken, destToken) {
      if (aliases) {
        aliases.set(sourceToken, destToken);
      }

      return {
        alias: alias
      };
    }

    return {
      alias: alias
    };
  };

  _proto.middleware = function middleware(deps, _middleware) {
    if (_middleware === undefined) {
      _middleware = function _middleware() {
        return deps;
      };
    }

    this.register(createPlugin({
      deps: deps,
      middleware: _middleware
    }));
  };

  _proto.enhance = function enhance(token, enhancer) {
    var _ref2 = this.registered.get(getTokenRef(token)) || {
      aliases: new Map(),
      enhancers: [],
      value: undefined
    },
        value = _ref2.value,
        aliases = _ref2.aliases,
        enhancers = _ref2.enhancers;

    this.enhancerToToken.set(enhancer, token);

    if (enhancers && Array.isArray(enhancers)) {
      enhancers.push(enhancer);
    }

    this.registered.set(getTokenRef(token), {
      value: value,
      aliases: aliases,
      enhancers: enhancers,
      token: token
    });
  };

  _proto.cleanup = function cleanup() {
    return Promise.all(this.cleanups.map(function (fn) {
      return fn();
    }));
  };

  _proto.resolve = function resolve() {
    var _this = this;

    if (!this.renderer) {
      throw new Error('Missing registration for RenderToken');
    }

    this._register(RenderToken, this.renderer);

    var resolved = new Map(); // Token.ref || Token => Service

    var dependedOn = new Set(); // Token.ref || Token

    var nonPluginTokens = new Set(); // Token

    var resolving = new Set(); // Token.ref || Token

    var registered = this.registered; // Token.ref || Token -> {value, aliases, enhancers}

    var resolvedPlugins = []; // Plugins

    var allAliases = new Set(); // Token.ref || Token

    var appliedEnhancers = [];

    var resolveToken = function resolveToken(token, tokenAliases) {
      // Base: if we have already resolved the type, return it
      if (tokenAliases && tokenAliases.has(token)) {
        var newToken = tokenAliases.get(token);
        allAliases.add([getTokenRef(token), getTokenRef(newToken)]);

        if (newToken) {
          token = newToken;
        }
      }

      if (resolved.has(getTokenRef(token))) {
        return resolved.get(getTokenRef(token));
      } // Base: if currently resolving the same type, we have a circular dependency


      if (resolving.has(getTokenRef(token))) {
        throw new Error("Cannot resolve circular dependency: " + token.name);
      } // Base: the type was never registered, throw error or provide undefined if optional


      var _ref3 = registered.get(getTokenRef(token)) || {},
          value = _ref3.value,
          aliases = _ref3.aliases,
          enhancers = _ref3.enhancers;

      if (value === undefined) {
        // Attempt to get default value, if optional
        if (token instanceof TokenImpl && token.type === TokenType.Optional) {
          _this.register(token, undefined);
        } else {
          var dependents = Array.from(_this.registered.entries());
          /**
           * Iterate over the entire list of dependencies and find all
           * dependencies of a given token.
           */

          var findDependentTokens = function findDependentTokens() {
            return dependents.filter(function (entry) {
              if (!entry[1].value || !entry[1].value.deps) {
                return false;
              }

              return Object.values(entry[1].value.deps).includes(token);
            }).map(function (entry) {
              return entry[1].token.name;
            });
          };

          var findDependentEnhancers = function findDependentEnhancers() {
            return appliedEnhancers.filter(function (_ref4) {
              var provides = _ref4[1];

              if (!provides || !provides.deps) {
                return false;
              }

              return Object.values(provides.deps).includes(token);
            }).map(function (_ref5) {
              var enhancer = _ref5[0];

              var enhancedToken = _this.enhancerToToken.get(enhancer);

              return "EnhancerOf<" + (enhancedToken ? enhancedToken.name : '(unknown)') + ">";
            });
          };

          var dependentTokens = [].concat(findDependentTokens(), findDependentEnhancers()); // otherwise, we cannot resolve this token

          throw new Error("Could not resolve token: \"" + (token ? token.name : '(unknown)') + "\", which is required by plugins registered with tokens: " + dependentTokens.map(function (token) {
            return "\"" + token + "\"";
          }).join(', ') + ". Did you forget to register a value for \"" + (token ? token.name : '(unknown)') + "\"?");
        }
      } // Recursive: get the registered type and resolve it


      resolving.add(getTokenRef(token));

      function resolvePlugin(plugin) {
        var registeredDeps = plugin && plugin.deps || {};
        var resolvedDeps = {};

        for (var key in registeredDeps) {
          var registeredToken = registeredDeps[key];
          dependedOn.add(getTokenRef(registeredToken));
          resolvedDeps[key] = resolveToken(registeredToken, aliases);
        } // `provides` should be undefined if the plugin does not have a `provides` function


        var provides = plugin && plugin.provides ? plugin.provides(resolvedDeps) : undefined;

        if (plugin && plugin.middleware) {
          resolvedPlugins.push(plugin.middleware(resolvedDeps, provides));
        }

        return provides;
      }

      var provides = value;

      if (value && value.__plugin__) {
        provides = resolvePlugin(provides);

        if (value.cleanup) {
          _this.cleanups.push(function () {
            return typeof value.cleanup === 'function' ? value.cleanup(provides) : Promise.resolve();
          });
        }
      } else {
        nonPluginTokens.add(token);
      }

      if (enhancers && enhancers.length) {
        enhancers.forEach(function (e) {
          var nextProvides = e(provides);
          appliedEnhancers.push([e, nextProvides]);

          if (nextProvides && nextProvides.__plugin__) {
            nextProvides = resolvePlugin(nextProvides);
          }

          provides = nextProvides;
        });
      }

      resolved.set(getTokenRef(token), provides);
      resolving.delete(getTokenRef(token));
      return provides;
    };

    for (var i = 0; i < this.plugins.length; i++) {
      resolveToken(this.plugins[i]);
    }

    for (var _iterator = allAliases, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
      var _ref6;

      if (_isArray) {
        if (_i >= _iterator.length) break;
        _ref6 = _iterator[_i++];
      } else {
        _i = _iterator.next();
        if (_i.done) break;
        _ref6 = _i.value;
      }

      var _aliasPair = _ref6;
      var sourceTokenRef = _aliasPair[0],
          destTokenRef = _aliasPair[1];

      if (dependedOn.has(sourceTokenRef)) {
        dependedOn.add(destTokenRef);
      }
    }

    for (var _iterator2 = nonPluginTokens, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {
      var _ref7;

      if (_isArray2) {
        if (_i2 >= _iterator2.length) break;
        _ref7 = _iterator2[_i2++];
      } else {
        _i2 = _iterator2.next();
        if (_i2.done) break;
        _ref7 = _i2.value;
      }

      var _token2 = _ref7;

      if (!dependedOn.has(getTokenRef(_token2))) {
        throw new Error("Registered token without depending on it: \"" + _token2.name + "\"");
      }
    }

    this.plugins = resolvedPlugins;
  };

  return FusionApp;
}();
/* Helper functions */


function getTokenRef(token) {
  if (token instanceof TokenImpl) {
    return token.ref;
  }

  return token;
}

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
// inline version of koa-compose to get around Rollup/CUP commonjs-related issue
function compose(middleware) {
  if (!Array.isArray(middleware)) {
    throw new TypeError('Middleware stack must be an array!');
  }

  for (var _iterator = middleware, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
    var _ref;

    if (_isArray) {
      if (_i >= _iterator.length) break;
      _ref = _iterator[_i++];
    } else {
      _i = _iterator.next();
      if (_i.done) break;
      _ref = _i.value;
    }

    var _fn = _ref;

    if (typeof _fn !== 'function') {
      throw new TypeError("Expected middleware function, received: " + _typeof(_fn));
    }
  }

  return function (context, next) {
    var index = -1;
    return dispatch(0);

    function dispatch(i) {
      if (i <= index) {
        return Promise.reject(new Error('next() called multiple times'));
      }

      index = i;
      var fn = middleware[i];
      if (i === middleware.length) fn = next;
      if (!fn) return Promise.resolve();

      try {
        // $FlowFixMe
        return fn(context, function next() {
          return dispatch(i + 1);
        });
      } catch (err) {
        return Promise.reject(err);
      }
    }
  };
}

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
function Container() {}

function memoize(fn) {
  var memoizeKey = new Container();
  return function memoized(ctx) {
    if (ctx.memoized.has(memoizeKey)) {
      return ctx.memoized.get(memoizeKey);
    }

    var result = fn(ctx);
    ctx.memoized.set(memoizeKey, result);
    return result;
  };
}

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
var Timing = function Timing() {
  this.start = now();
  this.render = deferred();
  this.end = deferred();
  this.downstream = deferred();
  this.upstream = deferred();
  this.upstreamStart = -1;
};

var timing = {
  from: memoize(function () {
    return new Timing();
  })
};
var TimingToken = createToken('TimingToken');

function _middleware(ctx, next) {
  ctx.memoized = new Map();

  var _timing$from = timing.from(ctx),
      start = _timing$from.start,
      render = _timing$from.render,
      end = _timing$from.end,
      downstream = _timing$from.downstream,
      upstream = _timing$from.upstream;

  ctx.timing = {
    start: start,
    render: render.promise,
    end: end.promise,
    downstream: downstream.promise,
    upstream: upstream.promise
  };
  return next().then(function () {
    var upstreamTime = now() - timing.from(ctx).upstreamStart;
    upstream.resolve(upstreamTime);
    var endTime = now() - ctx.timing.start;
    end.resolve(endTime);
  });
}

var timing$1 = createPlugin({
  provides: function provides() {
    return timing;
  },
  middleware: function middleware() {
    return _middleware;
  }
});
function now() {
  {
    // eslint-disable-next-line cup/no-undef
    if (window.performance && window.performance.now) {
      // eslint-disable-next-line cup/no-undef
      return Math.round(window.performance.now());
    }

    return Date.now();
  }
}

function deferred() {
  var resolve = function resolve() {};

  var reject = function reject() {};

  var promise = new Promise(function (res, rej) {
    resolve = res;
    reject = rej;
  });
  return {
    promise: promise,
    resolve: resolve,
    reject: reject
  };
}

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

/* eslint-env node */
var getEnv = function () {};

 // Handle flow-types for export so browser export is ignored.

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

/* eslint-env node */

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

/* eslint-env browser */
function createClientHydrate(_ref) {
  var element = _ref.element;
  return function clientHydrate(ctx, next) {
    ctx.prefix = window.__ROUTE_PREFIX__ || ''; // serialized by ./server

    ctx.element = element;
    ctx.preloadChunks = [];
    return next();
  };
}

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
function createClientRenderer(_ref) {
  var render = _ref.render;
  return function renderer(ctx, next) {
    var rendered = render(ctx.element);

    if (rendered instanceof Promise) {
      return rendered.then(function (r) {
        ctx.rendered = r;
        return next();
      });
    } else {
      ctx.rendered = rendered;
      return next();
    }
  };
}

function _inheritsLoose$1(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

/* eslint-env browser */
function clientApp () {
  return (
    /*#__PURE__*/
    function (_BaseApp) {
      _inheritsLoose$1(ClientApp, _BaseApp);

      function ClientApp(el, render) {
        var _this;

        _this = _BaseApp.call(this, el, render) || this;

        _this.register(TimingToken, timing$1);

        _this.middleware({
          element: ElementToken
        }, createClientHydrate);

        return _this;
      }

      var _proto = ClientApp.prototype;

      _proto.resolve = function resolve() {
        this.middleware({
          render: RenderToken
        }, createClientRenderer);
        return _BaseApp.prototype.resolve.call(this);
      };

      _proto.callback = function callback() {
        this.resolve();
        var middleware = compose(this.plugins);
        return function () {
          // TODO(#62): Create noop context object to match server api
          var ctx = {
            url: window.location.path + window.location.search,
            element: null,
            body: null
          }; // $FlowFixMe

          return middleware(ctx, function () {
            return Promise.resolve();
          }).then(function () {
            return ctx;
          });
        };
      };

      return ClientApp;
    }(FusionApp)
  );
}

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
function assetUrl(url) {
  /**
   * PLEASE NOTE: a build step transforms
   * the arguments provided to this function
   */
  return url;
}
function chunkId(filename) {
  /**
   * PLEASE NOTE: a build step transforms
   * the arguments provided to this function
   */
  return filename;
}
function syncChunkIds(argument) {
  /**
   * PLEASE NOTE: a build step transforms
   * the arguments provided to this function
   */
  return argument;
}
function syncChunkPaths(argument) {
  /**
   * PLEASE NOTE: a build step transforms
   * the arguments provided to this function
   */
  return argument;
}

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
var index = clientApp();

exports.default = index;
exports.getEnv = getEnv;
exports.compose = compose;
exports.memoize = memoize;
exports.html = flowHtml;
exports.dangerouslySetHTML = flowDangerouslySetHTML;
exports.consumeSanitizedHTML = flowConsumeSanitizedHTML;
exports.escape = flowEscape;
exports.unescape = unescape;
exports.assetUrl = assetUrl;
exports.chunkId = chunkId;
exports.syncChunkIds = syncChunkIds;
exports.syncChunkPaths = syncChunkPaths;
exports.RenderToken = RenderToken;
exports.ElementToken = ElementToken;
exports.SSRDeciderToken = SSRDeciderToken;
exports.HttpServerToken = HttpServerToken;
exports.createPlugin = createPlugin;
exports.createToken = createToken;
//# sourceMappingURL=browser.es5.js.map
