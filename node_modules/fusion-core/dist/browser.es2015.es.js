/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
// eslint-disable-next-line flowtype/generic-spacing
function createPlugin(opts) {
  return Object.assign({
    __plugin__: true
  }, opts);
}

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
const TokenType = {
  Required: 0,
  Optional: 1
};

function Ref() {}

class TokenImpl {
  constructor(name, ref) {
    this.name = name;
    this.ref = ref || new Ref();
    this.type = ref ? TokenType.Optional : TokenType.Required;

    if (!ref) {
      this.optional = new TokenImpl(name, this.ref);
    }
  }

}
function createToken(name) {
  // $FlowFixMe
  return new TokenImpl(name);
}

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
const RenderToken = createToken('RenderToken');
const ElementToken = createToken('ElementToken');
const SSRDeciderToken = createToken('SSRDeciderToken');
const HttpServerToken = createToken('HttpServerToken');

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

/*
We never want developers to be able to write `ctx.template.body.push(`<div>${stuff}</div>`)`
because that allows XSS attacks by default (e.g. if stuff === '<script>alert(1)</script>')
Instead, they should use html`<div>{stuff}</div>` so interpolated data gets automatically escaped
We trust the markup outside of interpolation because it's code written by a developer with commit permissions,
which can be audited via code reviews
*/
// eslint-disable-next-line import/no-mutable-exports
let html;
let dangerouslySetHTML;
let consumeSanitizedHTML;
let escape;

const replaceEscaped = c => String.fromCodePoint(parseInt(c.slice(2), 16));

const unescape = str => {
  return str.replace(/\\u003C|\\u003E|\\u0022|\\u002F|\\u2028|\\u2029/g, replaceEscaped);
}; // These types are necessary due to not having an assignment in the __BROWSER__ environment


const flowHtml = html;
const flowDangerouslySetHTML = dangerouslySetHTML;
const flowConsumeSanitizedHTML = consumeSanitizedHTML;
const flowEscape = escape;

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
const SSRDecider = createPlugin({
  provides: () => ctx => {
    // If the request has one of these extensions, we assume it's not something that requires server-side rendering of virtual dom
    // TODO(#46): this check should probably look at the asset manifest to ensure asset 404s are handled correctly
    if (ctx.path.match(/\.(js|gif|jpg|png|pdf|json)$/)) return false; // The Accept header is a good proxy for whether SSR should happen
    // Requesting an HTML page via the browser url bar generates a request with `text/html` in its Accept headers
    // XHR/fetch requests do not have `text/html` in the Accept headers

    if (!ctx.headers.accept) return false;
    if (!ctx.headers.accept.includes('text/html')) return false;
    return true;
  }
});

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
class FusionApp {
  constructor(el, render) {
    this.registered = new Map(); // getTokenRef(token) -> {value, aliases, enhancers}

    this.enhancerToToken = new Map(); // enhancer -> token

    this.plugins = []; // Token

    this.cleanups = [];
    el && this.register(ElementToken, el);
    render && this.register(RenderToken, render);
    this.register(SSRDeciderToken, SSRDecider);
  } // eslint-disable-next-line


  register(token, value) {
    // $FlowFixMe
    if (token && token.__plugin__) {
      value = token;
      token = createToken('UnnamedPlugin');
    }

    if (!(token instanceof TokenImpl) && value === undefined) {
      throw new Error(process.env.NODE_ENV !== "production" ? `Cannot register ${String(token)} without a token. Did you accidentally register a ${'server'} plugin on the ${'browser'}?` : 'Invalid configuration registration');
    } // the renderer is a special case, since it needs to be always run last


    if (token === RenderToken) {
      this.renderer = value;
      return {
        alias: () => {
          throw new Error('Aliasing for RenderToken not supported.');
        }
      };
    }

    return this._register(token, value);
  }

  _register(token, value) {
    this.plugins.push(token);
    const {
      aliases,
      enhancers
    } = this.registered.get(getTokenRef(token)) || {
      aliases: new Map(),
      enhancers: []
    };
    this.registered.set(getTokenRef(token), {
      value,
      aliases,
      enhancers,
      token
    });

    function alias(sourceToken, destToken) {
      if (aliases) {
        aliases.set(sourceToken, destToken);
      }

      return {
        alias
      };
    }

    return {
      alias
    };
  }

  middleware(deps, middleware) {
    if (middleware === undefined) {
      middleware = () => deps;
    }

    this.register(createPlugin({
      deps,
      middleware
    }));
  }

  enhance(token, enhancer) {
    const {
      value,
      aliases,
      enhancers
    } = this.registered.get(getTokenRef(token)) || {
      aliases: new Map(),
      enhancers: [],
      value: undefined
    };
    this.enhancerToToken.set(enhancer, token);

    if (enhancers && Array.isArray(enhancers)) {
      enhancers.push(enhancer);
    }

    this.registered.set(getTokenRef(token), {
      value,
      aliases,
      enhancers,
      token
    });
  }

  cleanup() {
    return Promise.all(this.cleanups.map(fn => fn()));
  }

  resolve() {
    if (!this.renderer) {
      throw new Error('Missing registration for RenderToken');
    }

    this._register(RenderToken, this.renderer);

    const resolved = new Map(); // Token.ref || Token => Service

    const dependedOn = new Set(); // Token.ref || Token

    const nonPluginTokens = new Set(); // Token

    const resolving = new Set(); // Token.ref || Token

    const registered = this.registered; // Token.ref || Token -> {value, aliases, enhancers}

    const resolvedPlugins = []; // Plugins

    const allAliases = new Set(); // Token.ref || Token

    const appliedEnhancers = [];

    const resolveToken = (token, tokenAliases) => {
      // Base: if we have already resolved the type, return it
      if (tokenAliases && tokenAliases.has(token)) {
        const newToken = tokenAliases.get(token);
        allAliases.add([getTokenRef(token), getTokenRef(newToken)]);

        if (newToken) {
          token = newToken;
        }
      }

      if (resolved.has(getTokenRef(token))) {
        return resolved.get(getTokenRef(token));
      } // Base: if currently resolving the same type, we have a circular dependency


      if (resolving.has(getTokenRef(token))) {
        throw new Error(`Cannot resolve circular dependency: ${token.name}`);
      } // Base: the type was never registered, throw error or provide undefined if optional


      let {
        value,
        aliases,
        enhancers
      } = registered.get(getTokenRef(token)) || {};

      if (value === undefined) {
        // Attempt to get default value, if optional
        if (token instanceof TokenImpl && token.type === TokenType.Optional) {
          this.register(token, undefined);
        } else {
          const dependents = Array.from(this.registered.entries());
          /**
           * Iterate over the entire list of dependencies and find all
           * dependencies of a given token.
           */

          const findDependentTokens = () => {
            return dependents.filter(entry => {
              if (!entry[1].value || !entry[1].value.deps) {
                return false;
              }

              return Object.values(entry[1].value.deps).includes(token);
            }).map(entry => entry[1].token.name);
          };

          const findDependentEnhancers = () => {
            return appliedEnhancers.filter(([, provides]) => {
              if (!provides || !provides.deps) {
                return false;
              }

              return Object.values(provides.deps).includes(token);
            }).map(([enhancer]) => {
              const enhancedToken = this.enhancerToToken.get(enhancer);
              return `EnhancerOf<${enhancedToken ? enhancedToken.name : '(unknown)'}>`;
            });
          };

          const dependentTokens = [...findDependentTokens(), ...findDependentEnhancers()]; // otherwise, we cannot resolve this token

          throw new Error(`Could not resolve token: "${token ? token.name : '(unknown)'}", which is required by plugins registered with tokens: ${dependentTokens.map(token => `"${token}"`).join(', ')}. Did you forget to register a value for "${token ? token.name : '(unknown)'}"?`);
        }
      } // Recursive: get the registered type and resolve it


      resolving.add(getTokenRef(token));

      function resolvePlugin(plugin) {
        const registeredDeps = plugin && plugin.deps || {};
        const resolvedDeps = {};

        for (const key in registeredDeps) {
          const registeredToken = registeredDeps[key];
          dependedOn.add(getTokenRef(registeredToken));
          resolvedDeps[key] = resolveToken(registeredToken, aliases);
        } // `provides` should be undefined if the plugin does not have a `provides` function


        let provides = plugin && plugin.provides ? plugin.provides(resolvedDeps) : undefined;

        if (plugin && plugin.middleware) {
          resolvedPlugins.push(plugin.middleware(resolvedDeps, provides));
        }

        return provides;
      }

      let provides = value;

      if (value && value.__plugin__) {
        provides = resolvePlugin(provides);

        if (value.cleanup) {
          this.cleanups.push(function () {
            return typeof value.cleanup === 'function' ? value.cleanup(provides) : Promise.resolve();
          });
        }
      } else {
        nonPluginTokens.add(token);
      }

      if (enhancers && enhancers.length) {
        enhancers.forEach(e => {
          let nextProvides = e(provides);
          appliedEnhancers.push([e, nextProvides]);

          if (nextProvides && nextProvides.__plugin__) {
            nextProvides = resolvePlugin(nextProvides);
          }

          provides = nextProvides;
        });
      }

      resolved.set(getTokenRef(token), provides);
      resolving.delete(getTokenRef(token));
      return provides;
    };

    for (let i = 0; i < this.plugins.length; i++) {
      resolveToken(this.plugins[i]);
    }

    for (const aliasPair of allAliases) {
      const [sourceTokenRef, destTokenRef] = aliasPair;

      if (dependedOn.has(sourceTokenRef)) {
        dependedOn.add(destTokenRef);
      }
    }

    for (const token of nonPluginTokens) {
      if (!dependedOn.has(getTokenRef(token))) {
        throw new Error(`Registered token without depending on it: "${token.name}"`);
      }
    }

    this.plugins = resolvedPlugins;
  }

}
/* Helper functions */


function getTokenRef(token) {
  if (token instanceof TokenImpl) {
    return token.ref;
  }

  return token;
}

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
// inline version of koa-compose to get around Rollup/CUP commonjs-related issue
function compose(middleware) {
  if (!Array.isArray(middleware)) {
    throw new TypeError('Middleware stack must be an array!');
  }

  for (const fn of middleware) {
    if (typeof fn !== 'function') {
      throw new TypeError(`Expected middleware function, received: ${typeof fn}`);
    }
  }

  return function (context, next) {
    let index = -1;
    return dispatch(0);

    function dispatch(i) {
      if (i <= index) {
        return Promise.reject(new Error('next() called multiple times'));
      }

      index = i;
      let fn = middleware[i];
      if (i === middleware.length) fn = next;
      if (!fn) return Promise.resolve();

      try {
        // $FlowFixMe
        return fn(context, function next() {
          return dispatch(i + 1);
        });
      } catch (err) {
        return Promise.reject(err);
      }
    }
  };
}

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
function Container() {}

function memoize(fn) {
  const memoizeKey = new Container();
  return function memoized(ctx) {
    if (ctx.memoized.has(memoizeKey)) {
      return ctx.memoized.get(memoizeKey);
    }

    const result = fn(ctx);
    ctx.memoized.set(memoizeKey, result);
    return result;
  };
}

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
class Timing {
  constructor() {
    this.start = now();
    this.render = deferred();
    this.end = deferred();
    this.downstream = deferred();
    this.upstream = deferred();
    this.upstreamStart = -1;
  }

}

const timing = {
  from: memoize(() => new Timing())
};
const TimingToken = createToken('TimingToken');

function middleware(ctx, next) {
  ctx.memoized = new Map();
  const {
    start,
    render,
    end,
    downstream,
    upstream
  } = timing.from(ctx);
  ctx.timing = {
    start,
    render: render.promise,
    end: end.promise,
    downstream: downstream.promise,
    upstream: upstream.promise
  };
  return next().then(() => {
    const upstreamTime = now() - timing.from(ctx).upstreamStart;
    upstream.resolve(upstreamTime);
    const endTime = now() - ctx.timing.start;
    end.resolve(endTime);
  });
}

var timing$1 = createPlugin({
  provides: () => timing,
  middleware: () => middleware
});
function now() {
  {
    // eslint-disable-next-line cup/no-undef
    if (window.performance && window.performance.now) {
      // eslint-disable-next-line cup/no-undef
      return Math.round(window.performance.now());
    }

    return Date.now();
  }
}

function deferred() {
  let resolve = () => {};

  let reject = () => {};

  const promise = new Promise((res, rej) => {
    resolve = res;
    reject = rej;
  });
  return {
    promise,
    resolve,
    reject
  };
}

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

/* eslint-env node */
var getEnv = () => {};

 // Handle flow-types for export so browser export is ignored.

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

/* eslint-env node */

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

/* eslint-env browser */
function createClientHydrate({
  element
}) {
  return function clientHydrate(ctx, next) {
    ctx.prefix = window.__ROUTE_PREFIX__ || ''; // serialized by ./server

    ctx.element = element;
    ctx.preloadChunks = [];
    return next();
  };
}

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
function createClientRenderer({
  render
}) {
  return function renderer(ctx, next) {
    const rendered = render(ctx.element);

    if (rendered instanceof Promise) {
      return rendered.then(r => {
        ctx.rendered = r;
        return next();
      });
    } else {
      ctx.rendered = rendered;
      return next();
    }
  };
}

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

/* eslint-env browser */
function clientApp () {
  return class ClientApp extends FusionApp {
    constructor(el, render) {
      super(el, render);
      this.register(TimingToken, timing$1);
      this.middleware({
        element: ElementToken
      }, createClientHydrate);
    }

    resolve() {
      this.middleware({
        render: RenderToken
      }, createClientRenderer);
      return super.resolve();
    }

    callback() {
      this.resolve();
      const middleware = compose(this.plugins);
      return () => {
        // TODO(#62): Create noop context object to match server api
        const ctx = {
          url: window.location.path + window.location.search,
          element: null,
          body: null
        }; // $FlowFixMe

        return middleware(ctx, () => Promise.resolve()).then(() => ctx);
      };
    }

  };
}

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
function assetUrl(url) {
  /**
   * PLEASE NOTE: a build step transforms
   * the arguments provided to this function
   */
  return url;
}
function chunkId(filename) {
  /**
   * PLEASE NOTE: a build step transforms
   * the arguments provided to this function
   */
  return filename;
}
function syncChunkIds(argument) {
  /**
   * PLEASE NOTE: a build step transforms
   * the arguments provided to this function
   */
  return argument;
}
function syncChunkPaths(argument) {
  /**
   * PLEASE NOTE: a build step transforms
   * the arguments provided to this function
   */
  return argument;
}

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
var index = clientApp();

export default index;
export { getEnv, compose, memoize, flowHtml as html, flowDangerouslySetHTML as dangerouslySetHTML, flowConsumeSanitizedHTML as consumeSanitizedHTML, flowEscape as escape, unescape, assetUrl, chunkId, syncChunkIds, syncChunkPaths, RenderToken, ElementToken, SSRDeciderToken, HttpServerToken, createPlugin, createToken };
//# sourceMappingURL=browser.es2015.es.js.map
