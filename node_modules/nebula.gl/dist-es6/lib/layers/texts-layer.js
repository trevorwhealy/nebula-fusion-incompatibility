'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _deck = require('deck.gl');

var _nebulaLayer = require('../nebula-layer');

var _nebulaLayer2 = _interopRequireDefault(_nebulaLayer);

var _utils = require('../utils');

var _deckCache2 = require('../deck-renderer/deck-cache');

var _deckCache3 = _interopRequireDefault(_deckCache2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var TextsLayer = function (_NebulaLayer) {
  _inherits(TextsLayer, _NebulaLayer);

  function TextsLayer(config) {
    _classCallCheck(this, TextsLayer);

    var _this = _possibleConstructorReturn(this, (TextsLayer.__proto__ || Object.getPrototypeOf(TextsLayer)).call(this, config));

    _this.deckCache = new _deckCache3.default(config.getData, function (data) {
      return config.toNebulaFeature(data);
    });
    return _this;
  }

  _createClass(TextsLayer, [{
    key: 'render',
    value: function render(_ref) {
      var nebula = _ref.nebula;

      var defaultColor = [0x0, 0x0, 0x0, 0xff];
      var _deckCache = this.deckCache,
          objects = _deckCache.objects,
          updateTrigger = _deckCache.updateTrigger;
      var zoom = nebula.props.viewport.zoom;


      return new _deck.TextLayer({
        id: 'texts-' + this.id,
        data: objects,
        opacity: 1,
        fp64: false,
        pickable: false,

        getText: function getText(nf) {
          return nf.style.text;
        },
        getPosition: function getPosition(nf) {
          return nebula.projector.coordsToLngLatOffset(nf.geoJson.geometry.coordinates);
        },
        getColor: function getColor(nf) {
          return (0, _utils.toDeckColor)(nf.style.fillColor) || defaultColor;
        },

        // TODO: layer should offer option to scale with zoom
        sizeScale: 1 / Math.pow(2, 20 - zoom),

        coordinateSystem: _deck.COORDINATE_SYSTEM.LNGLAT_OFFSETS,
        coordinateOrigin: nebula.projector.lngLat,
        updateTriggers: { all: updateTrigger + '_' + nebula.projector.lngLat },

        nebulaLayer: this
      });
    }
  }]);

  return TextsLayer;
}(_nebulaLayer2.default);

exports.default = TextsLayer;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9saWIvbGF5ZXJzL3RleHRzLWxheWVyLmpzIl0sIm5hbWVzIjpbIlRleHRzTGF5ZXIiLCJjb25maWciLCJkZWNrQ2FjaGUiLCJnZXREYXRhIiwidG9OZWJ1bGFGZWF0dXJlIiwiZGF0YSIsIm5lYnVsYSIsImRlZmF1bHRDb2xvciIsIm9iamVjdHMiLCJ1cGRhdGVUcmlnZ2VyIiwiem9vbSIsInByb3BzIiwidmlld3BvcnQiLCJpZCIsIm9wYWNpdHkiLCJmcDY0IiwicGlja2FibGUiLCJnZXRUZXh0IiwibmYiLCJzdHlsZSIsInRleHQiLCJnZXRQb3NpdGlvbiIsInByb2plY3RvciIsImNvb3Jkc1RvTG5nTGF0T2Zmc2V0IiwiZ2VvSnNvbiIsImdlb21ldHJ5IiwiY29vcmRpbmF0ZXMiLCJnZXRDb2xvciIsImZpbGxDb2xvciIsInNpemVTY2FsZSIsIk1hdGgiLCJwb3ciLCJjb29yZGluYXRlU3lzdGVtIiwiTE5HTEFUX09GRlNFVFMiLCJjb29yZGluYXRlT3JpZ2luIiwibG5nTGF0IiwidXBkYXRlVHJpZ2dlcnMiLCJhbGwiLCJuZWJ1bGFMYXllciJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFDQTs7QUFFQTs7OztBQUNBOztBQUNBOzs7Ozs7Ozs7Ozs7SUFFcUJBLFU7OztBQUduQixzQkFBWUMsTUFBWixFQUE0QjtBQUFBOztBQUFBLHdIQUNwQkEsTUFEb0I7O0FBRTFCLFVBQUtDLFNBQUwsR0FBaUIsd0JBQWNELE9BQU9FLE9BQXJCLEVBQThCO0FBQUEsYUFBUUYsT0FBT0csZUFBUCxDQUF1QkMsSUFBdkIsQ0FBUjtBQUFBLEtBQTlCLENBQWpCO0FBRjBCO0FBRzNCOzs7O2lDQUUwQjtBQUFBLFVBQWxCQyxNQUFrQixRQUFsQkEsTUFBa0I7O0FBQ3pCLFVBQU1DLGVBQWUsQ0FBQyxHQUFELEVBQU0sR0FBTixFQUFXLEdBQVgsRUFBZ0IsSUFBaEIsQ0FBckI7QUFEeUIsdUJBRVUsS0FBS0wsU0FGZjtBQUFBLFVBRWpCTSxPQUZpQixjQUVqQkEsT0FGaUI7QUFBQSxVQUVSQyxhQUZRLGNBRVJBLGFBRlE7QUFBQSxVQUlqQkMsSUFKaUIsR0FJUkosT0FBT0ssS0FBUCxDQUFhQyxRQUpMLENBSWpCRixJQUppQjs7O0FBTXpCLGFBQU8sb0JBQWM7QUFDbkJHLHVCQUFhLEtBQUtBLEVBREM7QUFFbkJSLGNBQU1HLE9BRmE7QUFHbkJNLGlCQUFTLENBSFU7QUFJbkJDLGNBQU0sS0FKYTtBQUtuQkMsa0JBQVUsS0FMUzs7QUFPbkJDLGlCQUFTO0FBQUEsaUJBQU1DLEdBQUdDLEtBQUgsQ0FBU0MsSUFBZjtBQUFBLFNBUFU7QUFRbkJDLHFCQUFhO0FBQUEsaUJBQU1mLE9BQU9nQixTQUFQLENBQWlCQyxvQkFBakIsQ0FBc0NMLEdBQUdNLE9BQUgsQ0FBV0MsUUFBWCxDQUFvQkMsV0FBMUQsQ0FBTjtBQUFBLFNBUk07QUFTbkJDLGtCQUFVO0FBQUEsaUJBQU0sd0JBQVlULEdBQUdDLEtBQUgsQ0FBU1MsU0FBckIsS0FBbUNyQixZQUF6QztBQUFBLFNBVFM7O0FBV25CO0FBQ0FzQixtQkFBVyxJQUFJQyxLQUFLQyxHQUFMLENBQVMsQ0FBVCxFQUFZLEtBQUtyQixJQUFqQixDQVpJOztBQWNuQnNCLDBCQUFrQix3QkFBa0JDLGNBZGpCO0FBZW5CQywwQkFBa0I1QixPQUFPZ0IsU0FBUCxDQUFpQmEsTUFmaEI7QUFnQm5CQyx3QkFBZ0IsRUFBRUMsS0FBUTVCLGFBQVIsU0FBeUJILE9BQU9nQixTQUFQLENBQWlCYSxNQUE1QyxFQWhCRzs7QUFrQm5CRyxxQkFBYTtBQWxCTSxPQUFkLENBQVA7QUFvQkQ7Ozs7OztrQkFsQ2tCdEMsVSIsImZpbGUiOiJ0ZXh0cy1sYXllci5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIEBmbG93XG5pbXBvcnQgeyBDT09SRElOQVRFX1NZU1RFTSwgVGV4dExheWVyIH0gZnJvbSAnZGVjay5nbCc7XG5cbmltcG9ydCBOZWJ1bGFMYXllciBmcm9tICcuLi9uZWJ1bGEtbGF5ZXInO1xuaW1wb3J0IHsgdG9EZWNrQ29sb3IgfSBmcm9tICcuLi91dGlscyc7XG5pbXBvcnQgRGVja0NhY2hlIGZyb20gJy4uL2RlY2stcmVuZGVyZXIvZGVjay1jYWNoZSc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRleHRzTGF5ZXIgZXh0ZW5kcyBOZWJ1bGFMYXllciB7XG4gIGRlY2tDYWNoZTogRGVja0NhY2hlPCosICo+O1xuXG4gIGNvbnN0cnVjdG9yKGNvbmZpZzogT2JqZWN0KSB7XG4gICAgc3VwZXIoY29uZmlnKTtcbiAgICB0aGlzLmRlY2tDYWNoZSA9IG5ldyBEZWNrQ2FjaGUoY29uZmlnLmdldERhdGEsIGRhdGEgPT4gY29uZmlnLnRvTmVidWxhRmVhdHVyZShkYXRhKSk7XG4gIH1cblxuICByZW5kZXIoeyBuZWJ1bGEgfTogT2JqZWN0KSB7XG4gICAgY29uc3QgZGVmYXVsdENvbG9yID0gWzB4MCwgMHgwLCAweDAsIDB4ZmZdO1xuICAgIGNvbnN0IHsgb2JqZWN0cywgdXBkYXRlVHJpZ2dlciB9ID0gdGhpcy5kZWNrQ2FjaGU7XG5cbiAgICBjb25zdCB7IHpvb20gfSA9IG5lYnVsYS5wcm9wcy52aWV3cG9ydDtcblxuICAgIHJldHVybiBuZXcgVGV4dExheWVyKHtcbiAgICAgIGlkOiBgdGV4dHMtJHt0aGlzLmlkfWAsXG4gICAgICBkYXRhOiBvYmplY3RzLFxuICAgICAgb3BhY2l0eTogMSxcbiAgICAgIGZwNjQ6IGZhbHNlLFxuICAgICAgcGlja2FibGU6IGZhbHNlLFxuXG4gICAgICBnZXRUZXh0OiBuZiA9PiBuZi5zdHlsZS50ZXh0LFxuICAgICAgZ2V0UG9zaXRpb246IG5mID0+IG5lYnVsYS5wcm9qZWN0b3IuY29vcmRzVG9MbmdMYXRPZmZzZXQobmYuZ2VvSnNvbi5nZW9tZXRyeS5jb29yZGluYXRlcyksXG4gICAgICBnZXRDb2xvcjogbmYgPT4gdG9EZWNrQ29sb3IobmYuc3R5bGUuZmlsbENvbG9yKSB8fCBkZWZhdWx0Q29sb3IsXG5cbiAgICAgIC8vIFRPRE86IGxheWVyIHNob3VsZCBvZmZlciBvcHRpb24gdG8gc2NhbGUgd2l0aCB6b29tXG4gICAgICBzaXplU2NhbGU6IDEgLyBNYXRoLnBvdygyLCAyMCAtIHpvb20pLFxuXG4gICAgICBjb29yZGluYXRlU3lzdGVtOiBDT09SRElOQVRFX1NZU1RFTS5MTkdMQVRfT0ZGU0VUUyxcbiAgICAgIGNvb3JkaW5hdGVPcmlnaW46IG5lYnVsYS5wcm9qZWN0b3IubG5nTGF0LFxuICAgICAgdXBkYXRlVHJpZ2dlcnM6IHsgYWxsOiBgJHt1cGRhdGVUcmlnZ2VyfV8ke25lYnVsYS5wcm9qZWN0b3IubG5nTGF0fWAgfSxcblxuICAgICAgbmVidWxhTGF5ZXI6IHRoaXNcbiAgICB9KTtcbiAgfVxufVxuIl19