'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _deck = require('deck.gl');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var JunctionScatterplotLayer = function (_CompositeLayer) {
  _inherits(JunctionScatterplotLayer, _CompositeLayer);

  function JunctionScatterplotLayer() {
    _classCallCheck(this, JunctionScatterplotLayer);

    return _possibleConstructorReturn(this, (JunctionScatterplotLayer.__proto__ || Object.getPrototypeOf(JunctionScatterplotLayer)).apply(this, arguments));
  }

  _createClass(JunctionScatterplotLayer, [{
    key: 'renderLayers',
    value: function renderLayers() {
      var _props = this.props,
          id = _props.id,
          getFillColor = _props.getFillColor,
          getStrokeColor = _props.getStrokeColor,
          getInnerRadius = _props.getInnerRadius,
          updateTriggers = _props.updateTriggers;

      // data needs to be passed explicitly after deck.gl 5.3

      return [
      // the full circles
      new _deck.ScatterplotLayer(_extends({}, this.props, {
        id: id + '-full',
        data: this.props.data,
        getColor: getStrokeColor,
        updateTriggers: _extends({}, updateTriggers, {
          getColor: updateTriggers.getStrokeColor
        })
      })),
      // the inner part
      new _deck.ScatterplotLayer(_extends({}, this.props, {
        id: id + '-inner',
        data: this.props.data,
        getColor: getFillColor,
        getRadius: getInnerRadius,
        pickable: false,
        updateTriggers: _extends({}, updateTriggers, {
          getColor: updateTriggers.getFillColor,
          getRadius: updateTriggers.getInnerRadius
        })
      }))];
    }
  }]);

  return JunctionScatterplotLayer;
}(_deck.CompositeLayer);

JunctionScatterplotLayer.layerName = 'JunctionScatterplotLayer';
JunctionScatterplotLayer.defaultProps = _extends({}, _deck.ScatterplotLayer.defaultProps, {
  getFillColor: function getFillColor(d) {
    return [0, 0, 0, 255];
  },
  getStrokeColor: function getStrokeColor(d) {
    return [255, 255, 255, 255];
  },
  getInnerRadius: function getInnerRadius(d) {
    return 1;
  }
});
exports.default = JunctionScatterplotLayer;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9saWIvZGVjay1yZW5kZXJlci9qdW5jdGlvbi1zY2F0dGVycGxvdC1sYXllci5qcyJdLCJuYW1lcyI6WyJKdW5jdGlvblNjYXR0ZXJwbG90TGF5ZXIiLCJwcm9wcyIsImlkIiwiZ2V0RmlsbENvbG9yIiwiZ2V0U3Ryb2tlQ29sb3IiLCJnZXRJbm5lclJhZGl1cyIsInVwZGF0ZVRyaWdnZXJzIiwiZGF0YSIsImdldENvbG9yIiwiZ2V0UmFkaXVzIiwicGlja2FibGUiLCJsYXllck5hbWUiLCJkZWZhdWx0UHJvcHMiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFDQTs7Ozs7Ozs7SUFFcUJBLHdCOzs7Ozs7Ozs7OzttQ0FTSjtBQUFBLG1CQUNnRSxLQUFLQyxLQURyRTtBQUFBLFVBQ0xDLEVBREssVUFDTEEsRUFESztBQUFBLFVBQ0RDLFlBREMsVUFDREEsWUFEQztBQUFBLFVBQ2FDLGNBRGIsVUFDYUEsY0FEYjtBQUFBLFVBQzZCQyxjQUQ3QixVQUM2QkEsY0FEN0I7QUFBQSxVQUM2Q0MsY0FEN0MsVUFDNkNBLGNBRDdDOztBQUdiOztBQUNBLGFBQU87QUFDTDtBQUNBLDhDQUNLLEtBQUtMLEtBRFY7QUFFRUMsWUFBT0EsRUFBUCxVQUZGO0FBR0VLLGNBQU0sS0FBS04sS0FBTCxDQUFXTSxJQUhuQjtBQUlFQyxrQkFBVUosY0FKWjtBQUtFRSxxQ0FDS0EsY0FETDtBQUVFRSxvQkFBVUYsZUFBZUY7QUFGM0I7QUFMRixTQUZLO0FBWUw7QUFDQSw4Q0FDSyxLQUFLSCxLQURWO0FBRUVDLFlBQU9BLEVBQVAsV0FGRjtBQUdFSyxjQUFNLEtBQUtOLEtBQUwsQ0FBV00sSUFIbkI7QUFJRUMsa0JBQVVMLFlBSlo7QUFLRU0sbUJBQVdKLGNBTGI7QUFNRUssa0JBQVUsS0FOWjtBQU9FSixxQ0FDS0EsY0FETDtBQUVFRSxvQkFBVUYsZUFBZUgsWUFGM0I7QUFHRU0scUJBQVdILGVBQWVEO0FBSDVCO0FBUEYsU0FiSyxDQUFQO0FBMkJEOzs7Ozs7QUF4Q2tCTCx3QixDQUNaVyxTLEdBQVksMEI7QUFEQVgsd0IsQ0FFWlksWSxnQkFDRix1QkFBaUJBLFk7QUFDcEJULGdCQUFjO0FBQUEsV0FBSyxDQUFDLENBQUQsRUFBSSxDQUFKLEVBQU8sQ0FBUCxFQUFVLEdBQVYsQ0FBTDtBQUFBLEc7QUFDZEMsa0JBQWdCO0FBQUEsV0FBSyxDQUFDLEdBQUQsRUFBTSxHQUFOLEVBQVcsR0FBWCxFQUFnQixHQUFoQixDQUFMO0FBQUEsRztBQUNoQkMsa0JBQWdCO0FBQUEsV0FBSyxDQUFMO0FBQUE7O2tCQU5DTCx3QiIsImZpbGUiOiJqdW5jdGlvbi1zY2F0dGVycGxvdC1sYXllci5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIEBmbG93XG5pbXBvcnQgeyBDb21wb3NpdGVMYXllciwgU2NhdHRlcnBsb3RMYXllciB9IGZyb20gJ2RlY2suZ2wnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBKdW5jdGlvblNjYXR0ZXJwbG90TGF5ZXIgZXh0ZW5kcyBDb21wb3NpdGVMYXllciB7XG4gIHN0YXRpYyBsYXllck5hbWUgPSAnSnVuY3Rpb25TY2F0dGVycGxvdExheWVyJztcbiAgc3RhdGljIGRlZmF1bHRQcm9wcyA9IHtcbiAgICAuLi5TY2F0dGVycGxvdExheWVyLmRlZmF1bHRQcm9wcyxcbiAgICBnZXRGaWxsQ29sb3I6IGQgPT4gWzAsIDAsIDAsIDI1NV0sXG4gICAgZ2V0U3Ryb2tlQ29sb3I6IGQgPT4gWzI1NSwgMjU1LCAyNTUsIDI1NV0sXG4gICAgZ2V0SW5uZXJSYWRpdXM6IGQgPT4gMVxuICB9O1xuXG4gIHJlbmRlckxheWVycygpIHtcbiAgICBjb25zdCB7IGlkLCBnZXRGaWxsQ29sb3IsIGdldFN0cm9rZUNvbG9yLCBnZXRJbm5lclJhZGl1cywgdXBkYXRlVHJpZ2dlcnMgfSA9IHRoaXMucHJvcHM7XG5cbiAgICAvLyBkYXRhIG5lZWRzIHRvIGJlIHBhc3NlZCBleHBsaWNpdGx5IGFmdGVyIGRlY2suZ2wgNS4zXG4gICAgcmV0dXJuIFtcbiAgICAgIC8vIHRoZSBmdWxsIGNpcmNsZXNcbiAgICAgIG5ldyBTY2F0dGVycGxvdExheWVyKHtcbiAgICAgICAgLi4udGhpcy5wcm9wcyxcbiAgICAgICAgaWQ6IGAke2lkfS1mdWxsYCxcbiAgICAgICAgZGF0YTogdGhpcy5wcm9wcy5kYXRhLFxuICAgICAgICBnZXRDb2xvcjogZ2V0U3Ryb2tlQ29sb3IsXG4gICAgICAgIHVwZGF0ZVRyaWdnZXJzOiB7XG4gICAgICAgICAgLi4udXBkYXRlVHJpZ2dlcnMsXG4gICAgICAgICAgZ2V0Q29sb3I6IHVwZGF0ZVRyaWdnZXJzLmdldFN0cm9rZUNvbG9yXG4gICAgICAgIH1cbiAgICAgIH0pLFxuICAgICAgLy8gdGhlIGlubmVyIHBhcnRcbiAgICAgIG5ldyBTY2F0dGVycGxvdExheWVyKHtcbiAgICAgICAgLi4udGhpcy5wcm9wcyxcbiAgICAgICAgaWQ6IGAke2lkfS1pbm5lcmAsXG4gICAgICAgIGRhdGE6IHRoaXMucHJvcHMuZGF0YSxcbiAgICAgICAgZ2V0Q29sb3I6IGdldEZpbGxDb2xvcixcbiAgICAgICAgZ2V0UmFkaXVzOiBnZXRJbm5lclJhZGl1cyxcbiAgICAgICAgcGlja2FibGU6IGZhbHNlLFxuICAgICAgICB1cGRhdGVUcmlnZ2Vyczoge1xuICAgICAgICAgIC4uLnVwZGF0ZVRyaWdnZXJzLFxuICAgICAgICAgIGdldENvbG9yOiB1cGRhdGVUcmlnZ2Vycy5nZXRGaWxsQ29sb3IsXG4gICAgICAgICAgZ2V0UmFkaXVzOiB1cGRhdGVUcmlnZ2Vycy5nZXRJbm5lclJhZGl1c1xuICAgICAgICB9XG4gICAgICB9KVxuICAgIF07XG4gIH1cbn1cbiJdfQ==