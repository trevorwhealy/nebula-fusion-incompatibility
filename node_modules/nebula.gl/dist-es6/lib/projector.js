'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _assert = require('assert');

var _assert2 = _interopRequireDefault(_assert);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// recalculate the deck.gl world center when the viewport moves for some distance
var CHANGE_CENTER_THRESHOLD = 0.03;

var Projector = function () {
  function Projector(viewport) {
    var _this = this;

    _classCallCheck(this, Projector);

    this.coordsToLngLatOffset = function (lngLat) {
      (0, _assert2.default)(Array.isArray(lngLat) && lngLat.length === 2, 'Bad lngLat provided to coordsToLngLatOffset()');

      return [lngLat[0] - _this.lngLat[0], lngLat[1] - _this.lngLat[1]];
    };

    this.setCenterFromViewport(viewport);
  }
  // center point we use for calculations


  _createClass(Projector, [{
    key: 'setCenterFromViewport',
    value: function setCenterFromViewport(_ref) {
      var latitude = _ref.latitude,
          longitude = _ref.longitude;

      this.lngLat = [longitude, latitude];
    }
  }, {
    key: 'shouldChangeCenter',
    value: function shouldChangeCenter(_ref2) {
      var latitude = _ref2.latitude,
          longitude = _ref2.longitude;

      return Math.abs(this.lngLat[1] - latitude) > CHANGE_CENTER_THRESHOLD || Math.abs(this.lngLat[0] - longitude) > CHANGE_CENTER_THRESHOLD;
    }
  }]);

  return Projector;
}();

exports.default = Projector;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9saWIvcHJvamVjdG9yLmpzIl0sIm5hbWVzIjpbIkNIQU5HRV9DRU5URVJfVEhSRVNIT0xEIiwiUHJvamVjdG9yIiwidmlld3BvcnQiLCJjb29yZHNUb0xuZ0xhdE9mZnNldCIsImxuZ0xhdCIsIkFycmF5IiwiaXNBcnJheSIsImxlbmd0aCIsInNldENlbnRlckZyb21WaWV3cG9ydCIsImxhdGl0dWRlIiwibG9uZ2l0dWRlIiwiTWF0aCIsImFicyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFDQTs7Ozs7Ozs7QUFHQTtBQUNBLElBQU1BLDBCQUEwQixJQUFoQzs7SUFFcUJDLFM7QUFJbkIscUJBQVlDLFFBQVosRUFBZ0M7QUFBQTs7QUFBQTs7QUFBQSxTQVFoQ0Msb0JBUmdDLEdBUVQsVUFBQ0MsTUFBRCxFQUFnRDtBQUNyRSw0QkFDRUMsTUFBTUMsT0FBTixDQUFjRixNQUFkLEtBQXlCQSxPQUFPRyxNQUFQLEtBQWtCLENBRDdDLEVBRUUsK0NBRkY7O0FBS0EsYUFBTyxDQUFDSCxPQUFPLENBQVAsSUFBWSxNQUFLQSxNQUFMLENBQVksQ0FBWixDQUFiLEVBQTZCQSxPQUFPLENBQVAsSUFBWSxNQUFLQSxNQUFMLENBQVksQ0FBWixDQUF6QyxDQUFQO0FBQ0QsS0FmK0I7O0FBQzlCLFNBQUtJLHFCQUFMLENBQTJCTixRQUEzQjtBQUNEO0FBTEQ7Ozs7O2dEQU95RDtBQUFBLFVBQWpDTyxRQUFpQyxRQUFqQ0EsUUFBaUM7QUFBQSxVQUF2QkMsU0FBdUIsUUFBdkJBLFNBQXVCOztBQUN2RCxXQUFLTixNQUFMLEdBQWMsQ0FBQ00sU0FBRCxFQUFZRCxRQUFaLENBQWQ7QUFDRDs7OzhDQVc4RDtBQUFBLFVBQTFDQSxRQUEwQyxTQUExQ0EsUUFBMEM7QUFBQSxVQUFoQ0MsU0FBZ0MsU0FBaENBLFNBQWdDOztBQUM3RCxhQUNFQyxLQUFLQyxHQUFMLENBQVMsS0FBS1IsTUFBTCxDQUFZLENBQVosSUFBaUJLLFFBQTFCLElBQXNDVCx1QkFBdEMsSUFDQVcsS0FBS0MsR0FBTCxDQUFTLEtBQUtSLE1BQUwsQ0FBWSxDQUFaLElBQWlCTSxTQUExQixJQUF1Q1YsdUJBRnpDO0FBSUQ7Ozs7OztrQkExQmtCQyxTIiwiZmlsZSI6InByb2plY3Rvci5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIEBmbG93XG5pbXBvcnQgYXNzZXJ0IGZyb20gJ2Fzc2VydCc7XG5pbXBvcnQgdHlwZSB7IFZpZXdwb3J0IH0gZnJvbSAnLi4vdHlwZXMnO1xuXG4vLyByZWNhbGN1bGF0ZSB0aGUgZGVjay5nbCB3b3JsZCBjZW50ZXIgd2hlbiB0aGUgdmlld3BvcnQgbW92ZXMgZm9yIHNvbWUgZGlzdGFuY2VcbmNvbnN0IENIQU5HRV9DRU5URVJfVEhSRVNIT0xEID0gMC4wMztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUHJvamVjdG9yIHtcbiAgLy8gY2VudGVyIHBvaW50IHdlIHVzZSBmb3IgY2FsY3VsYXRpb25zXG4gIGxuZ0xhdDogW251bWJlciwgbnVtYmVyXTtcblxuICBjb25zdHJ1Y3Rvcih2aWV3cG9ydDogVmlld3BvcnQpIHtcbiAgICB0aGlzLnNldENlbnRlckZyb21WaWV3cG9ydCh2aWV3cG9ydCk7XG4gIH1cblxuICBzZXRDZW50ZXJGcm9tVmlld3BvcnQoeyBsYXRpdHVkZSwgbG9uZ2l0dWRlIH06IFZpZXdwb3J0KSB7XG4gICAgdGhpcy5sbmdMYXQgPSBbbG9uZ2l0dWRlLCBsYXRpdHVkZV07XG4gIH1cblxuICBjb29yZHNUb0xuZ0xhdE9mZnNldCA9IChsbmdMYXQ6IFtudW1iZXIsIG51bWJlcl0pOiBbbnVtYmVyLCBudW1iZXJdID0+IHtcbiAgICBhc3NlcnQoXG4gICAgICBBcnJheS5pc0FycmF5KGxuZ0xhdCkgJiYgbG5nTGF0Lmxlbmd0aCA9PT0gMixcbiAgICAgICdCYWQgbG5nTGF0IHByb3ZpZGVkIHRvIGNvb3Jkc1RvTG5nTGF0T2Zmc2V0KCknXG4gICAgKTtcblxuICAgIHJldHVybiBbbG5nTGF0WzBdIC0gdGhpcy5sbmdMYXRbMF0sIGxuZ0xhdFsxXSAtIHRoaXMubG5nTGF0WzFdXTtcbiAgfTtcblxuICBzaG91bGRDaGFuZ2VDZW50ZXIoeyBsYXRpdHVkZSwgbG9uZ2l0dWRlIH06IFZpZXdwb3J0KTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIChcbiAgICAgIE1hdGguYWJzKHRoaXMubG5nTGF0WzFdIC0gbGF0aXR1ZGUpID4gQ0hBTkdFX0NFTlRFUl9USFJFU0hPTEQgfHxcbiAgICAgIE1hdGguYWJzKHRoaXMubG5nTGF0WzBdIC0gbG9uZ2l0dWRlKSA+IENIQU5HRV9DRU5URVJfVEhSRVNIT0xEXG4gICAgKTtcbiAgfVxufVxuIl19