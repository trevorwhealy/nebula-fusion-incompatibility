"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _react = _interopRequireWildcard(require("react"));

var _propTypes = _interopRequireDefault(require("prop-types"));

var _core = require("@deck.gl/core");

var _extractJsxLayers = _interopRequireDefault(require("./utils/extract-jsx-layers"));

var _inheritsFrom = require("./utils/inherits-from");

var _evaluateChildren = _interopRequireDefault(require("./utils/evaluate-children"));

var _autobind = _interopRequireDefault(require("./utils/autobind"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

function _instanceof(left, right) { if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) { return right[Symbol.hasInstance](left); } else { return left instanceof right; } }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!_instanceof(instance, Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

var propTypes = _core.Deck.getPropTypes(_propTypes.default);

var defaultProps = _core.Deck.defaultProps;

var DeckGL =
/*#__PURE__*/
function (_React$PureComponent) {
  _inherits(DeckGL, _React$PureComponent);

  function DeckGL(props) {
    var _this;

    _classCallCheck(this, DeckGL);

    _this = _possibleConstructorReturn(this, (DeckGL.__proto__ || Object.getPrototypeOf(DeckGL)).call(this, props));
    _this.state = {
      width: 0,
      height: 0,
      viewState: props.initialViewState
    };
    _this.children = [];
    (0, _autobind.default)(_assertThisInitialized(_this));
    return _this;
  }

  _createClass(DeckGL, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      this.deck = new _core.Deck(Object.assign({}, this.props, {
        initialViewState: null,
        canvas: this.deckCanvas,
        viewState: this._getViewState(this.props),
        // Note: If Deck event handling change size or view state, it calls onResize to update
        onViewStateChange: this._onViewStateChange,
        onResize: this._onResize
      }));
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      this.deck.finalize();
    } // Public API

  }, {
    key: "pickObject",
    value: function pickObject(_ref) {
      var x = _ref.x,
          y = _ref.y,
          _ref$radius = _ref.radius,
          radius = _ref$radius === void 0 ? 0 : _ref$radius,
          _ref$layerIds = _ref.layerIds,
          layerIds = _ref$layerIds === void 0 ? null : _ref$layerIds;
      return this.deck.pickObject({
        x: x,
        y: y,
        radius: radius,
        layerIds: layerIds
      });
    }
  }, {
    key: "pickMultipleObjects",
    value: function pickMultipleObjects(_ref2) {
      var x = _ref2.x,
          y = _ref2.y,
          _ref2$radius = _ref2.radius,
          radius = _ref2$radius === void 0 ? 0 : _ref2$radius,
          _ref2$layerIds = _ref2.layerIds,
          layerIds = _ref2$layerIds === void 0 ? null : _ref2$layerIds,
          _ref2$depth = _ref2.depth,
          depth = _ref2$depth === void 0 ? 10 : _ref2$depth;
      return this.deck.pickMultipleObjects({
        x: x,
        y: y,
        radius: radius,
        layerIds: layerIds,
        depth: depth
      });
    }
  }, {
    key: "pickObjects",
    value: function pickObjects(_ref3) {
      var x = _ref3.x,
          y = _ref3.y,
          _ref3$width = _ref3.width,
          width = _ref3$width === void 0 ? 1 : _ref3$width,
          _ref3$height = _ref3.height,
          height = _ref3$height === void 0 ? 1 : _ref3$height,
          _ref3$layerIds = _ref3.layerIds,
          layerIds = _ref3$layerIds === void 0 ? null : _ref3$layerIds;
      return this.deck.pickObjects({
        x: x,
        y: y,
        width: width,
        height: height,
        layerIds: layerIds
      });
    }
  }, {
    key: "queryObject",
    value: function queryObject(opts) {
      _core.log.removed('queryObject', 'pickObject')();
    }
  }, {
    key: "queryVisibleObjects",
    value: function queryVisibleObjects(opts) {
      _core.log.removed('queryVisibleObjects', 'pickObjects')();
    } // Callbacks
    // Forward callback and then call forceUpdate to guarantee that sub components update

  }, {
    key: "_onResize",
    value: function _onResize(params) {
      this.setState(params);
      this.props.onResize(params);
    } // Forward callback and then call forceUpdate to guarantee that sub components update

  }, {
    key: "_onViewStateChange",
    value: function _onViewStateChange(params) {
      // Let app know that view state is changing, and give it a chance to change it
      var viewState = this.props.onViewStateChange(params) || params.viewState; // If initialViewState was set on creation, auto track position

      if (this.state.viewState) {
        this.setState({
          viewState: Object.assign({}, this.state.viewState, _defineProperty({}, params.viewId, viewState))
        });
      }
    } // Private Helpers
    // 1. Extract any JSX layers from the react children
    // 2. Handle any backwards compatiblity props for React layer
    // Needs to be called both from initial mount, and when new props arrive

  }, {
    key: "_updateFromProps",
    value: function _updateFromProps(nextProps) {
      if (!this.deck) {
        return;
      }

      if (nextProps.viewports || nextProps.viewport) {
        _core.log.removed('DeckGL.viewport(s)', 'DeckGL.views')();
      } // extract any deck.gl layers masquerading as react elements from props.children


      var _extractJSXLayers = (0, _extractJsxLayers.default)(nextProps),
          layers = _extractJSXLayers.layers,
          views = _extractJSXLayers.views,
          children = _extractJSXLayers.children;

      this.deck.setProps(Object.assign({}, nextProps, {
        onViewStateChange: this._onViewStateChange,
        onResize: this._onResize,
        viewState: this._getViewState(nextProps),
        layers: layers,
        views: views
      }));
      this.children = children;
    } // Supports old "geospatial view state as separate props" style (React only!)

  }, {
    key: "_getViewState",
    value: function _getViewState(props) {
      if (!props.viewState && 'latitude' in props && 'longitude' in props && 'zoom' in props) {
        if ('maxZoom' in props || 'minZoom' in props) {
          _core.log.removed('maxZoom/minZoom', 'viewState');
        }

        var latitude = props.latitude,
            longitude = props.longitude,
            zoom = props.zoom,
            _props$pitch = props.pitch,
            pitch = _props$pitch === void 0 ? 0 : _props$pitch,
            _props$bearing = props.bearing,
            bearing = _props$bearing === void 0 ? 0 : _props$bearing;
        return {
          latitude: latitude,
          longitude: longitude,
          zoom: zoom,
          pitch: pitch,
          bearing: bearing
        };
      }

      return props.viewState || this.state.viewState;
    } // Iterate over views and reposition children associated with views
    // TODO - Can we supply a similar function for the non-React case?

  }, {
    key: "_positionChildrenUnderViews",
    value: function _positionChildrenUnderViews(children) {
      var _ref4 = this.deck || {},
          viewManager = _ref4.viewManager;

      if (!viewManager || !viewManager.views.length) {
        return [];
      }

      var defaultViewId = viewManager.views[0].id;
      return children.map(function (child, i) {
        if (child.props.viewportId) {
          _core.log.removed('viewportId', '<View>')();
        }

        if (child.props.viewId) {
          _core.log.removed('viewId', '<View>')();
        } // Unless child is a View, position / render as part of the default view


        var viewId = defaultViewId;
        var viewChildren = child;

        if ((0, _inheritsFrom.inheritsFrom)(child.type, _core.View)) {
          viewId = child.props.id || defaultViewId;
          viewChildren = child.props.children;
        }

        var viewport = viewManager.getViewport(viewId);
        var viewState = viewManager.getViewState(viewId); // Drop (auto-hide) elements with viewId that are not matched by any current view

        if (!viewport) {
          return null;
        } // Resolve potentially relative dimensions using the deck.gl container size


        var x = viewport.x,
            y = viewport.y,
            width = viewport.width,
            height = viewport.height;
        viewChildren = (0, _evaluateChildren.default)(viewChildren, {
          x: x,
          y: y,
          width: width,
          height: height,
          viewport: viewport,
          viewState: viewState
        });
        var style = {
          position: 'absolute',
          left: x,
          top: y,
          width: width,
          height: height
        };
        var key = "view-child-".concat(viewId, "-").concat(i);
        return (0, _react.createElement)('div', {
          key: key,
          id: key,
          style: style
        }, viewChildren);
      });
    }
  }, {
    key: "render",
    value: function render() {
      var _this2 = this;

      this._updateFromProps(this.props); // Render the background elements (typically react-map-gl instances)
      // using the view descriptors


      var children = this._positionChildrenUnderViews(this.children); // TODO - this styling is enforced for correct positioning with children
      // It can override the styling set by `Deck`, this should be consolidated.
      // Note that width and height are handled by deck.gl


      var style = Object.assign({}, {
        position: 'absolute',
        left: 0,
        top: 0
      }, this.props.style);
      var canvas = (0, _react.createElement)('canvas', {
        ref: function ref(c) {
          return _this2.deckCanvas = c;
        },
        key: 'deck-canvas',
        id: this.props.id,
        style: style
      }); // Render deck.gl as last child

      children.push(canvas);
      return (0, _react.createElement)('div', {
        id: 'deckgl-wrapper'
      }, children);
    }
  }]);

  return DeckGL;
}(_react.default.PureComponent);

exports.default = DeckGL;
DeckGL.propTypes = propTypes;
DeckGL.defaultProps = defaultProps;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9kZWNrZ2wuanMiXSwibmFtZXMiOlsicHJvcFR5cGVzIiwiRGVjayIsImdldFByb3BUeXBlcyIsIlByb3BUeXBlcyIsImRlZmF1bHRQcm9wcyIsIkRlY2tHTCIsInByb3BzIiwic3RhdGUiLCJ3aWR0aCIsImhlaWdodCIsInZpZXdTdGF0ZSIsImluaXRpYWxWaWV3U3RhdGUiLCJjaGlsZHJlbiIsImRlY2siLCJPYmplY3QiLCJhc3NpZ24iLCJjYW52YXMiLCJkZWNrQ2FudmFzIiwiX2dldFZpZXdTdGF0ZSIsIm9uVmlld1N0YXRlQ2hhbmdlIiwiX29uVmlld1N0YXRlQ2hhbmdlIiwib25SZXNpemUiLCJfb25SZXNpemUiLCJmaW5hbGl6ZSIsIngiLCJ5IiwicmFkaXVzIiwibGF5ZXJJZHMiLCJwaWNrT2JqZWN0IiwiZGVwdGgiLCJwaWNrTXVsdGlwbGVPYmplY3RzIiwicGlja09iamVjdHMiLCJvcHRzIiwibG9nIiwicmVtb3ZlZCIsInBhcmFtcyIsInNldFN0YXRlIiwidmlld0lkIiwibmV4dFByb3BzIiwidmlld3BvcnRzIiwidmlld3BvcnQiLCJsYXllcnMiLCJ2aWV3cyIsInNldFByb3BzIiwibGF0aXR1ZGUiLCJsb25naXR1ZGUiLCJ6b29tIiwicGl0Y2giLCJiZWFyaW5nIiwidmlld01hbmFnZXIiLCJsZW5ndGgiLCJkZWZhdWx0Vmlld0lkIiwiaWQiLCJtYXAiLCJjaGlsZCIsImkiLCJ2aWV3cG9ydElkIiwidmlld0NoaWxkcmVuIiwidHlwZSIsIlZpZXciLCJnZXRWaWV3cG9ydCIsImdldFZpZXdTdGF0ZSIsInN0eWxlIiwicG9zaXRpb24iLCJsZWZ0IiwidG9wIiwia2V5IiwiX3VwZGF0ZUZyb21Qcm9wcyIsIl9wb3NpdGlvbkNoaWxkcmVuVW5kZXJWaWV3cyIsInJlZiIsImMiLCJwdXNoIiwiUmVhY3QiLCJQdXJlQ29tcG9uZW50Il0sIm1hcHBpbmdzIjoiOzs7Ozs7O0FBb0JBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNB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cHlyaWdodCAoYykgMjAxNSAtIDIwMTcgVWJlciBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4vLyBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4vLyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4vLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4vLyBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuLy8gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuLy8gVEhFIFNPRlRXQVJFLlxuXG5pbXBvcnQgUmVhY3QsIHtjcmVhdGVFbGVtZW50fSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IHtEZWNrLCBWaWV3LCBsb2d9IGZyb20gJ0BkZWNrLmdsL2NvcmUnO1xuaW1wb3J0IGV4dHJhY3RKU1hMYXllcnMgZnJvbSAnLi91dGlscy9leHRyYWN0LWpzeC1sYXllcnMnO1xuaW1wb3J0IHtpbmhlcml0c0Zyb219IGZyb20gJy4vdXRpbHMvaW5oZXJpdHMtZnJvbSc7XG5pbXBvcnQgZXZhbHVhdGVDaGlsZHJlbiBmcm9tICcuL3V0aWxzL2V2YWx1YXRlLWNoaWxkcmVuJztcbmltcG9ydCBhdXRvYmluZCBmcm9tICcuL3V0aWxzL2F1dG9iaW5kJztcblxuY29uc3QgcHJvcFR5cGVzID0gRGVjay5nZXRQcm9wVHlwZXMoUHJvcFR5cGVzKTtcblxuY29uc3QgZGVmYXVsdFByb3BzID0gRGVjay5kZWZhdWx0UHJvcHM7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIERlY2tHTCBleHRlbmRzIFJlYWN0LlB1cmVDb21wb25lbnQge1xuICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgIHN1cGVyKHByb3BzKTtcbiAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgd2lkdGg6IDAsXG4gICAgICBoZWlnaHQ6IDAsXG4gICAgICB2aWV3U3RhdGU6IHByb3BzLmluaXRpYWxWaWV3U3RhdGVcbiAgICB9O1xuICAgIHRoaXMuY2hpbGRyZW4gPSBbXTtcbiAgICBhdXRvYmluZCh0aGlzKTtcbiAgfVxuXG4gIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgIHRoaXMuZGVjayA9IG5ldyBEZWNrKFxuICAgICAgT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5wcm9wcywge1xuICAgICAgICBpbml0aWFsVmlld1N0YXRlOiBudWxsLFxuICAgICAgICBjYW52YXM6IHRoaXMuZGVja0NhbnZhcyxcbiAgICAgICAgdmlld1N0YXRlOiB0aGlzLl9nZXRWaWV3U3RhdGUodGhpcy5wcm9wcyksXG4gICAgICAgIC8vIE5vdGU6IElmIERlY2sgZXZlbnQgaGFuZGxpbmcgY2hhbmdlIHNpemUgb3IgdmlldyBzdGF0ZSwgaXQgY2FsbHMgb25SZXNpemUgdG8gdXBkYXRlXG4gICAgICAgIG9uVmlld1N0YXRlQ2hhbmdlOiB0aGlzLl9vblZpZXdTdGF0ZUNoYW5nZSxcbiAgICAgICAgb25SZXNpemU6IHRoaXMuX29uUmVzaXplXG4gICAgICB9KVxuICAgICk7XG4gIH1cblxuICBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICB0aGlzLmRlY2suZmluYWxpemUoKTtcbiAgfVxuXG4gIC8vIFB1YmxpYyBBUElcblxuICBwaWNrT2JqZWN0KHt4LCB5LCByYWRpdXMgPSAwLCBsYXllcklkcyA9IG51bGx9KSB7XG4gICAgcmV0dXJuIHRoaXMuZGVjay5waWNrT2JqZWN0KHt4LCB5LCByYWRpdXMsIGxheWVySWRzfSk7XG4gIH1cblxuICBwaWNrTXVsdGlwbGVPYmplY3RzKHt4LCB5LCByYWRpdXMgPSAwLCBsYXllcklkcyA9IG51bGwsIGRlcHRoID0gMTB9KSB7XG4gICAgcmV0dXJuIHRoaXMuZGVjay5waWNrTXVsdGlwbGVPYmplY3RzKHt4LCB5LCByYWRpdXMsIGxheWVySWRzLCBkZXB0aH0pO1xuICB9XG5cbiAgcGlja09iamVjdHMoe3gsIHksIHdpZHRoID0gMSwgaGVpZ2h0ID0gMSwgbGF5ZXJJZHMgPSBudWxsfSkge1xuICAgIHJldHVybiB0aGlzLmRlY2sucGlja09iamVjdHMoe3gsIHksIHdpZHRoLCBoZWlnaHQsIGxheWVySWRzfSk7XG4gIH1cblxuICBxdWVyeU9iamVjdChvcHRzKSB7XG4gICAgbG9nLnJlbW92ZWQoJ3F1ZXJ5T2JqZWN0JywgJ3BpY2tPYmplY3QnKSgpO1xuICB9XG5cbiAgcXVlcnlWaXNpYmxlT2JqZWN0cyhvcHRzKSB7XG4gICAgbG9nLnJlbW92ZWQoJ3F1ZXJ5VmlzaWJsZU9iamVjdHMnLCAncGlja09iamVjdHMnKSgpO1xuICB9XG5cbiAgLy8gQ2FsbGJhY2tzXG5cbiAgLy8gRm9yd2FyZCBjYWxsYmFjayBhbmQgdGhlbiBjYWxsIGZvcmNlVXBkYXRlIHRvIGd1YXJhbnRlZSB0aGF0IHN1YiBjb21wb25lbnRzIHVwZGF0ZVxuICBfb25SZXNpemUocGFyYW1zKSB7XG4gICAgdGhpcy5zZXRTdGF0ZShwYXJhbXMpO1xuICAgIHRoaXMucHJvcHMub25SZXNpemUocGFyYW1zKTtcbiAgfVxuXG4gIC8vIEZvcndhcmQgY2FsbGJhY2sgYW5kIHRoZW4gY2FsbCBmb3JjZVVwZGF0ZSB0byBndWFyYW50ZWUgdGhhdCBzdWIgY29tcG9uZW50cyB1cGRhdGVcbiAgX29uVmlld1N0YXRlQ2hhbmdlKHBhcmFtcykge1xuICAgIC8vIExldCBhcHAga25vdyB0aGF0IHZpZXcgc3RhdGUgaXMgY2hhbmdpbmcsIGFuZCBnaXZlIGl0IGEgY2hhbmNlIHRvIGNoYW5nZSBpdFxuICAgIGNvbnN0IHZpZXdTdGF0ZSA9IHRoaXMucHJvcHMub25WaWV3U3RhdGVDaGFuZ2UocGFyYW1zKSB8fCBwYXJhbXMudmlld1N0YXRlO1xuXG4gICAgLy8gSWYgaW5pdGlhbFZpZXdTdGF0ZSB3YXMgc2V0IG9uIGNyZWF0aW9uLCBhdXRvIHRyYWNrIHBvc2l0aW9uXG4gICAgaWYgKHRoaXMuc3RhdGUudmlld1N0YXRlKSB7XG4gICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgdmlld1N0YXRlOiBPYmplY3QuYXNzaWduKHt9LCB0aGlzLnN0YXRlLnZpZXdTdGF0ZSwge1xuICAgICAgICAgIFtwYXJhbXMudmlld0lkXTogdmlld1N0YXRlXG4gICAgICAgIH0pXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICAvLyBQcml2YXRlIEhlbHBlcnNcblxuICAvLyAxLiBFeHRyYWN0IGFueSBKU1ggbGF5ZXJzIGZyb20gdGhlIHJlYWN0IGNoaWxkcmVuXG4gIC8vIDIuIEhhbmRsZSBhbnkgYmFja3dhcmRzIGNvbXBhdGlibGl0eSBwcm9wcyBmb3IgUmVhY3QgbGF5ZXJcbiAgLy8gTmVlZHMgdG8gYmUgY2FsbGVkIGJvdGggZnJvbSBpbml0aWFsIG1vdW50LCBhbmQgd2hlbiBuZXcgcHJvcHMgYXJyaXZlXG4gIF91cGRhdGVGcm9tUHJvcHMobmV4dFByb3BzKSB7XG4gICAgaWYgKCF0aGlzLmRlY2spIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAobmV4dFByb3BzLnZpZXdwb3J0cyB8fCBuZXh0UHJvcHMudmlld3BvcnQpIHtcbiAgICAgIGxvZy5yZW1vdmVkKCdEZWNrR0wudmlld3BvcnQocyknLCAnRGVja0dMLnZpZXdzJykoKTtcbiAgICB9XG5cbiAgICAvLyBleHRyYWN0IGFueSBkZWNrLmdsIGxheWVycyBtYXNxdWVyYWRpbmcgYXMgcmVhY3QgZWxlbWVudHMgZnJvbSBwcm9wcy5jaGlsZHJlblxuICAgIGNvbnN0IHtsYXllcnMsIHZpZXdzLCBjaGlsZHJlbn0gPSBleHRyYWN0SlNYTGF5ZXJzKG5leHRQcm9wcyk7XG5cbiAgICB0aGlzLmRlY2suc2V0UHJvcHMoXG4gICAgICBPYmplY3QuYXNzaWduKHt9LCBuZXh0UHJvcHMsIHtcbiAgICAgICAgb25WaWV3U3RhdGVDaGFuZ2U6IHRoaXMuX29uVmlld1N0YXRlQ2hhbmdlLFxuICAgICAgICBvblJlc2l6ZTogdGhpcy5fb25SZXNpemUsXG4gICAgICAgIHZpZXdTdGF0ZTogdGhpcy5fZ2V0Vmlld1N0YXRlKG5leHRQcm9wcyksXG4gICAgICAgIGxheWVycyxcbiAgICAgICAgdmlld3NcbiAgICAgIH0pXG4gICAgKTtcblxuICAgIHRoaXMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgfVxuXG4gIC8vIFN1cHBvcnRzIG9sZCBcImdlb3NwYXRpYWwgdmlldyBzdGF0ZSBhcyBzZXBhcmF0ZSBwcm9wc1wiIHN0eWxlIChSZWFjdCBvbmx5ISlcbiAgX2dldFZpZXdTdGF0ZShwcm9wcykge1xuICAgIGlmICghcHJvcHMudmlld1N0YXRlICYmICdsYXRpdHVkZScgaW4gcHJvcHMgJiYgJ2xvbmdpdHVkZScgaW4gcHJvcHMgJiYgJ3pvb20nIGluIHByb3BzKSB7XG4gICAgICBpZiAoJ21heFpvb20nIGluIHByb3BzIHx8ICdtaW5ab29tJyBpbiBwcm9wcykge1xuICAgICAgICBsb2cucmVtb3ZlZCgnbWF4Wm9vbS9taW5ab29tJywgJ3ZpZXdTdGF0ZScpO1xuICAgICAgfVxuICAgICAgY29uc3Qge2xhdGl0dWRlLCBsb25naXR1ZGUsIHpvb20sIHBpdGNoID0gMCwgYmVhcmluZyA9IDB9ID0gcHJvcHM7XG4gICAgICByZXR1cm4ge2xhdGl0dWRlLCBsb25naXR1ZGUsIHpvb20sIHBpdGNoLCBiZWFyaW5nfTtcbiAgICB9XG4gICAgcmV0dXJuIHByb3BzLnZpZXdTdGF0ZSB8fCB0aGlzLnN0YXRlLnZpZXdTdGF0ZTtcbiAgfVxuXG4gIC8vIEl0ZXJhdGUgb3ZlciB2aWV3cyBhbmQgcmVwb3NpdGlvbiBjaGlsZHJlbiBhc3NvY2lhdGVkIHdpdGggdmlld3NcbiAgLy8gVE9ETyAtIENhbiB3ZSBzdXBwbHkgYSBzaW1pbGFyIGZ1bmN0aW9uIGZvciB0aGUgbm9uLVJlYWN0IGNhc2U/XG4gIF9wb3NpdGlvbkNoaWxkcmVuVW5kZXJWaWV3cyhjaGlsZHJlbikge1xuICAgIGNvbnN0IHt2aWV3TWFuYWdlcn0gPSB0aGlzLmRlY2sgfHwge307XG5cbiAgICBpZiAoIXZpZXdNYW5hZ2VyIHx8ICF2aWV3TWFuYWdlci52aWV3cy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG5cbiAgICBjb25zdCBkZWZhdWx0Vmlld0lkID0gdmlld01hbmFnZXIudmlld3NbMF0uaWQ7XG5cbiAgICByZXR1cm4gY2hpbGRyZW4ubWFwKChjaGlsZCwgaSkgPT4ge1xuICAgICAgaWYgKGNoaWxkLnByb3BzLnZpZXdwb3J0SWQpIHtcbiAgICAgICAgbG9nLnJlbW92ZWQoJ3ZpZXdwb3J0SWQnLCAnPFZpZXc+JykoKTtcbiAgICAgIH1cbiAgICAgIGlmIChjaGlsZC5wcm9wcy52aWV3SWQpIHtcbiAgICAgICAgbG9nLnJlbW92ZWQoJ3ZpZXdJZCcsICc8Vmlldz4nKSgpO1xuICAgICAgfVxuXG4gICAgICAvLyBVbmxlc3MgY2hpbGQgaXMgYSBWaWV3LCBwb3NpdGlvbiAvIHJlbmRlciBhcyBwYXJ0IG9mIHRoZSBkZWZhdWx0IHZpZXdcbiAgICAgIGxldCB2aWV3SWQgPSBkZWZhdWx0Vmlld0lkO1xuICAgICAgbGV0IHZpZXdDaGlsZHJlbiA9IGNoaWxkO1xuICAgICAgaWYgKGluaGVyaXRzRnJvbShjaGlsZC50eXBlLCBWaWV3KSkge1xuICAgICAgICB2aWV3SWQgPSBjaGlsZC5wcm9wcy5pZCB8fCBkZWZhdWx0Vmlld0lkO1xuICAgICAgICB2aWV3Q2hpbGRyZW4gPSBjaGlsZC5wcm9wcy5jaGlsZHJlbjtcbiAgICAgIH1cblxuICAgICAgY29uc3Qgdmlld3BvcnQgPSB2aWV3TWFuYWdlci5nZXRWaWV3cG9ydCh2aWV3SWQpO1xuICAgICAgY29uc3Qgdmlld1N0YXRlID0gdmlld01hbmFnZXIuZ2V0Vmlld1N0YXRlKHZpZXdJZCk7XG5cbiAgICAgIC8vIERyb3AgKGF1dG8taGlkZSkgZWxlbWVudHMgd2l0aCB2aWV3SWQgdGhhdCBhcmUgbm90IG1hdGNoZWQgYnkgYW55IGN1cnJlbnQgdmlld1xuICAgICAgaWYgKCF2aWV3cG9ydCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgLy8gUmVzb2x2ZSBwb3RlbnRpYWxseSByZWxhdGl2ZSBkaW1lbnNpb25zIHVzaW5nIHRoZSBkZWNrLmdsIGNvbnRhaW5lciBzaXplXG4gICAgICBjb25zdCB7eCwgeSwgd2lkdGgsIGhlaWdodH0gPSB2aWV3cG9ydDtcblxuICAgICAgdmlld0NoaWxkcmVuID0gZXZhbHVhdGVDaGlsZHJlbih2aWV3Q2hpbGRyZW4sIHtcbiAgICAgICAgeCxcbiAgICAgICAgeSxcbiAgICAgICAgd2lkdGgsXG4gICAgICAgIGhlaWdodCxcbiAgICAgICAgdmlld3BvcnQsXG4gICAgICAgIHZpZXdTdGF0ZVxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHN0eWxlID0ge3Bvc2l0aW9uOiAnYWJzb2x1dGUnLCBsZWZ0OiB4LCB0b3A6IHksIHdpZHRoLCBoZWlnaHR9O1xuICAgICAgY29uc3Qga2V5ID0gYHZpZXctY2hpbGQtJHt2aWV3SWR9LSR7aX1gO1xuICAgICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQoJ2RpdicsIHtrZXksIGlkOiBrZXksIHN0eWxlfSwgdmlld0NoaWxkcmVuKTtcbiAgICB9KTtcbiAgfVxuXG4gIHJlbmRlcigpIHtcbiAgICB0aGlzLl91cGRhdGVGcm9tUHJvcHModGhpcy5wcm9wcyk7XG5cbiAgICAvLyBSZW5kZXIgdGhlIGJhY2tncm91bmQgZWxlbWVudHMgKHR5cGljYWxseSByZWFjdC1tYXAtZ2wgaW5zdGFuY2VzKVxuICAgIC8vIHVzaW5nIHRoZSB2aWV3IGRlc2NyaXB0b3JzXG4gICAgY29uc3QgY2hpbGRyZW4gPSB0aGlzLl9wb3NpdGlvbkNoaWxkcmVuVW5kZXJWaWV3cyh0aGlzLmNoaWxkcmVuKTtcblxuICAgIC8vIFRPRE8gLSB0aGlzIHN0eWxpbmcgaXMgZW5mb3JjZWQgZm9yIGNvcnJlY3QgcG9zaXRpb25pbmcgd2l0aCBjaGlsZHJlblxuICAgIC8vIEl0IGNhbiBvdmVycmlkZSB0aGUgc3R5bGluZyBzZXQgYnkgYERlY2tgLCB0aGlzIHNob3VsZCBiZSBjb25zb2xpZGF0ZWQuXG4gICAgLy8gTm90ZSB0aGF0IHdpZHRoIGFuZCBoZWlnaHQgYXJlIGhhbmRsZWQgYnkgZGVjay5nbFxuICAgIGNvbnN0IHN0eWxlID0gT2JqZWN0LmFzc2lnbih7fSwge3Bvc2l0aW9uOiAnYWJzb2x1dGUnLCBsZWZ0OiAwLCB0b3A6IDB9LCB0aGlzLnByb3BzLnN0eWxlKTtcblxuICAgIGNvbnN0IGNhbnZhcyA9IGNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycsIHtcbiAgICAgIHJlZjogYyA9PiAodGhpcy5kZWNrQ2FudmFzID0gYyksXG4gICAgICBrZXk6ICdkZWNrLWNhbnZhcycsXG4gICAgICBpZDogdGhpcy5wcm9wcy5pZCxcbiAgICAgIHN0eWxlXG4gICAgfSk7XG5cbiAgICAvLyBSZW5kZXIgZGVjay5nbCBhcyBsYXN0IGNoaWxkXG4gICAgY2hpbGRyZW4ucHVzaChjYW52YXMpO1xuXG4gICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQoJ2RpdicsIHtpZDogJ2RlY2tnbC13cmFwcGVyJ30sIGNoaWxkcmVuKTtcbiAgfVxufVxuXG5EZWNrR0wucHJvcFR5cGVzID0gcHJvcFR5cGVzO1xuRGVja0dMLmRlZmF1bHRQcm9wcyA9IGRlZmF1bHRQcm9wcztcbiJdfQ==