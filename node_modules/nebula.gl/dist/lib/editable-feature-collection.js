'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var EditableFeatureCollection = exports.EditableFeatureCollection = function () {
  function EditableFeatureCollection(featureCollection) {
    _classCallCheck(this, EditableFeatureCollection);

    this.featureCollection = featureCollection;
  }

  _createClass(EditableFeatureCollection, [{
    key: 'getObject',
    value: function getObject() {
      return this.featureCollection;
    }

    /**
     * Replaces the position deeply nested withing the given feature's geometry.
     * Works with Point, MultiPoint, LineString, MultiLineString, Polygon, and MultiPolygon.
     *
     * @param featureIndex The index of the feature to update
     * @param positionIndexes An array containing the indexes of the position to replace
     * @param updatedPosition The updated position to place in the result (i.e. [lng, lat])
     *
     * @returns A new `EditableFeatureCollection` with the given position replaced. Does not modify this `EditableFeatureCollection`.
     */

  }, {
    key: 'replacePosition',
    value: function replacePosition(featureIndex, positionIndexes, updatedPosition) {
      var featureToUpdate = this.featureCollection.features[featureIndex];
      var isPolygonal = featureToUpdate.geometry.type === 'Polygon' || featureToUpdate.geometry.type === 'MultiPolygon';

      var updatedCoordinates = immutablyReplacePosition(featureToUpdate.geometry.coordinates, positionIndexes, updatedPosition, isPolygonal);

      var updatedFeature = _extends({}, featureToUpdate, {
        geometry: _extends({}, featureToUpdate.geometry, {
          coordinates: updatedCoordinates
        })
      });

      // Immutably replace the feature being edited in the featureCollection
      var updatedFeatureCollection = _extends({}, this.featureCollection, {
        features: [].concat(_toConsumableArray(this.featureCollection.features.slice(0, featureIndex)), [updatedFeature], _toConsumableArray(this.featureCollection.features.slice(featureIndex + 1)))
      });

      return new EditableFeatureCollection(updatedFeatureCollection);
    }

    /**
     * Removes a position deeply nested in a GeoJSON geometry coordinates array.
     * Works with MultiPoint, LineString, MultiLineString, Polygon, and MultiPolygon.
     *
     * @param featureIndex The index of the feature to update
     * @param positionIndexes An array containing the indexes of the postion to remove
     *
     * @returns A new `EditableFeatureCollection` with the given coordinate removed. Does not modify this `EditableFeatureCollection`.
     */

  }, {
    key: 'removePosition',
    value: function removePosition(featureIndex, positionIndexes) {
      var featureToUpdate = this.featureCollection.features[featureIndex];
      if (featureToUpdate.geometry.type === 'Point') {
        throw Error('Can\'t remove a position from a Point or there\'d be nothing left');
      }
      if (featureToUpdate.geometry.type === 'MultiPoint' && featureToUpdate.geometry.coordinates.length < 2) {
        throw Error('Can\'t remove the last point of a MultiPoint or there\'d be nothing left');
      }
      var isPolygonal = featureToUpdate.geometry.type === 'Polygon' || featureToUpdate.geometry.type === 'MultiPolygon';

      var updatedCoordinates = immutablyRemovePosition(featureToUpdate.geometry.coordinates, positionIndexes, isPolygonal);

      var updatedGeometry = _extends({}, featureToUpdate.geometry, {
        coordinates: updatedCoordinates
      });

      // Handle cases where geometry type is "downgraded"
      downgradeGeometryIfNecessary(updatedGeometry);

      var updatedFeature = _extends({}, featureToUpdate, {
        geometry: updatedGeometry
      });

      // Immutably replace the feature being edited in the featureCollection
      var updatedFeatureCollection = _extends({}, this.featureCollection, {
        features: [].concat(_toConsumableArray(this.featureCollection.features.slice(0, featureIndex)), [updatedFeature], _toConsumableArray(this.featureCollection.features.slice(featureIndex + 1)))
      });

      return new EditableFeatureCollection(updatedFeatureCollection);
    }

    /**
     * Adds a position deeply nested in a GeoJSON geometry coordinates array.
     * Works with MultiPoint, LineString, MultiLineString, Polygon, and MultiPolygon.
     *
     * @param featureIndex The index of the feature to update
     * @param positionIndexes An array containing the indexes of the postion that will preceed the new position
     * @param positionToAdd The new position to place in the result (i.e. [lng, lat])
     *
     * @returns A new `EditableFeatureCollection` with the given coordinate removed. Does not modify this `EditableFeatureCollection`.
     */

  }, {
    key: 'addPosition',
    value: function addPosition(featureIndex, positionIndexes, positionToAdd) {
      var featureToUpdate = this.featureCollection.features[featureIndex];

      if (featureToUpdate.geometry.type === 'Point') {
        throw new Error('Unable to add a position to a Point feature');
      }

      var isPolygonal = featureToUpdate.geometry.type === 'Polygon' || featureToUpdate.geometry.type === 'MultiPolygon';

      var updatedCoordinates = immutablyAddPosition(featureToUpdate.geometry.coordinates, positionIndexes, positionToAdd, isPolygonal);

      var updatedFeature = _extends({}, featureToUpdate, {
        geometry: _extends({}, featureToUpdate.geometry, {
          coordinates: updatedCoordinates
        })
      });

      // Immutably replace the feature being edited in the featureCollection
      var updatedFeatureCollection = _extends({}, this.featureCollection, {
        features: [].concat(_toConsumableArray(this.featureCollection.features.slice(0, featureIndex)), [updatedFeature], _toConsumableArray(this.featureCollection.features.slice(featureIndex + 1)))
      });

      return new EditableFeatureCollection(updatedFeatureCollection);
    }
  }, {
    key: 'replaceGeometry',
    value: function replaceGeometry(featureIndex, geometry) {
      var updatedFeature = _extends({}, this.featureCollection.features[featureIndex], {
        geometry: geometry
      });
      var updatedFeatureCollection = _extends({}, this.featureCollection, {
        features: [].concat(_toConsumableArray(this.featureCollection.features.slice(0, featureIndex)), [updatedFeature], _toConsumableArray(this.featureCollection.features.slice(featureIndex + 1)))
      });
      return new EditableFeatureCollection(updatedFeatureCollection);
    }
  }, {
    key: 'addFeature',
    value: function addFeature(feature) {
      var updatedFeatureCollection = _extends({}, this.featureCollection, {
        features: [].concat(_toConsumableArray(this.featureCollection.features), [feature])
      });
      return new EditableFeatureCollection(updatedFeatureCollection);
    }

    /**
     * Returns a flat array of positions for the given feature along with their indexes into the feature's geometry's coordinates.
     *
     * @param featureIndex The index of the feature to get edit handles
     */

  }, {
    key: 'getEditHandles',
    value: function getEditHandles(featureIndex) {
      var handles = [];

      var geometry = this.featureCollection.features[featureIndex].geometry;

      switch (geometry.type) {
        case 'Point':
          // positions are not nested
          handles = [{
            position: geometry.coordinates,
            positionIndexes: [],
            featureIndex: featureIndex,
            type: 'existing'
          }];
          break;
        case 'MultiPoint':
        case 'LineString':
          // positions are nested 1 level
          var includeIntermediate = geometry.type !== 'MultiPoint';
          handles = handles.concat(_getEditHandles(geometry.coordinates, [], includeIntermediate, featureIndex));
          break;
        case 'Polygon':
        case 'MultiLineString':
          // positions are nested 2 levels
          for (var a = 0; a < geometry.coordinates.length; a++) {
            handles = handles.concat(_getEditHandles(geometry.coordinates[a], [a], true, featureIndex));
          }
          break;
        case 'MultiPolygon':
          // positions are nested 3 levels
          for (var _a = 0; _a < geometry.coordinates.length; _a++) {
            for (var b = 0; b < geometry.coordinates[_a].length; b++) {
              handles = handles.concat(_getEditHandles(geometry.coordinates[_a][b], [_a, b], true, featureIndex));
            }
          }
          break;
        default:
          throw Error('Unhandled geometry type: ' + geometry.type);
      }

      return handles;
    }
  }]);

  return EditableFeatureCollection;
}();

function immutablyReplacePosition(coordinates, positionIndexes, updatedPosition, isPolygonal) {
  if (!positionIndexes) {
    return coordinates;
  }
  if (positionIndexes.length === 0) {
    return updatedPosition;
  }
  if (positionIndexes.length === 1) {
    var updated = [].concat(_toConsumableArray(coordinates.slice(0, positionIndexes[0])), [updatedPosition], _toConsumableArray(coordinates.slice(positionIndexes[0] + 1)));

    if (isPolygonal && (positionIndexes[0] === 0 || positionIndexes[0] === coordinates.length - 1)) {
      // for polygons, the first point is repeated at the end of the array
      // so, update it on both ends of the array
      updated[0] = updatedPosition;
      updated[coordinates.length - 1] = updatedPosition;
    }
    return updated;
  }

  // recursively update inner array
  return [].concat(_toConsumableArray(coordinates.slice(0, positionIndexes[0])), [immutablyReplacePosition(coordinates[positionIndexes[0]], positionIndexes.slice(1, positionIndexes.length), updatedPosition, isPolygonal)], _toConsumableArray(coordinates.slice(positionIndexes[0] + 1)));
}

function immutablyRemovePosition(coordinates, positionIndexes, isPolygonal) {
  if (!positionIndexes) {
    return coordinates;
  }
  if (positionIndexes.length === 0) {
    throw Error('Must specify the index of the position to remove');
  }
  if (positionIndexes.length === 1) {
    var updated = [].concat(_toConsumableArray(coordinates.slice(0, positionIndexes[0])), _toConsumableArray(coordinates.slice(positionIndexes[0] + 1)));

    if (isPolygonal && (positionIndexes[0] === 0 || positionIndexes[0] === coordinates.length - 1)) {
      // for polygons, the first point is repeated at the end of the array
      // so, if the first/last coordinate is to be removed, coordinates[1] will be the new first/last coordinate
      if (positionIndexes[0] === 0) {
        // change the last to be the same as the first
        updated[updated.length - 1] = updated[0];
      } else if (positionIndexes[0] === coordinates.length - 1) {
        // change the first to be the same as the last
        updated[0] = updated[updated.length - 1];
      }
    }
    return updated;
  }

  // recursively update inner array
  return [].concat(_toConsumableArray(coordinates.slice(0, positionIndexes[0])), [immutablyRemovePosition(coordinates[positionIndexes[0]], positionIndexes.slice(1, positionIndexes.length), isPolygonal)], _toConsumableArray(coordinates.slice(positionIndexes[0] + 1)));
}

function immutablyAddPosition(coordinates, positionIndexes, positionToAdd, isPolygonal) {
  if (!positionIndexes) {
    return coordinates;
  }
  if (positionIndexes.length === 0) {
    throw Error('Must specify the index of the position to remove');
  }
  if (positionIndexes.length === 1) {
    if (isPolygonal && (positionIndexes[0] < 1 || positionIndexes[0] > coordinates.length - 1)) {
      // TODO: test this case
      throw Error('Invalid position index for polygon: ' + positionIndexes[0] + '. Points must be added to a Polygon between the first and last point.');
    }
    var updated = [].concat(_toConsumableArray(coordinates.slice(0, positionIndexes[0])), [positionToAdd], _toConsumableArray(coordinates.slice(positionIndexes[0])));
    return updated;
  }

  // recursively update inner array
  return [].concat(_toConsumableArray(coordinates.slice(0, positionIndexes[0])), [immutablyAddPosition(coordinates[positionIndexes[0]], positionIndexes.slice(1, positionIndexes.length), positionToAdd, isPolygonal)], _toConsumableArray(coordinates.slice(positionIndexes[0] + 1)));
}

function downgradeGeometryIfNecessary(geometry) {
  switch (geometry.type) {
    case 'LineString':
      downgradeLineStringIfNecessary(geometry);
      break;
    case 'Polygon':
      downgradePolygonIfNecessary(geometry);
      break;
    case 'MultiLineString':
      downgradeMultiLineStringIfNecessary(geometry);
      break;
    case 'MultiPolygon':
      downgradeMultiPolygonIfNecessary(geometry);
      break;
    default:
      // Not downgradable
      break;
  }
}

function downgradeLineStringIfNecessary(geometry) {
  if (geometry.coordinates.length === 1) {
    // Only one position left, so convert to a Point
    geometry.type = 'Point';
    geometry.coordinates = geometry.coordinates[0];
  }
}

function downgradePolygonIfNecessary(geometry) {
  var polygon = geometry.coordinates;
  var outerRing = polygon[0];
  // If the outer ring is no longer a polygon, convert the whole thing to a LineString
  if (outerRing.length <= 3) {
    geometry.type = 'LineString';
    geometry.coordinates = outerRing.slice(0, outerRing.length - 1);
    return;
  }

  // If any hole is no longer a polygon, remove the hole entirely
  for (var holeIndex = 1; holeIndex < polygon.length; holeIndex++) {
    if (removeHoleIfNecessary(polygon, holeIndex)) {
      // It was removed, so keep the index the same
      holeIndex--;
    }
  }
}

function downgradeMultiLineStringIfNecessary(geometry) {
  if (geometry.coordinates.length === 1 && geometry.coordinates[0].length === 1) {
    // Only one position left, so convert to a Point
    geometry.type = 'Point';
    geometry.coordinates = geometry.coordinates[0][0];
    return;
  }
  for (var lineStringIndex = 0; lineStringIndex < geometry.coordinates.length; lineStringIndex++) {
    var lineString = geometry.coordinates[lineStringIndex];
    if (lineString.length === 1) {
      // Only a single position left on this LineString, so remove it (can't have Point in MultiLineString)
      geometry.coordinates.splice(lineStringIndex, 1);
      // Keep the index the same
      lineStringIndex--;
    }
  }
}

function downgradeMultiPolygonIfNecessary(geometry) {
  if (geometry.coordinates.length === 1) {
    var outerRing = geometry.coordinates[0][0];
    if (outerRing.length <= 3) {
      geometry.type = 'LineString';
      geometry.coordinates = outerRing.slice(0, outerRing.length - 1);
      return;
    }
  }
  for (var polygonIndex = 0; polygonIndex < geometry.coordinates.length; polygonIndex++) {
    var polygon = geometry.coordinates[polygonIndex];
    var _outerRing = polygon[0];

    // If the outer ring is no longer a polygon, remove the whole polygon
    if (_outerRing.length <= 3) {
      geometry.coordinates.splice(polygonIndex, 1);
      // It was removed, so keep the index the same
      polygonIndex--;
    }

    for (var holeIndex = 1; holeIndex < polygon.length; holeIndex++) {
      if (removeHoleIfNecessary(polygon, holeIndex)) {
        // It was removed, so keep the index the same
        holeIndex--;
      }
    }
  }
}

function removeHoleIfNecessary(polygon, holeIndex) {
  var hole = polygon[holeIndex];
  if (hole.length <= 3) {
    polygon.splice(holeIndex, 1);
    return true;
  }
  return false;
}

function getIntermediatePosition(position1, position2) {
  var intermediatePosition = [];
  for (var dimension = 0; dimension < position1.length; dimension++) {
    intermediatePosition.push((position1[dimension] + position2[dimension]) / 2.0);
  }
  return intermediatePosition;
}

function _getEditHandles(coordinates, positionIndexPrefix, includeIntermediate, featureIndex) {
  var editHandles = [];
  for (var i = 0; i < coordinates.length; i++) {
    var position = coordinates[i];
    editHandles.push({
      position: position,
      positionIndexes: [].concat(_toConsumableArray(positionIndexPrefix), [i]),
      featureIndex: featureIndex,
      type: 'existing'
    });

    if (includeIntermediate && i < coordinates.length - 1) {
      // add intermediate position after every position except the last one
      var nextPosition = coordinates[i + 1];
      editHandles.push({
        position: getIntermediatePosition(position, nextPosition),
        positionIndexes: [].concat(_toConsumableArray(positionIndexPrefix), [i + 1]),
        featureIndex: featureIndex,
        type: 'intermediate'
      });
    }
  }
  return editHandles;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9saWIvZWRpdGFibGUtZmVhdHVyZS1jb2xsZWN0aW9uLmpzIl0sIm5hbWVzIjpbIkVkaXRhYmxlRmVhdHVyZUNvbGxlY3Rpb24iLCJmZWF0dXJlQ29sbGVjdGlvbiIsImZlYXR1cmVJbmRleCIsInBvc2l0aW9uSW5kZXhlcyIsInVwZGF0ZWRQb3NpdGlvbiIsImZlYXR1cmVUb1VwZGF0ZSIsImZlYXR1cmVzIiwiaXNQb2x5Z29uYWwiLCJnZW9tZXRyeSIsInR5cGUiLCJ1cGRhdGVkQ29vcmRpbmF0ZXMiLCJpbW11dGFibHlSZXBsYWNlUG9zaXRpb24iLCJjb29yZGluYXRlcyIsInVwZGF0ZWRGZWF0dXJlIiwidXBkYXRlZEZlYXR1cmVDb2xsZWN0aW9uIiwic2xpY2UiLCJFcnJvciIsImxlbmd0aCIsImltbXV0YWJseVJlbW92ZVBvc2l0aW9uIiwidXBkYXRlZEdlb21ldHJ5IiwiZG93bmdyYWRlR2VvbWV0cnlJZk5lY2Vzc2FyeSIsInBvc2l0aW9uVG9BZGQiLCJpbW11dGFibHlBZGRQb3NpdGlvbiIsImZlYXR1cmUiLCJoYW5kbGVzIiwicG9zaXRpb24iLCJpbmNsdWRlSW50ZXJtZWRpYXRlIiwiY29uY2F0IiwiZ2V0RWRpdEhhbmRsZXMiLCJhIiwiYiIsInVwZGF0ZWQiLCJkb3duZ3JhZGVMaW5lU3RyaW5nSWZOZWNlc3NhcnkiLCJkb3duZ3JhZGVQb2x5Z29uSWZOZWNlc3NhcnkiLCJkb3duZ3JhZGVNdWx0aUxpbmVTdHJpbmdJZk5lY2Vzc2FyeSIsImRvd25ncmFkZU11bHRpUG9seWdvbklmTmVjZXNzYXJ5IiwicG9seWdvbiIsIm91dGVyUmluZyIsImhvbGVJbmRleCIsInJlbW92ZUhvbGVJZk5lY2Vzc2FyeSIsImxpbmVTdHJpbmdJbmRleCIsImxpbmVTdHJpbmciLCJzcGxpY2UiLCJwb2x5Z29uSW5kZXgiLCJob2xlIiwiZ2V0SW50ZXJtZWRpYXRlUG9zaXRpb24iLCJwb3NpdGlvbjEiLCJwb3NpdGlvbjIiLCJpbnRlcm1lZGlhdGVQb3NpdGlvbiIsImRpbWVuc2lvbiIsInB1c2giLCJwb3NpdGlvbkluZGV4UHJlZml4IiwiZWRpdEhhbmRsZXMiLCJpIiwibmV4dFBvc2l0aW9uIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztJQU9hQSx5QixXQUFBQSx5QjtBQUdYLHFDQUFZQyxpQkFBWixFQUFrRDtBQUFBOztBQUNoRCxTQUFLQSxpQkFBTCxHQUF5QkEsaUJBQXpCO0FBQ0Q7Ozs7Z0NBRThCO0FBQzdCLGFBQU8sS0FBS0EsaUJBQVo7QUFDRDs7QUFFRDs7Ozs7Ozs7Ozs7OztvQ0FXRUMsWSxFQUNBQyxlLEVBQ0FDLGUsRUFDMkI7QUFDM0IsVUFBTUMsa0JBQWtCLEtBQUtKLGlCQUFMLENBQXVCSyxRQUF2QixDQUFnQ0osWUFBaEMsQ0FBeEI7QUFDQSxVQUFNSyxjQUNKRixnQkFBZ0JHLFFBQWhCLENBQXlCQyxJQUF6QixLQUFrQyxTQUFsQyxJQUNBSixnQkFBZ0JHLFFBQWhCLENBQXlCQyxJQUF6QixLQUFrQyxjQUZwQzs7QUFJQSxVQUFNQyxxQkFBcUJDLHlCQUN6Qk4sZ0JBQWdCRyxRQUFoQixDQUF5QkksV0FEQSxFQUV6QlQsZUFGeUIsRUFHekJDLGVBSHlCLEVBSXpCRyxXQUp5QixDQUEzQjs7QUFPQSxVQUFNTSw4QkFDRFIsZUFEQztBQUVKRywrQkFDS0gsZ0JBQWdCRyxRQURyQjtBQUVFSSx1QkFBYUY7QUFGZjtBQUZJLFFBQU47O0FBUUE7QUFDQSxVQUFNSSx3Q0FDRCxLQUFLYixpQkFESjtBQUVKSywrQ0FDSyxLQUFLTCxpQkFBTCxDQUF1QkssUUFBdkIsQ0FBZ0NTLEtBQWhDLENBQXNDLENBQXRDLEVBQXlDYixZQUF6QyxDQURMLElBRUVXLGNBRkYsc0JBR0ssS0FBS1osaUJBQUwsQ0FBdUJLLFFBQXZCLENBQWdDUyxLQUFoQyxDQUFzQ2IsZUFBZSxDQUFyRCxDQUhMO0FBRkksUUFBTjs7QUFTQSxhQUFPLElBQUlGLHlCQUFKLENBQThCYyx3QkFBOUIsQ0FBUDtBQUNEOztBQUVEOzs7Ozs7Ozs7Ozs7bUNBU2Va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LElBQVosQ0FBaUI7QUFDZnpCLGtCQUFVb0Isd0JBQXdCcEIsUUFBeEIsRUFBa0M2QixZQUFsQyxDQURLO0FBRWZuRCxzREFBcUJnRCxtQkFBckIsSUFBMENFLElBQUksQ0FBOUMsRUFGZTtBQUdmbkQsa0NBSGU7QUFJZk8sY0FBTTtBQUpTLE9BQWpCO0FBTUQ7QUFDRjtBQUNELFNBQU8yQyxXQUFQO0FBQ0QiLCJmaWxlIjoiZWRpdGFibGUtZmVhdHVyZS1jb2xsZWN0aW9uLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gQGZsb3dcbmltcG9ydCB0eXBlIHsgR2VvSnNvbkdlb21ldHJ5IH0gZnJvbSAnLi4vdHlwZXMnO1xuXG50eXBlIEZlYXR1cmVDb2xsZWN0aW9uID0ge1xuICBmZWF0dXJlczogQXJyYXk8T2JqZWN0PlxufTtcblxuZXhwb3J0IGNsYXNzIEVkaXRhYmxlRmVhdHVyZUNvbGxlY3Rpb24ge1xuICBmZWF0dXJlQ29sbGVjdGlvbjogRmVhdHVyZUNvbGxlY3Rpb247XG5cbiAgY29uc3RydWN0b3IoZmVhdHVyZUNvbGxlY3Rpb246IEZlYXR1cmVDb2xsZWN0aW9uKSB7XG4gICAgdGhpcy5mZWF0dXJlQ29sbGVjdGlvbiA9IGZlYXR1cmVDb2xsZWN0aW9uO1xuICB9XG5cbiAgZ2V0T2JqZWN0KCk6IEZlYXR1cmVDb2xsZWN0aW9uIHtcbiAgICByZXR1cm4gdGhpcy5mZWF0dXJlQ29sbGVjdGlvbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXBsYWNlcyB0aGUgcG9zaXRpb24gZGVlcGx5IG5lc3RlZCB3aXRoaW5nIHRoZSBnaXZlbiBmZWF0dXJlJ3MgZ2VvbWV0cnkuXG4gICAqIFdvcmtzIHdpdGggUG9pbnQsIE11bHRpUG9pbnQsIExpbmVTdHJpbmcsIE11bHRpTGluZVN0cmluZywgUG9seWdvbiwgYW5kIE11bHRpUG9seWdvbi5cbiAgICpcbiAgICogQHBhcmFtIGZlYXR1cmVJbmRleCBUaGUgaW5kZXggb2YgdGhlIGZlYXR1cmUgdG8gdXBkYXRlXG4gICAqIEBwYXJhbSBwb3NpdGlvbkluZGV4ZXMgQW4gYXJyYXkgY29udGFpbmluZyB0aGUgaW5kZXhlcyBvZiB0aGUgcG9zaXRpb24gdG8gcmVwbGFjZVxuICAgKiBAcGFyYW0gdXBkYXRlZFBvc2l0aW9uIFRoZSB1cGRhdGVkIHBvc2l0aW9uIHRvIHBsYWNlIGluIHRoZSByZXN1bHQgKGkuZS4gW2xuZywgbGF0XSlcbiAgICpcbiAgICogQHJldHVybnMgQSBuZXcgYEVkaXRhYmxlRmVhdHVyZUNvbGxlY3Rpb25gIHdpdGggdGhlIGdpdmVuIHBvc2l0aW9uIHJlcGxhY2VkLiBEb2VzIG5vdCBtb2RpZnkgdGhpcyBgRWRpdGFibGVGZWF0dXJlQ29sbGVjdGlvbmAuXG4gICAqL1xuICByZXBsYWNlUG9zaXRpb24oXG4gICAgZmVhdHVyZUluZGV4OiBudW1iZXIsXG4gICAgcG9zaXRpb25JbmRleGVzOiBBcnJheTxudW1iZXI+LFxuICAgIHVwZGF0ZWRQb3NpdGlvbjogQXJyYXk8bnVtYmVyPlxuICApOiBFZGl0YWJsZUZlYXR1cmVDb2xsZWN0aW9uIHtcbiAgICBjb25zdCBmZWF0dXJlVG9VcGRhdGUgPSB0aGlzLmZlYXR1cmVDb2xsZWN0aW9uLmZlYXR1cmVzW2ZlYXR1cmVJbmRleF07XG4gICAgY29uc3QgaXNQb2x5Z29uYWwgPVxuICAgICAgZmVhdHVyZVRvVXBkYXRlLmdlb21ldHJ5LnR5cGUgPT09ICdQb2x5Z29uJyB8fFxuICAgICAgZmVhdHVyZVRvVXBkYXRlLmdlb21ldHJ5LnR5cGUgPT09ICdNdWx0aVBvbHlnb24nO1xuXG4gICAgY29uc3QgdXBkYXRlZENvb3JkaW5hdGVzID0gaW1tdXRhYmx5UmVwbGFjZVBvc2l0aW9uKFxuICAgICAgZmVhdHVyZVRvVXBkYXRlLmdlb21ldHJ5LmNvb3JkaW5hdGVzLFxuICAgICAgcG9zaXRpb25JbmRleGVzLFxuICAgICAgdXBkYXRlZFBvc2l0aW9uLFxuICAgICAgaXNQb2x5Z29uYWxcbiAgICApO1xuXG4gICAgY29uc3QgdXBkYXRlZEZlYXR1cmUgPSB7XG4gICAgICAuLi5mZWF0dXJlVG9VcGRhdGUsXG4gICAgICBnZW9tZXRyeToge1xuICAgICAgICAuLi5mZWF0dXJlVG9VcGRhdGUuZ2VvbWV0cnksXG4gICAgICAgIGNvb3JkaW5hdGVzOiB1cGRhdGVkQ29vcmRpbmF0ZXNcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gSW1tdXRhYmx5IHJlcGxhY2UgdGhlIGZlYXR1cmUgYmVpbmcgZWRpdGVkIGluIHRoZSBmZWF0dXJlQ29sbGVjdGlvblxuICAgIGNvbnN0IHVwZGF0ZWRGZWF0dXJlQ29sbGVjdGlvbiA9IHtcbiAgICAgIC4uLnRoaXMuZmVhdHVyZUNvbGxlY3Rpb24sXG4gICAgICBmZWF0dXJlczogW1xuICAgICAgICAuLi50aGlzLmZlYXR1cmVDb2xsZWN0aW9uLmZlYXR1cmVzLnNsaWNlKDAsIGZlYXR1cmVJbmRleCksXG4gICAgICAgIHVwZGF0ZWRGZWF0dXJlLFxuICAgICAgICAuLi50aGlzLmZlYXR1cmVDb2xsZWN0aW9uLmZlYXR1cmVzLnNsaWNlKGZlYXR1cmVJbmRleCArIDEpXG4gICAgICBdXG4gICAgfTtcblxuICAgIHJldHVybiBuZXcgRWRpdGFibGVGZWF0dXJlQ29sbGVjdGlvbih1cGRhdGVkRmVhdHVyZUNvbGxlY3Rpb24pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgYSBwb3NpdGlvbiBkZWVwbHkgbmVzdGVkIGluIGEgR2VvSlNPTiBnZW9tZXRyeSBjb29yZGluYXRlcyBhcnJheS5cbiAgICogV29ya3Mgd2l0aCBNdWx0aVBvaW50LCBMaW5lU3RyaW5nLCBNdWx0aUxpbmVTdHJpbmcsIFBvbHlnb24sIGFuZCBNdWx0aVBvbHlnb24uXG4gICAqXG4gICAqIEBwYXJhbSBmZWF0dXJlSW5kZXggVGhlIGluZGV4IG9mIHRoZSBmZWF0dXJlIHRvIHVwZGF0ZVxuICAgKiBAcGFyYW0gcG9zaXRpb25JbmRleGVzIEFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIGluZGV4ZXMgb2YgdGhlIHBvc3Rpb24gdG8gcmVtb3ZlXG4gICAqXG4gICAqIEByZXR1cm5zIEEgbmV3IGBFZGl0YWJsZUZlYXR1cmVDb2xsZWN0aW9uYCB3aXRoIHRoZSBnaXZlbiBjb29yZGluYXRlIHJlbW92ZWQuIERvZXMgbm90IG1vZGlmeSB0aGlzIGBFZGl0YWJsZUZlYXR1cmVDb2xsZWN0aW9uYC5cbiAgICovXG4gIHJlbW92ZVBvc2l0aW9uKGZlYXR1cmVJbmRleDogbnVtYmVyLCBwb3NpdGlvbkluZGV4ZXM6IEFycmF5PG51bWJlcj4pOiBFZGl0YWJsZUZlYXR1cmVDb2xsZWN0aW9uIHtcbiAgICBjb25zdCBmZWF0dXJlVG9VcGRhdGUgPSB0aGlzLmZlYXR1cmVDb2xsZWN0aW9uLmZlYXR1cmVzW2ZlYXR1cmVJbmRleF07XG4gICAgaWYgKGZlYXR1cmVUb1VwZGF0ZS5nZW9tZXRyeS50eXBlID09PSAnUG9pbnQnKSB7XG4gICAgICB0aHJvdyBFcnJvcihgQ2FuJ3QgcmVtb3ZlIGEgcG9zaXRpb24gZnJvbSBhIFBvaW50IG9yIHRoZXJlJ2QgYmUgbm90aGluZyBsZWZ0YCk7XG4gICAgfVxuICAgIGlmIChcbiAgICAgIGZlYXR1cmVUb1VwZGF0ZS5nZW9tZXRyeS50eXBlID09PSAnTXVsdGlQb2ludCcgJiZcbiAgICAgIGZlYXR1cmVUb1VwZGF0ZS5nZW9tZXRyeS5jb29yZGluYXRlcy5sZW5ndGggPCAyXG4gICAgKSB7XG4gICAgICB0aHJvdyBFcnJvcihgQ2FuJ3QgcmVtb3ZlIHRoZSBsYXN0IHBvaW50IG9mIGEgTXVsdGlQb2ludCBvciB0aGVyZSdkIGJlIG5vdGhpbmcgbGVmdGApO1xuICAgIH1cbiAgICBjb25zdCBpc1BvbHlnb25hbCA9XG4gICAgICBmZWF0dXJlVG9VcGRhdGUuZ2VvbWV0cnkudHlwZSA9PT0gJ1BvbHlnb24nIHx8XG4gICAgICBmZWF0dXJlVG9VcGRhdGUuZ2VvbWV0cnkudHlwZSA9PT0gJ011bHRpUG9seWdvbic7XG5cbiAgICBjb25zdCB1cGRhdGVkQ29vcmRpbmF0ZXMgPSBpbW11dGFibHlSZW1vdmVQb3NpdGlvbihcbiAgICAgIGZlYXR1cmVUb1VwZGF0ZS5nZW9tZXRyeS5jb29yZGluYXRlcyxcbiAgICAgIHBvc2l0aW9uSW5kZXhlcyxcbiAgICAgIGlzUG9seWdvbmFsXG4gICAgKTtcblxuICAgIGNvbnN0IHVwZGF0ZWRHZW9tZXRyeSA9IHtcbiAgICAgIC4uLmZlYXR1cmVUb1VwZGF0ZS5nZW9tZXRyeSxcbiAgICAgIGNvb3JkaW5hdGVzOiB1cGRhdGVkQ29vcmRpbmF0ZXNcbiAgICB9O1xuXG4gICAgLy8gSGFuZGxlIGNhc2VzIHdoZXJlIGdlb21ldHJ5IHR5cGUgaXMgXCJkb3duZ3JhZGVkXCJcbiAgICBkb3duZ3JhZGVHZW9tZXRyeUlmTmVjZXNzYXJ5KHVwZGF0ZWRHZW9tZXRyeSk7XG5cbiAgICBjb25zdCB1cGRhdGVkRmVhdHVyZSA9IHtcbiAgICAgIC4uLmZlYXR1cmVUb1VwZGF0ZSxcbiAgICAgIGdlb21ldHJ5OiB1cGRhdGVkR2VvbWV0cnlcbiAgICB9O1xuXG4gICAgLy8gSW1tdXRhYmx5IHJlcGxhY2UgdGhlIGZlYXR1cmUgYmVpbmcgZWRpdGVkIGluIHRoZSBmZWF0dXJlQ29sbGVjdGlvblxuICAgIGNvbnN0IHVwZGF0ZWRGZWF0dXJlQ29sbGVjdGlvbiA9IHtcbiAgICAgIC4uLnRoaXMuZmVhdHVyZUNvbGxlY3Rpb24sXG4gICAgICBmZWF0dXJlczogW1xuICAgICAgICAuLi50aGlzLmZlYXR1cmVDb2xsZWN0aW9uLmZlYXR1cmVzLnNsaWNlKDAsIGZlYXR1cmVJbmRleCksXG4gICAgICAgIHVwZGF0ZWRGZWF0dXJlLFxuICAgICAgICAuLi50aGlzLmZlYXR1cmVDb2xsZWN0aW9uLmZlYXR1cmVzLnNsaWNlKGZlYXR1cmVJbmRleCArIDEpXG4gICAgICBdXG4gICAgfTtcblxuICAgIHJldHVybiBuZXcgRWRpdGFibGVGZWF0dXJlQ29sbGVjdGlvbih1cGRhdGVkRmVhdHVyZUNvbGxlY3Rpb24pO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgYSBwb3NpdGlvbiBkZWVwbHkgbmVzdGVkIGluIGEgR2VvSlNPTiBnZW9tZXRyeSBjb29yZGluYXRlcyBhcnJheS5cbiAgICogV29ya3Mgd2l0aCBNdWx0aVBvaW50LCBMaW5lU3RyaW5nLCBNdWx0aUxpbmVTdHJpbmcsIFBvbHlnb24sIGFuZCBNdWx0aVBvbHlnb24uXG4gICAqXG4gICAqIEBwYXJhbSBmZWF0dXJlSW5kZXggVGhlIGluZGV4IG9mIHRoZSBmZWF0dXJlIHRvIHVwZGF0ZVxuICAgKiBAcGFyYW0gcG9zaXRpb25JbmRleGVzIEFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIGluZGV4ZXMgb2YgdGhlIHBvc3Rpb24gdGhhdCB3aWxsIHByZWNlZWQgdGhlIG5ldyBwb3NpdGlvblxuICAgKiBAcGFyYW0gcG9zaXRpb25Ub0FkZCBUaGUgbmV3IHBvc2l0aW9uIHRvIHBsYWNlIGluIHRoZSByZXN1bHQgKGkuZS4gW2xuZywgbGF0XSlcbiAgICpcbiAgICogQHJldHVybnMgQSBuZXcgYEVkaXRhYmxlRmVhdHVyZUNvbGxlY3Rpb25gIHdpdGggdGhlIGdpdmVuIGNvb3JkaW5hdGUgcmVtb3ZlZC4gRG9lcyBub3QgbW9kaWZ5IHRoaXMgYEVkaXRhYmxlRmVhdHVyZUNvbGxlY3Rpb25gLlxuICAgKi9cbiAgYWRkUG9zaXRpb24oXG4gICAgZmVhdHVyZUluZGV4OiBudW1iZXIsXG4gICAgcG9zaXRpb25JbmRleGVzOiBBcnJheTxudW1iZXI+LFxuICAgIHBvc2l0aW9uVG9BZGQ6IEFycmF5PG51bWJlcj5cbiAgKTogRWRpdGFibGVGZWF0dXJlQ29sbGVjdGlvbiB7XG4gICAgY29uc3QgZmVhdHVyZVRvVXBkYXRlID0gdGhpcy5mZWF0dXJlQ29sbGVjdGlvbi5mZWF0dXJlc1tmZWF0dXJlSW5kZXhdO1xuXG4gICAgaWYgKGZlYXR1cmVUb1VwZGF0ZS5nZW9tZXRyeS50eXBlID09PSAnUG9pbnQnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byBhZGQgYSBwb3NpdGlvbiB0byBhIFBvaW50IGZlYXR1cmUnKTtcbiAgICB9XG5cbiAgICBjb25zdCBpc1BvbHlnb25hbCA9XG4gICAgICBmZWF0dXJlVG9VcGRhdGUuZ2VvbWV0cnkudHlwZSA9PT0gJ1BvbHlnb24nIHx8XG4gICAgICBmZWF0dXJlVG9VcGRhdGUuZ2VvbWV0cnkudHlwZSA9PT0gJ011bHRpUG9seWdvbic7XG5cbiAgICBjb25zdCB1cGRhdGVkQ29vcmRpbmF0ZXMgPSBpbW11dGFibHlBZGRQb3NpdGlvbihcbiAgICAgIGZlYXR1cmVUb1VwZGF0ZS5nZW9tZXRyeS5jb29yZGluYXRlcyxcbiAgICAgIHBvc2l0aW9uSW5kZXhlcyxcbiAgICAgIHBvc2l0aW9uVG9BZGQsXG4gICAgICBpc1BvbHlnb25hbFxuICAgICk7XG5cbiAgICBjb25zdCB1cGRhdGVkRmVhdHVyZSA9IHtcbiAgICAgIC4uLmZlYXR1cmVUb1VwZGF0ZSxcbiAgICAgIGdlb21ldHJ5OiB7XG4gICAgICAgIC4uLmZlYXR1cmVUb1VwZGF0ZS5nZW9tZXRyeSxcbiAgICAgICAgY29vcmRpbmF0ZXM6IHVwZGF0ZWRDb29yZGluYXRlc1xuICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBJbW11dGFibHkgcmVwbGFjZSB0aGUgZmVhdHVyZSBiZWluZyBlZGl0ZWQgaW4gdGhlIGZlYXR1cmVDb2xsZWN0aW9uXG4gICAgY29uc3QgdXBkYXRlZEZlYXR1cmVDb2xsZWN0aW9uID0ge1xuICAgICAgLi4udGhpcy5mZWF0dXJlQ29sbGVjdGlvbixcbiAgICAgIGZlYXR1cmVzOiBbXG4gICAgICAgIC4uLnRoaXMuZmVhdHVyZUNvbGxlY3Rpb24uZmVhdHVyZXMuc2xpY2UoMCwgZmVhdHVyZUluZGV4KSxcbiAgICAgICAgdXBkYXRlZEZlYXR1cmUsXG4gICAgICAgIC4uLnRoaXMuZmVhdHVyZUNvbGxlY3Rpb24uZmVhdHVyZXMuc2xpY2UoZmVhdHVyZUluZGV4ICsgMSlcbiAgICAgIF1cbiAgICB9O1xuXG4gICAgcmV0dXJuIG5ldyBFZGl0YWJsZUZlYXR1cmVDb2xsZWN0aW9uKHVwZGF0ZWRGZWF0dXJlQ29sbGVjdGlvbik7XG4gIH1cblxuICByZXBsYWNlR2VvbWV0cnkoZmVhdHVyZUluZGV4OiBudW1iZXIsIGdlb21ldHJ5OiBHZW9Kc29uR2VvbWV0cnkpIHtcbiAgICBjb25zdCB1cGRhdGVkRmVhdHVyZSA9IHtcbiAgICAgIC4uLnRoaXMuZmVhdHVyZUNvbGxlY3Rpb24uZmVhdHVyZXNbZmVhdHVyZUluZGV4XSxcbiAgICAgIGdlb21ldHJ5XG4gICAgfTtcbiAgICBjb25zdCB1cGRhdGVkRmVhdHVyZUNvbGxlY3Rpb24gPSB7XG4gICAgICAuLi50aGlzLmZlYXR1cmVDb2xsZWN0aW9uLFxuICAgICAgZmVhdHVyZXM6IFtcbiAgICAgICAgLi4udGhpcy5mZWF0dXJlQ29sbGVjdGlvbi5mZWF0dXJlcy5zbGljZSgwLCBmZWF0dXJlSW5kZXgpLFxuICAgICAgICB1cGRhdGVkRmVhdHVyZSxcbiAgICAgICAgLi4udGhpcy5mZWF0dXJlQ29sbGVjdGlvbi5mZWF0dXJlcy5zbGljZShmZWF0dXJlSW5kZXggKyAxKVxuICAgICAgXVxuICAgIH07XG4gICAgcmV0dXJuIG5ldyBFZGl0YWJsZUZlYXR1cmVDb2xsZWN0aW9uKHVwZGF0ZWRGZWF0dXJlQ29sbGVjdGlvbik7XG4gIH1cblxuICBhZGRGZWF0dXJlKGZlYXR1cmU6IE9iamVjdCkge1xuICAgIGNvbnN0IHVwZGF0ZWRGZWF0dXJlQ29sbGVjdGlvbiA9IHtcbiAgICAgIC4uLnRoaXMuZmVhdHVyZUNvbGxlY3Rpb24sXG4gICAgICBmZWF0dXJlczogWy4uLnRoaXMuZmVhdHVyZUNvbGxlY3Rpb24uZmVhdHVyZXMsIGZlYXR1cmVdXG4gICAgfTtcbiAgICByZXR1cm4gbmV3IEVkaXRhYmxlRmVhdHVyZUNvbGxlY3Rpb24odXBkYXRlZEZlYXR1cmVDb2xsZWN0aW9uKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgZmxhdCBhcnJheSBvZiBwb3NpdGlvbnMgZm9yIHRoZSBnaXZlbiBmZWF0dXJlIGFsb25nIHdpdGggdGhlaXIgaW5kZXhlcyBpbnRvIHRoZSBmZWF0dXJlJ3MgZ2VvbWV0cnkncyBjb29yZGluYXRlcy5cbiAgICpcbiAgICogQHBhcmFtIGZlYXR1cmVJbmRleCBUaGUgaW5kZXggb2YgdGhlIGZlYXR1cmUgdG8gZ2V0IGVkaXQgaGFuZGxlc1xuICAgKi9cbiAgZ2V0RWRpdEhhbmRsZXMoZmVhdHVyZUluZGV4OiBudW1iZXIpIHtcbiAgICBsZXQgaGFuZGxlcyA9IFtdO1xuXG4gICAgY29uc3QgZ2VvbWV0cnkgPSB0aGlzLmZlYXR1cmVDb2xsZWN0aW9uLmZlYXR1cmVzW2ZlYXR1cmVJbmRleF0uZ2VvbWV0cnk7XG5cbiAgICBzd2l0Y2ggKGdlb21ldHJ5LnR5cGUpIHtcbiAgICAgIGNhc2UgJ1BvaW50JzpcbiAgICAgICAgLy8gcG9zaXRpb25zIGFyZSBub3QgbmVzdGVkXG4gICAgICAgIGhhbmRsZXMgPSBbXG4gICAgICAgICAge1xuICAgICAgICAgICAgcG9zaXRpb246IGdlb21ldHJ5LmNvb3JkaW5hdGVzLFxuICAgICAgICAgICAgcG9zaXRpb25JbmRleGVzOiBbXSxcbiAgICAgICAgICAgIGZlYXR1cmVJbmRleCxcbiAgICAgICAgICAgIHR5cGU6ICdleGlzdGluZydcbiAgICAgICAgICB9XG4gICAgICAgIF07XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnTXVsdGlQb2ludCc6XG4gICAgICBjYXNlICdMaW5lU3RyaW5nJzpcbiAgICAgICAgLy8gcG9zaXRpb25zIGFyZSBuZXN0ZWQgMSBsZXZlbFxuICAgICAgICBjb25zdCBpbmNsdWRlSW50ZXJtZWRpYXRlID0gZ2VvbWV0cnkudHlwZSAhPT0gJ011bHRpUG9pbnQnO1xuICAgICAgICBoYW5kbGVzID0gaGFuZGxlcy5jb25jYXQoXG4gICAgICAgICAgZ2V0RWRpdEhhbmRsZXMoZ2VvbWV0cnkuY29vcmRpbmF0ZXMsIFtdLCBpbmNsdWRlSW50ZXJtZWRpYXRlLCBmZWF0dXJlSW5kZXgpXG4gICAgICAgICk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnUG9seWdvbic6XG4gICAgICBjYXNlICdNdWx0aUxpbmVTdHJpbmcnOlxuICAgICAgICAvLyBwb3NpdGlvbnMgYXJlIG5lc3RlZCAyIGxldmVsc1xuICAgICAgICBmb3IgKGxldCBhID0gMDsgYSA8IGdlb21ldHJ5LmNvb3JkaW5hdGVzLmxlbmd0aDsgYSsrKSB7XG4gICAgICAgICAgaGFuZGxlcyA9IGhhbmRsZXMuY29uY2F0KFxuICAgICAgICAgICAgZ2V0RWRpdEhhbmRsZXMoZ2VvbWV0cnkuY29vcmRpbmF0ZXNbYV0sIFthXSwgdHJ1ZSwgZmVhdHVyZUluZGV4KVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdNdWx0aVBvbHlnb24nOlxuICAgICAgICAvLyBwb3NpdGlvbnMgYXJlIG5lc3RlZCAzIGxldmVsc1xuICAgICAgICBmb3IgKGxldCBhID0gMDsgYSA8IGdlb21ldHJ5LmNvb3JkaW5hdGVzLmxlbmd0aDsgYSsrKSB7XG4gICAgICAgICAgZm9yIChsZXQgYiA9IDA7IGIgPCBnZW9tZXRyeS5jb29yZGluYXRlc1thXS5sZW5ndGg7IGIrKykge1xuICAgICAgICAgICAgaGFuZGxlcyA9IGhhbmRsZXMuY29uY2F0KFxuICAgICAgICAgICAgICBnZXRFZGl0SGFuZGxlcyhnZW9tZXRyeS5jb29yZGluYXRlc1thXVtiXSwgW2EsIGJdLCB0cnVlLCBmZWF0dXJlSW5kZXgpXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IEVycm9yKGBVbmhhbmRsZWQgZ2VvbWV0cnkgdHlwZTogJHtnZW9tZXRyeS50eXBlfWApO1xuICAgIH1cblxuICAgIHJldHVybiBoYW5kbGVzO1xuICB9XG59XG5cbmZ1bmN0aW9uIGltbXV0YWJseVJlcGxhY2VQb3NpdGlvbihcbiAgY29vcmRpbmF0ZXM6IEFycmF5PGFueT4sXG4gIHBvc2l0aW9uSW5kZXhlczogQXJyYXk8bnVtYmVyPixcbiAgdXBkYXRlZFBvc2l0aW9uOiBBcnJheTxudW1iZXI+LFxuICBpc1BvbHlnb25hbDogYm9vbGVhblxuKTogQXJyYXk8YW55PiB7XG4gIGlmICghcG9zaXRpb25JbmRleGVzKSB7XG4gICAgcmV0dXJuIGNvb3JkaW5hdGVzO1xuICB9XG4gIGlmIChwb3NpdGlvbkluZGV4ZXMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIHVwZGF0ZWRQb3NpdGlvbjtcbiAgfVxuICBpZiAocG9zaXRpb25JbmRleGVzLmxlbmd0aCA9PT0gMSkge1xuICAgIGNvbnN0IHVwZGF0ZWQgPSBbXG4gICAgICAuLi5jb29yZGluYXRlcy5zbGljZSgwLCBwb3NpdGlvbkluZGV4ZXNbMF0pLFxuICAgICAgdXBkYXRlZFBvc2l0aW9uLFxuICAgICAgLi4uY29vcmRpbmF0ZXMuc2xpY2UocG9zaXRpb25JbmRleGVzWzBdICsgMSlcbiAgICBdO1xuXG4gICAgaWYgKFxuICAgICAgaXNQb2x5Z29uYWwgJiZcbiAgICAgIChwb3NpdGlvbkluZGV4ZXNbMF0gPT09IDAgfHwgcG9zaXRpb25JbmRleGVzWzBdID09PSBjb29yZGluYXRlcy5sZW5ndGggLSAxKVxuICAgICkge1xuICAgICAgLy8gZm9yIHBvbHlnb25zLCB0aGUgZmlyc3QgcG9pbnQgaXMgcmVwZWF0ZWQgYXQgdGhlIGVuZCBvZiB0aGUgYXJyYXlcbiAgICAgIC8vIHNvLCB1cGRhdGUgaXQgb24gYm90aCBlbmRzIG9mIHRoZSBhcnJheVxuICAgICAgdXBkYXRlZFswXSA9IHVwZGF0ZWRQb3NpdGlvbjtcbiAgICAgIHVwZGF0ZWRbY29vcmRpbmF0ZXMubGVuZ3RoIC0gMV0gPSB1cGRhdGVkUG9zaXRpb247XG4gICAgfVxuICAgIHJldHVybiB1cGRhdGVkO1xuICB9XG5cbiAgLy8gcmVjdXJzaXZlbHkgdXBkYXRlIGlubmVyIGFycmF5XG4gIHJldHVybiBbXG4gICAgLi4uY29vcmRpbmF0ZXMuc2xpY2UoMCwgcG9zaXRpb25JbmRleGVzWzBdKSxcbiAgICBpbW11dGFibHlSZXBsYWNlUG9zaXRpb24oXG4gICAgICBjb29yZGluYXRlc1twb3NpdGlvbkluZGV4ZXNbMF1dLFxuICAgICAgcG9zaXRpb25JbmRleGVzLnNsaWNlKDEsIHBvc2l0aW9uSW5kZXhlcy5sZW5ndGgpLFxuICAgICAgdXBkYXRlZFBvc2l0aW9uLFxuICAgICAgaXNQb2x5Z29uYWxcbiAgICApLFxuICAgIC4uLmNvb3JkaW5hdGVzLnNsaWNlKHBvc2l0aW9uSW5kZXhlc1swXSArIDEpXG4gIF07XG59XG5cbmZ1bmN0aW9uIGltbXV0YWJseVJlbW92ZVBvc2l0aW9uKFxuICBjb29yZGluYXRlczogQXJyYXk8YW55PixcbiAgcG9zaXRpb25JbmRleGVzOiBBcnJheTxudW1iZXI+LFxuICBpc1BvbHlnb25hbDogYm9vbGVhblxuKTogQXJyYXk8YW55PiB7XG4gIGlmICghcG9zaXRpb25JbmRleGVzKSB7XG4gICAgcmV0dXJuIGNvb3JkaW5hdGVzO1xuICB9XG4gIGlmIChwb3NpdGlvbkluZGV4ZXMubGVuZ3RoID09PSAwKSB7XG4gICAgdGhyb3cgRXJyb3IoJ011c3Qgc3BlY2lmeSB0aGUgaW5kZXggb2YgdGhlIHBvc2l0aW9uIHRvIHJlbW92ZScpO1xuICB9XG4gIGlmIChwb3NpdGlvbkluZGV4ZXMubGVuZ3RoID09PSAxKSB7XG4gICAgY29uc3QgdXBkYXRlZCA9IFtcbiAgICAgIC4uLmNvb3JkaW5hdGVzLnNsaWNlKDAsIHBvc2l0aW9uSW5kZXhlc1swXSksXG4gICAgICAuLi5jb29yZGluYXRlcy5zbGljZShwb3NpdGlvbkluZGV4ZXNbMF0gKyAxKVxuICAgIF07XG5cbiAgICBpZiAoXG4gICAgICBpc1BvbHlnb25hbCAmJlxuICAgICAgKHBvc2l0aW9uSW5kZXhlc1swXSA9PT0gMCB8fCBwb3NpdGlvbkluZGV4ZXNbMF0gPT09IGNvb3JkaW5hdGVzLmxlbmd0aCAtIDEpXG4gICAgKSB7XG4gICAgICAvLyBmb3IgcG9seWdvbnMsIHRoZSBmaXJzdCBwb2ludCBpcyByZXBlYXRlZCBhdCB0aGUgZW5kIG9mIHRoZSBhcnJheVxuICAgICAgLy8gc28sIGlmIHRoZSBmaXJzdC9sYXN0IGNvb3JkaW5hdGUgaXMgdG8gYmUgcmVtb3ZlZCwgY29vcmRpbmF0ZXNbMV0gd2lsbCBiZSB0aGUgbmV3IGZpcnN0L2xhc3QgY29vcmRpbmF0ZVxuICAgICAgaWYgKHBvc2l0aW9uSW5kZXhlc1swXSA9PT0gMCkge1xuICAgICAgICAvLyBjaGFuZ2UgdGhlIGxhc3QgdG8gYmUgdGhlIHNhbWUgYXMgdGhlIGZpcnN0XG4gICAgICAgIHVwZGF0ZWRbdXBkYXRlZC5sZW5ndGggLSAxXSA9IHVwZGF0ZWRbMF07XG4gICAgICB9IGVsc2UgaWYgKHBvc2l0aW9uSW5kZXhlc1swXSA9PT0gY29vcmRpbmF0ZXMubGVuZ3RoIC0gMSkge1xuICAgICAgICAvLyBjaGFuZ2UgdGhlIGZpcnN0IHRvIGJlIHRoZSBzYW1lIGFzIHRoZSBsYXN0XG4gICAgICAgIHVwZGF0ZWRbMF0gPSB1cGRhdGVkW3VwZGF0ZWQubGVuZ3RoIC0gMV07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB1cGRhdGVkO1xuICB9XG5cbiAgLy8gcmVjdXJzaXZlbHkgdXBkYXRlIGlubmVyIGFycmF5XG4gIHJldHVybiBbXG4gICAgLi4uY29vcmRpbmF0ZXMuc2xpY2UoMCwgcG9zaXRpb25JbmRleGVzWzBdKSxcbiAgICBpbW11dGFibHlSZW1vdmVQb3NpdGlvbihcbiAgICAgIGNvb3JkaW5hdGVzW3Bvc2l0aW9uSW5kZXhlc1swXV0sXG4gICAgICBwb3NpdGlvbkluZGV4ZXMuc2xpY2UoMSwgcG9zaXRpb25JbmRleGVzLmxlbmd0aCksXG4gICAgICBpc1BvbHlnb25hbFxuICAgICksXG4gICAgLi4uY29vcmRpbmF0ZXMuc2xpY2UocG9zaXRpb25JbmRleGVzWzBdICsgMSlcbiAgXTtcbn1cblxuZnVuY3Rpb24gaW1tdXRhYmx5QWRkUG9zaXRpb24oXG4gIGNvb3JkaW5hdGVzOiBBcnJheTxhbnk+LFxuICBwb3NpdGlvbkluZGV4ZXM6IEFycmF5PG51bWJlcj4sXG4gIHBvc2l0aW9uVG9BZGQ6IEFycmF5PG51bWJlcj4sXG4gIGlzUG9seWdvbmFsOiBib29sZWFuXG4pOiBBcnJheTxhbnk+IHtcbiAgaWYgKCFwb3NpdGlvbkluZGV4ZXMpIHtcbiAgICByZXR1cm4gY29vcmRpbmF0ZXM7XG4gIH1cbiAgaWYgKHBvc2l0aW9uSW5kZXhlcy5sZW5ndGggPT09IDApIHtcbiAgICB0aHJvdyBFcnJvcignTXVzdCBzcGVjaWZ5IHRoZSBpbmRleCBvZiB0aGUgcG9zaXRpb24gdG8gcmVtb3ZlJyk7XG4gIH1cbiAgaWYgKHBvc2l0aW9uSW5kZXhlcy5sZW5ndGggPT09IDEpIHtcbiAgICBpZiAoaXNQb2x5Z29uYWwgJiYgKHBvc2l0aW9uSW5kZXhlc1swXSA8IDEgfHwgcG9zaXRpb25JbmRleGVzWzBdID4gY29vcmRpbmF0ZXMubGVuZ3RoIC0gMSkpIHtcbiAgICAgIC8vIFRPRE86IHRlc3QgdGhpcyBjYXNlXG4gICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgYEludmFsaWQgcG9zaXRpb24gaW5kZXggZm9yIHBvbHlnb246ICR7XG4gICAgICAgICAgcG9zaXRpb25JbmRleGVzWzBdXG4gICAgICAgIH0uIFBvaW50cyBtdXN0IGJlIGFkZGVkIHRvIGEgUG9seWdvbiBiZXR3ZWVuIHRoZSBmaXJzdCBhbmQgbGFzdCBwb2ludC5gXG4gICAgICApO1xuICAgIH1cbiAgICBjb25zdCB1cGRhdGVkID0gW1xuICAgICAgLi4uY29vcmRpbmF0ZXMuc2xpY2UoMCwgcG9zaXRpb25JbmRleGVzWzBdKSxcbiAgICAgIHBvc2l0aW9uVG9BZGQsXG4gICAgICAuLi5jb29yZGluYXRlcy5zbGljZShwb3NpdGlvbkluZGV4ZXNbMF0pXG4gICAgXTtcbiAgICByZXR1cm4gdXBkYXRlZDtcbiAgfVxuXG4gIC8vIHJlY3Vyc2l2ZWx5IHVwZGF0ZSBpbm5lciBhcnJheVxuICByZXR1cm4gW1xuICAgIC4uLmNvb3JkaW5hdGVzLnNsaWNlKDAsIHBvc2l0aW9uSW5kZXhlc1swXSksXG4gICAgaW1tdXRhYmx5QWRkUG9zaXRpb24oXG4gICAgICBjb29yZGluYXRlc1twb3NpdGlvbkluZGV4ZXNbMF1dLFxuICAgICAgcG9zaXRpb25JbmRleGVzLnNsaWNlKDEsIHBvc2l0aW9uSW5kZXhlcy5sZW5ndGgpLFxuICAgICAgcG9zaXRpb25Ub0FkZCxcbiAgICAgIGlzUG9seWdvbmFsXG4gICAgKSxcbiAgICAuLi5jb29yZGluYXRlcy5zbGljZShwb3NpdGlvbkluZGV4ZXNbMF0gKyAxKVxuICBdO1xufVxuXG5mdW5jdGlvbiBkb3duZ3JhZGVHZW9tZXRyeUlmTmVjZXNzYXJ5KGdlb21ldHJ5OiBHZW9Kc29uR2VvbWV0cnkpIHtcbiAgc3dpdGNoIChnZW9tZXRyeS50eXBlKSB7XG4gICAgY2FzZSAnTGluZVN0cmluZyc6XG4gICAgICBkb3duZ3JhZGVMaW5lU3RyaW5nSWZOZWNlc3NhcnkoZ2VvbWV0cnkpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnUG9seWdvbic6XG4gICAgICBkb3duZ3JhZGVQb2x5Z29uSWZOZWNlc3NhcnkoZ2VvbWV0cnkpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnTXVsdGlMaW5lU3RyaW5nJzpcbiAgICAgIGRvd25ncmFkZU11bHRpTGluZVN0cmluZ0lmTmVjZXNzYXJ5KGdlb21ldHJ5KTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ011bHRpUG9seWdvbic6XG4gICAgICBkb3duZ3JhZGVNdWx0aVBvbHlnb25JZk5lY2Vzc2FyeShnZW9tZXRyeSk7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgLy8gTm90IGRvd25ncmFkYWJsZVxuICAgICAgYnJlYWs7XG4gIH1cbn1cblxuZnVuY3Rpb24gZG93bmdyYWRlTGluZVN0cmluZ0lmTmVjZXNzYXJ5KGdlb21ldHJ5OiBHZW9Kc29uR2VvbWV0cnkpIHtcbiAgaWYgKGdlb21ldHJ5LmNvb3JkaW5hdGVzLmxlbmd0aCA9PT0gMSkge1xuICAgIC8vIE9ubHkgb25lIHBvc2l0aW9uIGxlZnQsIHNvIGNvbnZlcnQgdG8gYSBQb2ludFxuICAgIGdlb21ldHJ5LnR5cGUgPSAnUG9pbnQnO1xuICAgIGdlb21ldHJ5LmNvb3JkaW5hdGVzID0gZ2VvbWV0cnkuY29vcmRpbmF0ZXNbMF07XG4gIH1cbn1cblxuZnVuY3Rpb24gZG93bmdyYWRlUG9seWdvbklmTmVjZXNzYXJ5KGdlb21ldHJ5OiBHZW9Kc29uR2VvbWV0cnkpIHtcbiAgY29uc3QgcG9seWdvbiA9IGdlb21ldHJ5LmNvb3JkaW5hdGVzO1xuICBjb25zdCBvdXRlclJpbmcgPSBwb2x5Z29uWzBdO1xuICAvLyBJZiB0aGUgb3V0ZXIgcmluZyBpcyBubyBsb25nZXIgYSBwb2x5Z29uLCBjb252ZXJ0IHRoZSB3aG9sZSB0aGluZyB0byBhIExpbmVTdHJpbmdcbiAgaWYgKG91dGVyUmluZy5sZW5ndGggPD0gMykge1xuICAgIGdlb21ldHJ5LnR5cGUgPSAnTGluZVN0cmluZyc7XG4gICAgZ2VvbWV0cnkuY29vcmRpbmF0ZXMgPSBvdXRlclJpbmcuc2xpY2UoMCwgb3V0ZXJSaW5nLmxlbmd0aCAtIDEpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIElmIGFueSBob2xlIGlzIG5vIGxvbmdlciBhIHBvbHlnb24sIHJlbW92ZSB0aGUgaG9sZSBlbnRpcmVseVxuICBmb3IgKGxldCBob2xlSW5kZXggPSAxOyBob2xlSW5kZXggPCBwb2x5Z29uLmxlbmd0aDsgaG9sZUluZGV4KyspIHtcbiAgICBpZiAocmVtb3ZlSG9sZUlmTmVjZXNzYXJ5KHBvbHlnb24sIGhvbGVJbmRleCkpIHtcbiAgICAgIC8vIEl0IHdhcyByZW1vdmVkLCBzbyBrZWVwIHRoZSBpbmRleCB0aGUgc2FtZVxuICAgICAgaG9sZUluZGV4LS07XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGRvd25ncmFkZU11bHRpTGluZVN0cmluZ0lmTmVjZXNzYXJ5KGdlb21ldHJ5OiBHZW9Kc29uR2VvbWV0cnkpIHtcbiAgaWYgKGdlb21ldHJ5LmNvb3JkaW5hdGVzLmxlbmd0aCA9PT0gMSAmJiBnZW9tZXRyeS5jb29yZGluYXRlc1swXS5sZW5ndGggPT09IDEpIHtcbiAgICAvLyBPbmx5IG9uZSBwb3NpdGlvbiBsZWZ0LCBzbyBjb252ZXJ0IHRvIGEgUG9pbnRcbiAgICBnZW9tZXRyeS50eXBlID0gJ1BvaW50JztcbiAgICBnZW9tZXRyeS5jb29yZGluYXRlcyA9IGdlb21ldHJ5LmNvb3JkaW5hdGVzWzBdWzBdO1xuICAgIHJldHVybjtcbiAgfVxuICBmb3IgKGxldCBsaW5lU3RyaW5nSW5kZXggPSAwOyBsaW5lU3RyaW5nSW5kZXggPCBnZW9tZXRyeS5jb29yZGluYXRlcy5sZW5ndGg7IGxpbmVTdHJpbmdJbmRleCsrKSB7XG4gICAgY29uc3QgbGluZVN0cmluZyA9IGdlb21ldHJ5LmNvb3JkaW5hdGVzW2xpbmVTdHJpbmdJbmRleF07XG4gICAgaWYgKGxpbmVTdHJpbmcubGVuZ3RoID09PSAxKSB7XG4gICAgICAvLyBPbmx5IGEgc2luZ2xlIHBvc2l0aW9uIGxlZnQgb24gdGhpcyBMaW5lU3RyaW5nLCBzbyByZW1vdmUgaXQgKGNhbid0IGhhdmUgUG9pbnQgaW4gTXVsdGlMaW5lU3RyaW5nKVxuICAgICAgZ2VvbWV0cnkuY29vcmRpbmF0ZXMuc3BsaWNlKGxpbmVTdHJpbmdJbmRleCwgMSk7XG4gICAgICAvLyBLZWVwIHRoZSBpbmRleCB0aGUgc2FtZVxuICAgICAgbGluZVN0cmluZ0luZGV4LS07XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGRvd25ncmFkZU11bHRpUG9seWdvbklmTmVjZXNzYXJ5KGdlb21ldHJ5OiBHZW9Kc29uR2VvbWV0cnkpIHtcbiAgaWYgKGdlb21ldHJ5LmNvb3JkaW5hdGVzLmxlbmd0aCA9PT0gMSkge1xuICAgIGNvbnN0IG91dGVyUmluZyA9IGdlb21ldHJ5LmNvb3JkaW5hdGVzWzBdWzBdO1xuICAgIGlmIChvdXRlclJpbmcubGVuZ3RoIDw9IDMpIHtcbiAgICAgIGdlb21ldHJ5LnR5cGUgPSAnTGluZVN0cmluZyc7XG4gICAgICBnZW9tZXRyeS5jb29yZGluYXRlcyA9IG91dGVyUmluZy5zbGljZSgwLCBvdXRlclJpbmcubGVuZ3RoIC0gMSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG4gIGZvciAobGV0IHBvbHlnb25JbmRleCA9IDA7IHBvbHlnb25JbmRleCA8IGdlb21ldHJ5LmNvb3JkaW5hdGVzLmxlbmd0aDsgcG9seWdvbkluZGV4KyspIHtcbiAgICBjb25zdCBwb2x5Z29uID0gZ2VvbWV0cnkuY29vcmRpbmF0ZXNbcG9seWdvbkluZGV4XTtcbiAgICBjb25zdCBvdXRlclJpbmcgPSBwb2x5Z29uWzBdO1xuXG4gICAgLy8gSWYgdGhlIG91dGVyIHJpbmcgaXMgbm8gbG9uZ2VyIGEgcG9seWdvbiwgcmVtb3ZlIHRoZSB3aG9sZSBwb2x5Z29uXG4gICAgaWYgKG91dGVyUmluZy5sZW5ndGggPD0gMykge1xuICAgICAgZ2VvbWV0cnkuY29vcmRpbmF0ZXMuc3BsaWNlKHBvbHlnb25JbmRleCwgMSk7XG4gICAgICAvLyBJdCB3YXMgcmVtb3ZlZCwgc28ga2VlcCB0aGUgaW5kZXggdGhlIHNhbWVcbiAgICAgIHBvbHlnb25JbmRleC0tO1xuICAgIH1cblxuICAgIGZvciAobGV0IGhvbGVJbmRleCA9IDE7IGhvbGVJbmRleCA8IHBvbHlnb24ubGVuZ3RoOyBob2xlSW5kZXgrKykge1xuICAgICAgaWYgKHJlbW92ZUhvbGVJZk5lY2Vzc2FyeShwb2x5Z29uLCBob2xlSW5kZXgpKSB7XG4gICAgICAgIC8vIEl0IHdhcyByZW1vdmVkLCBzbyBrZWVwIHRoZSBpbmRleCB0aGUgc2FtZVxuICAgICAgICBob2xlSW5kZXgtLTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVtb3ZlSG9sZUlmTmVjZXNzYXJ5KHBvbHlnb246IEFycmF5PGFueT4sIGhvbGVJbmRleDogbnVtYmVyKSB7XG4gIGNvbnN0IGhvbGUgPSBwb2x5Z29uW2hvbGVJbmRleF07XG4gIGlmIChob2xlLmxlbmd0aCA8PSAzKSB7XG4gICAgcG9seWdvbi5zcGxpY2UoaG9sZUluZGV4LCAxKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGdldEludGVybWVkaWF0ZVBvc2l0aW9uKFxuICBwb3NpdGlvbjE6IEFycmF5PG51bWJlcj4sXG4gIHBvc2l0aW9uMjogQXJyYXk8bnVtYmVyPlxuKTogQXJyYXk8bnVtYmVyPiB7XG4gIGNvbnN0IGludGVybWVkaWF0ZVBvc2l0aW9uID0gW107XG4gIGZvciAobGV0IGRpbWVuc2lvbiA9IDA7IGRpbWVuc2lvbiA8IHBvc2l0aW9uMS5sZW5ndGg7IGRpbWVuc2lvbisrKSB7XG4gICAgaW50ZXJtZWRpYXRlUG9zaXRpb24ucHVzaCgocG9zaXRpb24xW2RpbWVuc2lvbl0gKyBwb3NpdGlvbjJbZGltZW5zaW9uXSkgLyAyLjApO1xuICB9XG4gIHJldHVybiBpbnRlcm1lZGlhdGVQb3NpdGlvbjtcbn1cblxuZnVuY3Rpb24gZ2V0RWRpdEhhbmRsZXMoXG4gIGNvb3JkaW5hdGVzOiBBcnJheTxBcnJheTxudW1iZXI+PixcbiAgcG9zaXRpb25JbmRleFByZWZpeDogQXJyYXk8bnVtYmVyPixcbiAgaW5jbHVkZUludGVybWVkaWF0ZTogYm9vbGVhbixcbiAgZmVhdHVyZUluZGV4OiBudW1iZXJcbikge1xuICBjb25zdCBlZGl0SGFuZGxlcyA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGNvb3JkaW5hdGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgcG9zaXRpb24gPSBjb29yZGluYXRlc1tpXTtcbiAgICBlZGl0SGFuZGxlcy5wdXNoKHtcbiAgICAgIHBvc2l0aW9uLFxuICAgICAgcG9zaXRpb25JbmRleGVzOiBbLi4ucG9zaXRpb25JbmRleFByZWZpeCwgaV0sXG4gICAgICBmZWF0dXJlSW5kZXgsXG4gICAgICB0eXBlOiAnZXhpc3RpbmcnXG4gICAgfSk7XG5cbiAgICBpZiAoaW5jbHVkZUludGVybWVkaWF0ZSAmJiBpIDwgY29vcmRpbmF0ZXMubGVuZ3RoIC0gMSkge1xuICAgICAgLy8gYWRkIGludGVybWVkaWF0ZSBwb3NpdGlvbiBhZnRlciBldmVyeSBwb3NpdGlvbiBleGNlcHQgdGhlIGxhc3Qgb25lXG4gICAgICBjb25zdCBuZXh0UG9zaXRpb24gPSBjb29yZGluYXRlc1tpICsgMV07XG4gICAgICBlZGl0SGFuZGxlcy5wdXNoKHtcbiAgICAgICAgcG9zaXRpb246IGdldEludGVybWVkaWF0ZVBvc2l0aW9uKHBvc2l0aW9uLCBuZXh0UG9zaXRpb24pLFxuICAgICAgICBwb3NpdGlvbkluZGV4ZXM6IFsuLi5wb3NpdGlvbkluZGV4UHJlZml4LCBpICsgMV0sXG4gICAgICAgIGZlYXR1cmVJbmRleCxcbiAgICAgICAgdHlwZTogJ2ludGVybWVkaWF0ZSdcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZWRpdEhhbmRsZXM7XG59XG4iXX0=