'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _events = require('events');

var _events2 = _interopRequireDefault(_events);

var _document = require('global/document');

var _document2 = _interopRequireDefault(_document);

var _window = require('global/window');

var _window2 = _interopRequireDefault(_window);

var _deck = require('deck.gl');

var _deckDrawer = require('./deck-renderer/deck-drawer');

var _deckDrawer2 = _interopRequireDefault(_deckDrawer);

var _layerMouseEvent = require('./layer-mouse-event');

var _layerMouseEvent2 = _interopRequireDefault(_layerMouseEvent);

var _projector = require('./projector');

var _projector2 = _interopRequireDefault(_projector);

var _nebulaLayer = require('./nebula-layer');

var _nebulaLayer2 = _interopRequireDefault(_nebulaLayer);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var LOGGER_PREFIX = 'Nebula: ';

var Nebula = function () {
  function Nebula() {
    var _this = this;

    _classCallCheck(this, Nebula);

    this.queryObjectEvents = new _events2.default();

    this._onMouseEvent = function (event) {
      if (!_this._isNebulaEvent(event)) {
        return;
      }

      if (event.type === 'mousedown') {
        _this._mouseWasDown = true;
      }

      // offsetX/Y of the MouseEvent provides the offset in the X/Y coordinate
      // of the mouse pointer between that event and the padding edge of the target node.
      // We set our listener to document so we need to adjust offsetX/Y
      // in case the target is not be our WebGL canvas.

      var _ref = _this.mainContainer ? _this.mainContainer.getBoundingClientRect() : {},
          _ref$top = _ref.top,
          top = _ref$top === undefined ? 0 : _ref$top,
          _ref$left = _ref.left,
          left = _ref$left === undefined ? 0 : _ref$left;

      var proxyEvent = new Proxy(event, {
        get: function get(original, propertyName) {
          if (propertyName === 'offsetX') {
            return original.pageX - left;
          }

          if (propertyName === 'offsetY') {
            return original.pageY - top;
          }

          // TODO: Properly use pointer events
          if (propertyName === 'type') {
            return original.type.replace('pointer', 'mouse');
          }

          var result = original[propertyName];
          if (typeof result === 'function') {
            return result.bind(original);
          }
          return result;
        }
      });

      _this._handleDeckGLEvent(proxyEvent);
    };
  }

  _createClass(Nebula, [{
    key: 'init',
    value: function init(props) {
      var _this2 = this;

      this.props = props;
      this.projector = new _projector2.default(this.props.viewport);
      this.wmViewport = new _deck.WebMercatorViewport(this.props.viewport);

      // TODO: Properly use pointer events
      // ['click', 'dblclick', 'mousemove', 'mouseup', 'mousedown'].forEach(name =>
      ['click', 'dblclick', 'pointermove', 'pointerup', 'pointerdown'].forEach(function (name) {
        return _document2.default.addEventListener(name, _this2._onMouseEvent, true);
      });
    }
  }, {
    key: 'updateProps',
    value: function updateProps(newProps) {
      this.props = newProps;
      var viewport = this.props.viewport;
      var projector = this.projector;


      if (projector.shouldChangeCenter(viewport)) {
        this.log('Changing center to [' + viewport.longitude + ', ' + viewport.latitude + ']');
        projector.setCenterFromViewport(viewport);
      }

      this.wmViewport = new _deck.WebMercatorViewport(viewport);
    }
  }, {
    key: 'log',
    value: function log(message) {
      var logger = this.props.logger;

      if (logger && logger.info) {
        logger.info(LOGGER_PREFIX + message);
      }
    }
  }, {
    key: 'updateAllDeckObjects',
    value: function updateAllDeckObjects() {
      this.getAllLayers().forEach(function (layer) {
        if (layer && layer.deckCache) {
          layer.deckCache.updateAllDeckObjects();
        }
      });
      this.forceUpdate();
    }
  }, {
    key: 'updateDeckObjectsByIds',
    value: function updateDeckObjectsByIds(ids) {
      this.getAllLayers().forEach(function (layer) {
        if (layer && layer.deckCache) {
          layer.deckCache.updateDeckObjectsByIds(ids);
        }
      });
      this.forceUpdate();
    }
  }, {
    key: 'rerenderLayers',
    value: function rerenderLayers() {
      this.updateAllDeckObjects();
    }
  }, {
    key: '_isNebulaEvent',
    value: function _isNebulaEvent(_ref2) {
      var buttons = _ref2.buttons,
          target = _ref2.target,
          type = _ref2.type;
      var viewport = this.props.viewport;

      // allow mouseup event aggressively to cancel drag properly
      // TODO: use pointer capture setPointerCapture() to capture mouseup properly after deckgl

      if (this._mouseWasDown && type === 'mouseup') {
        this._mouseWasDown = false;
        return true;
      }

      // allow mousemove event while dragging
      if (type === 'mousemove' && buttons > 0) {
        return true;
      }

      if (!target.getBoundingClientRect) {
        return false;
      }

      var rect = target.getBoundingClientRect();
      // Only listen to events coming from the basemap
      // identified by the canvas of the same size as viewport.
      // Need to round the rect dimension as some monitors
      // have some sub-pixel difference with viewport.
      return Math.round(rect.width) === Math.round(viewport.width) && Math.round(rect.height) === Math.round(viewport.height);
    }
  }, {
    key: 'allowEvent',
    value: function allowEvent(lngLat, event) {
      return true;
    }
  }, {
    key: '_getMouseGroundPosition',
    value: function _getMouseGroundPosition(event) {
      return this.wmViewport.unproject([event.offsetX, event.offsetY]);
    }
  }, {
    key: '_handleDeckGLEvent',
    value: function _handleDeckGLEvent(event) {
      var deckgl = this.deckgl,
          _props = this.props,
          onMapMouseEvent = _props.onMapMouseEvent,
          selectionType = _props.selectionType;

      var sendMapEvent = true;
      var cursor = 'auto';

      if (event && deckgl && selectionType) {
        if (!this._deckDrawer) this._deckDrawer = new _deckDrawer2.default(this);

        var lngLat = this._getMouseGroundPosition(event);
        if (!this.allowEvent(lngLat, event)) return;

        var drawerResult = this._deckDrawer.handleEvent(event, lngLat, selectionType);
        if (drawerResult.redraw) this.forceUpdate();
        return;
      }

      if (event && deckgl && (!event.buttons || event.type !== 'mousemove')) {
        // TODO: sort by mouse priority
        var layerIds = deckgl.props.layers.filter(function (l) {
          return l && l.props && l.props.nebulaLayer && l.props.nebulaLayer.enablePicking;
        }).map(function (l) {
          return l.id;
        });

        var pickingInfo = deckgl.queryObject({
          x: event.offsetX,
          y: event.offsetY,
          radius: 5,
          layerIds: layerIds
        });
        this.queryObjectEvents.emit('pick', { event: event, pickingInfo: pickingInfo });
        if (pickingInfo) {
          sendMapEvent = false;

          var index = pickingInfo.index,
              _lngLat = pickingInfo.lngLat;

          if (!this.allowEvent(_lngLat, event)) return;

          var deckLayer = pickingInfo.layer,
              object = pickingInfo.object;

          var original = object.original || deckLayer.props.nebulaLayer && deckLayer.props.nebulaLayer.deckCache && deckLayer.props.nebulaLayer.deckCache.originals[index];

          if (original) {
            this.deckglMouseOverInfo = { originalLayer: deckLayer.props.nebulaLayer, index: index };
            var nebulaMouseEvent = new _layerMouseEvent2.default(event, {
              data: original,
              metadata: object.metadata,
              groundPoint: _lngLat,
              nebula: this
            });
            deckLayer.props.nebulaLayer.emit(event.type, nebulaMouseEvent);
            this.forceUpdate();
          }

          cursor = 'pointer';
        }
      }

      if (_document2.default.documentElement) {
        _document2.default.documentElement.style.cursor = cursor;
      }

      if (sendMapEvent) {
        this.deckglMouseOverInfo = null;

        var _lngLat2 = this._getMouseGroundPosition(event);
        if (!this.allowEvent(_lngLat2, event)) return;

        // send to layers first
        var _nebulaMouseEvent = new _layerMouseEvent2.default(event, {
          groundPoint: _lngLat2,
          nebula: this
        });
        this.getAllLayers().filter(function (layer) {
          return layer && layer.usesMapEvents;
        }).forEach(function (layer) {
          return layer.emit('mapMouseEvent', _nebulaMouseEvent);
        });

        if (onMapMouseEvent) {
          onMapMouseEvent(event, _lngLat2);
        }
      }
    }
  }, {
    key: 'getExtraDeckLayers',
    value: function getExtraDeckLayers() {
      var result = [];

      if (this._deckDrawer) result.push.apply(result, _toConsumableArray(this._deckDrawer.render()));

      return result;
    }
  }, {
    key: 'renderDeckLayers',
    value: function renderDeckLayers() {
      var _this3 = this;

      return this.getAllLayers().map(function (layer) {
        return layer instanceof _nebulaLayer2.default ? layer.render({ nebula: _this3 }) : layer;
      }).filter(Boolean);
    }
  }, {
    key: 'getAllLayers',
    value: function getAllLayers() {
      var result = [];

      this.props.layers.filter(Boolean).forEach(function (layer) {
        result.push(layer);
        // Only NebulaLayers have helpers, Deck GL layers don't.
        if (layer instanceof _nebulaLayer2.default) {
          result.push.apply(result, _toConsumableArray(layer.helperLayers));
        }
      });

      return result.filter(Boolean);
    }
  }, {
    key: 'getRenderedLayers',
    value: function getRenderedLayers() {
      return [].concat(_toConsumableArray(this.renderDeckLayers()), _toConsumableArray(this.getExtraDeckLayers()));
    }
  }, {
    key: 'updateAndGetRenderedLayers',
    value: function updateAndGetRenderedLayers(layers, viewport, container) {
      if (this.inited) {
        this.updateProps({ layers: layers, viewport: viewport });
        this.forceUpdate = function () {
          return container.forceUpdate();
        };
      } else {
        this.inited = true;
        this.init({ layers: layers, viewport: viewport });
        this.forceUpdate = function () {
          return container.forceUpdate();
        };
        this.updateAllDeckObjects();
      }

      return this.getRenderedLayers();
    }
  }, {
    key: 'setDeck',
    value: function setDeck(deckgl) {
      if (deckgl) {
        this.deckgl = deckgl;
      }
    }
  }]);

  return Nebula;
}();

exports.default = Nebula;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9saWIvbmVidWxhLmpzIl0sIm5hbWVzIjpbIkxPR0dFUl9QUkVGSVgiLCJOZWJ1bGEiLCJxdWVyeU9iamVjdEV2ZW50cyIsIl9vbk1vdXNlRXZlbnQiLCJldmVudCIsIl9pc05lYnVsYUV2ZW50IiwidHlwZSIsIl9tb3VzZVdhc0Rvd24iLCJtYWluQ29udGFpbmVyIiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwidG9wIiwibGVmdCIsInByb3h5RXZlbnQiLCJQcm94eSIsImdldCIsIm9yaWdpbmFsIiwicHJvcGVydHlOYW1lIiwicGFnZVgiLCJwYWdlWSIsInJlcGxhY2UiLCJyZXN1bHQiLCJiaW5kIiwiX2hhbmRsZURlY2tHTEV2ZW50IiwicHJvcHMiLCJwcm9qZWN0b3IiLCJ2aWV3cG9ydCIsIndtVmlld3BvcnQiLCJmb3JFYWNoIiwiYWRkRXZlbnRMaXN0ZW5lciIsIm5hbWUiLCJuZXdQcm9wcyIsInNob3VsZENoYW5nZUNlbnRlciIsImxvZyIsImxvbmdpdHVkZSIsImxhdGl0dWRlIiwic2V0Q2VudGVyRnJvbVZpZXdwb3J0IiwibWVzc2FnZSIsImxvZ2dlciIsImluZm8iLCJnZXRBbGxMYXllcnMiLCJsYXllciIsImRlY2tDYWNoZSIsInVwZGF0ZUFsbERlY2tPYmplY3RzIiwiZm9yY2VVcGRhdGUiLCJpZHMiLCJ1cGRhdGVEZWNrT2JqZWN0c0J5SWRzIiwiYnV0dG9ucyIsInRhcmdldCIsInJlY3QiLCJNYXRoIiwicm91bmQiLCJ3aWR0aCIsImhlaWdodCIsImxuZ0xhdCIsInVucHJvamVjdCIsIm9mZnNldFgiLCJvZmZzZXRZIiwiZGVja2dsIiwib25NYXBNb3VzZUV2ZW50Iiwic2VsZWN0aW9uVHlwZSIsInNlbmRNYXBFdmVudCIsImN1cnNvciIsIl9kZWNrRHJhd2VyIiwiX2dldE1vdXNlR3JvdW5kUG9zaXRpb24iLCJhbGxvd0V2ZW50IiwiZHJhd2VyUmVzdWx0IiwiaGFuZGxlRXZlbnQiLCJyZWRyYXciLCJsYXllcklkcyIsImxheWVycyIsImZpbHRlciIsImwiLCJuZWJ1bGFMYXllciIsImVuYWJsZVBpY2tpbmciLCJtYXAiLCJpZCIsInBpY2tpbmdJbmZvIiwicXVlcnlPYmplY3QiLCJ4IiwieSIsInJhZGl1cyIsImVtaXQiLCJpbmRleCIsImRlY2tMYXllciIsIm9iamVjdCIsIm9yaWdpbmFscyIsImRlY2tnbE1vdXNlT3ZlckluZm8iLCJvcmlnaW5hbExheWVyIiwibmVidWxhTW91c2VFdmVudCIsImRhdGEiLCJtZXRhZGF0YSIsImdyb3VuZFBvaW50IiwibmVidWxhIiwiZG9jdW1lbnRFbGVtZW50Iiwic3R5bGUiLCJ1c2VzTWFwRXZlbnRzIiwicHVzaCIsInJlbmRlciIsIkJvb2xlYW4iLCJoZWxwZXJMYXllcnMiLCJyZW5kZXJEZWNrTGF5ZXJzIiwiZ2V0RXh0cmFEZWNrTGF5ZXJzIiwiY29udGFpbmVyIiwiaW5pdGVkIiwidXBkYXRlUHJvcHMiLCJpbml0IiwiZ2V0UmVuZGVyZWRMYXllcnMiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7O0FBRUE7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7Ozs7Ozs7QUFFQSxJQUFNQSxnQkFBZ0IsVUFBdEI7O0lBRXFCQyxNOzs7Ozs7U0FrQ25CQyxpQixHQUFrQyxzQjs7U0ErRGxDQyxhLEdBQWdCLFVBQUNDLEtBQUQsRUFBOEI7QUFDNUMsVUFBSSxDQUFDLE1BQUtDLGNBQUwsQ0FBb0JELEtBQXBCLENBQUwsRUFBaUM7QUFDL0I7QUFDRDs7QUFFRCxVQUFJQSxNQUFNRSxJQUFOLEtBQWUsV0FBbkIsRUFBZ0M7QUFDOUIsY0FBS0MsYUFBTCxHQUFxQixJQUFyQjtBQUNEOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQVo0QyxpQkFhZCxNQUFLQyxhQUFMLEdBQzFCLE1BQUtBLGFBQUwsQ0FBbUJDLHFCQUFuQixFQUQwQixHQUUxQixFQWZ3QztBQUFBLDBCQWFwQ0MsR0Fib0M7QUFBQSxVQWFwQ0EsR0Fib0MsNEJBYTlCLENBYjhC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RW1pdHRlciBmcm9tICdldmVudHMnO1xuaW1wb3J0IGRvY3VtZW50IGZyb20gJ2dsb2JhbC9kb2N1bWVudCc7XG5pbXBvcnQgd2luZG93IGZyb20gJ2dsb2JhbC93aW5kb3cnO1xuaW1wb3J0IHsgV2ViTWVyY2F0b3JWaWV3cG9ydCB9IGZyb20gJ2RlY2suZ2wnO1xuXG5pbXBvcnQgRGVja0RyYXdlciBmcm9tICcuL2RlY2stcmVuZGVyZXIvZGVjay1kcmF3ZXInO1xuaW1wb3J0IExheWVyTW91c2VFdmVudCBmcm9tICcuL2xheWVyLW1vdXNlLWV2ZW50JztcbmltcG9ydCBQcm9qZWN0b3IgZnJvbSAnLi9wcm9qZWN0b3InO1xuaW1wb3J0IE5lYnVsYUxheWVyIGZyb20gJy4vbmVidWxhLWxheWVyJztcblxuY29uc3QgTE9HR0VSX1BSRUZJWCA9ICdOZWJ1bGE6ICc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE5lYnVsYSB7XG4gIGluaXQocHJvcHM6IE9iamVjdCkge1xuICAgIHRoaXMucHJvcHMgPSBwcm9wcztcbiAgICB0aGlzLnByb2plY3RvciA9IG5ldyBQcm9qZWN0b3IodGhpcy5wcm9wcy52aWV3cG9ydCk7XG4gICAgdGhpcy53bVZpZXdwb3J0ID0gbmV3IFdlYk1lcmNhdG9yVmlld3BvcnQodGhpcy5wcm9wcy52aWV3cG9ydCk7XG5cbiAgICAvLyBUT0RPOiBQcm9wZXJseSB1c2UgcG9pbnRlciBldmVudHNcbiAgICAvLyBbJ2NsaWNrJywgJ2RibGNsaWNrJywgJ21vdXNlbW92ZScsICdtb3VzZXVwJywgJ21vdXNlZG93biddLmZvckVhY2gobmFtZSA9PlxuICAgIFsnY2xpY2snLCAnZGJsY2xpY2snLCAncG9pbnRlcm1vdmUnLCAncG9pbnRlcnVwJywgJ3BvaW50ZXJkb3duJ10uZm9yRWFjaChuYW1lID0+XG4gICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKG5hbWUsIHRoaXMuX29uTW91c2VFdmVudCwgdHJ1ZSlcbiAgICApO1xuICB9XG5cbiAgdXBkYXRlUHJvcHMobmV3UHJvcHM6IE9iamVjdCkge1xuICAgIHRoaXMucHJvcHMgPSBuZXdQcm9wcztcbiAgICBjb25zdCB7IHZpZXdwb3J0IH0gPSB0aGlzLnByb3BzO1xuICAgIGNvbnN0IHsgcHJvamVjdG9yIH0gPSB0aGlzO1xuXG4gICAgaWYgKHByb2plY3Rvci5zaG91bGRDaGFuZ2VDZW50ZXIodmlld3BvcnQpKSB7XG4gICAgICB0aGlzLmxvZyhgQ2hhbmdpbmcgY2VudGVyIHRvIFske3ZpZXdwb3J0LmxvbmdpdHVkZX0sICR7dmlld3BvcnQubGF0aXR1ZGV9XWApO1xuICAgICAgcHJvamVjdG9yLnNldENlbnRlckZyb21WaWV3cG9ydCh2aWV3cG9ydCk7XG4gICAgfVxuXG4gICAgdGhpcy53bVZpZXdwb3J0ID0gbmV3IFdlYk1lcmNhdG9yVmlld3BvcnQodmlld3BvcnQpO1xuICB9XG5cbiAgcHJvcHM6IE9iamVjdDtcbiAgcHJvamVjdG9yOiBQcm9qZWN0b3I7XG4gIGRlY2tnbDogT2JqZWN0IHwgbnVsbDtcbiAgbWFpbkNvbnRhaW5lcjogT2JqZWN0IHwgbnVsbDtcbiAgZGVja2dsTW91c2VPdmVySW5mbzogP09iamVjdDtcbiAgX2RlY2tEcmF3ZXI6IERlY2tEcmF3ZXI7XG4gIF9tb3VzZVdhc0Rvd246IGJvb2xlYW47XG4gIHdtVmlld3BvcnQ6IFdlYk1lcmNhdG9yVmlld3BvcnQ7XG4gIHF1ZXJ5T2JqZWN0RXZlbnRzOiBFdmVudEVtaXR0ZXIgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gIGZvcmNlVXBkYXRlOiBGdW5jdGlvbjtcbiAgaW5pdGVkOiBib29sZWFuO1xuXG4gIGxvZyhtZXNzYWdlOiBzdHJpbmcpIHtcbiAgICBjb25zdCB7IGxvZ2dlciB9ID0gdGhpcy5wcm9wcztcbiAgICBpZiAobG9nZ2VyICYmIGxvZ2dlci5pbmZvKSB7XG4gICAgICBsb2dnZXIuaW5mbyhMT0dHRVJfUFJFRklYICsgbWVzc2FnZSk7XG4gICAgfVxuICB9XG5cbiAgdXBkYXRlQWxsRGVja09iamVjdHMoKSB7XG4gICAgdGhpcy5nZXRBbGxMYXllcnMoKS5mb3JFYWNoKGxheWVyID0+IHtcbiAgICAgIGlmIChsYXllciAmJiBsYXllci5kZWNrQ2FjaGUpIHtcbiAgICAgICAgKGxheWVyLmRlY2tDYWNoZTogYW55KS51cGRhdGVBbGxEZWNrT2JqZWN0cygpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuZm9yY2VVcGRhdGUoKTtcbiAgfVxuXG4gIHVwZGF0ZURlY2tPYmplY3RzQnlJZHMoaWRzOiBzdHJpbmdbXSkge1xuICAgIHRoaXMuZ2V0QWxsTGF5ZXJzKCkuZm9yRWFjaChsYXllciA9PiB7XG4gICAgICBpZiAobGF5ZXIgJiYgbGF5ZXIuZGVja0NhY2hlKSB7XG4gICAgICAgIChsYXllci5kZWNrQ2FjaGU6IGFueSkudXBkYXRlRGVja09iamVjdHNCeUlkcyhpZHMpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuZm9yY2VVcGRhdGUoKTtcbiAgfVxuXG4gIHJlcmVuZGVyTGF5ZXJzKCkge1xuICAgIHRoaXMudXBkYXRlQWxsRGVja09iamVjdHMoKTtcbiAgfVxuXG4gIF9pc05lYnVsYUV2ZW50KHsgYnV0dG9ucywgdGFyZ2V0LCB0eXBlIH06IE9iamVjdCkge1xuICAgIGNvbnN0IHsgdmlld3BvcnQgfSA9IHRoaXMucHJvcHM7XG5cbiAgICAvLyBhbGxvdyBtb3VzZXVwIGV2ZW50IGFnZ3Jlc3NpdmVseSB0byBjYW5jZWwgZHJhZyBwcm9wZXJseVxuICAgIC8vIFRPRE86IHVzZSBwb2ludGVyIGNhcHR1cmUgc2V0UG9pbnRlckNhcHR1cmUoKSB0byBjYXB0dXJlIG1vdXNldXAgcHJvcGVybHkgYWZ0ZXIgZGVja2dsXG4gICAgaWYgKHRoaXMuX21vdXNlV2FzRG93biAmJiB0eXBlID09PSAnbW91c2V1cCcpIHtcbiAgICAgIHRoaXMuX21vdXNlV2FzRG93biA9IGZhbHNlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLy8gYWxsb3cgbW91c2Vtb3ZlIGV2ZW50IHdoaWxlIGRyYWdnaW5nXG4gICAgaWYgKHR5cGUgPT09ICdtb3VzZW1vdmUnICYmIGJ1dHRvbnMgPiAwKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoIXRhcmdldC5nZXRCb3VuZGluZ0NsaWVudFJlY3QpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBjb25zdCByZWN0ID0gdGFyZ2V0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIC8vIE9ubHkgbGlzdGVuIHRvIGV2ZW50cyBjb21pbmcgZnJvbSB0aGUgYmFzZW1hcFxuICAgIC8vIGlkZW50aWZpZWQgYnkgdGhlIGNhbnZhcyBvZiB0aGUgc2FtZSBzaXplIGFzIHZpZXdwb3J0LlxuICAgIC8vIE5lZWQgdG8gcm91bmQgdGhlIHJlY3QgZGltZW5zaW9uIGFzIHNvbWUgbW9uaXRvcnNcbiAgICAvLyBoYXZlIHNvbWUgc3ViLXBpeGVsIGRpZmZlcmVuY2Ugd2l0aCB2aWV3cG9ydC5cbiAgICByZXR1cm4gKFxuICAgICAgTWF0aC5yb3VuZChyZWN0LndpZHRoKSA9PT0gTWF0aC5yb3VuZCh2aWV3cG9ydC53aWR0aCkgJiZcbiAgICAgIE1hdGgucm91bmQocmVjdC5oZWlnaHQpID09PSBNYXRoLnJvdW5kKHZpZXdwb3J0LmhlaWdodClcbiAgICApO1xuICB9XG5cbiAgX29uTW91c2VFdmVudCA9IChldmVudDogd2luZG93Lk1vdXNlRXZlbnQpID0+IHtcbiAgICBpZiAoIXRoaXMuX2lzTmVidWxhRXZlbnQoZXZlbnQpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGV2ZW50LnR5cGUgPT09ICdtb3VzZWRvd24nKSB7XG4gICAgICB0aGlzLl9tb3VzZVdhc0Rvd24gPSB0cnVlO1xuICAgIH1cblxuICAgIC8vIG9mZnNldFgvWSBvZiB0aGUgTW91c2VFdmVudCBwcm92aWRlcyB0aGUgb2Zmc2V0IGluIHRoZSBYL1kgY29vcmRpbmF0ZVxuICAgIC8vIG9mIHRoZSBtb3VzZSBwb2ludGVyIGJldHdlZW4gdGhhdCBldmVudCBhbmQgdGhlIHBhZGRpbmcgZWRnZSBvZiB0aGUgdGFyZ2V0IG5vZGUuXG4gICAgLy8gV2Ugc2V0IG91ciBsaXN0ZW5lciB0byBkb2N1bWVudCBzbyB3ZSBuZWVkIHRvIGFkanVzdCBvZmZzZXRYL1lcbiAgICAvLyBpbiBjYXNlIHRoZSB0YXJnZXQgaXMgbm90IGJlIG91ciBXZWJHTCBjYW52YXMuXG4gICAgY29uc3QgeyB0b3AgPSAwLCBsZWZ0ID0gMCB9ID0gdGhpcy5tYWluQ29udGFpbmVyXG4gICAgICA/IHRoaXMubWFpbkNvbnRhaW5lci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxuICAgICAgOiB7fTtcbiAgICBjb25zdCBwcm94eUV2ZW50ID0gbmV3IFByb3h5KGV2ZW50LCB7XG4gICAgICBnZXQ6IChvcmlnaW5hbDogYW55LCBwcm9wZXJ0eU5hbWU6IHN0cmluZykgPT4ge1xuICAgICAgICBpZiAocHJvcGVydHlOYW1lID09PSAnb2Zmc2V0WCcpIHtcbiAgICAgICAgICByZXR1cm4gb3JpZ2luYWwucGFnZVggLSBsZWZ0O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHByb3BlcnR5TmFtZSA9PT0gJ29mZnNldFknKSB7XG4gICAgICAgICAgcmV0dXJuIG9yaWdpbmFsLnBhZ2VZIC0gdG9wO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVE9ETzogUHJvcGVybHkgdXNlIHBvaW50ZXIgZXZlbnRzXG4gICAgICAgIGlmIChwcm9wZXJ0eU5hbWUgPT09ICd0eXBlJykge1xuICAgICAgICAgIHJldHVybiBvcmlnaW5hbC50eXBlLnJlcGxhY2UoJ3BvaW50ZXInLCAnbW91c2UnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IG9yaWdpbmFsW3Byb3BlcnR5TmFtZV07XG4gICAgICAgIGlmICh0eXBlb2YgcmVzdWx0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdC5iaW5kKG9yaWdpbmFsKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdGhpcy5faGFuZGxlRGVja0dMRXZlbnQocHJveHlFdmVudCk7XG4gIH07XG5cbiAgYWxsb3dFdmVudChsbmdMYXQ6IFtudW1iZXIsIG51bWJlcl0sIGV2ZW50OiBPYmplY3QpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIF9nZXRNb3VzZUdyb3VuZFBvc2l0aW9uKGV2ZW50OiBPYmplY3QpIHtcbiAgICByZXR1cm4gdGhpcy53bVZpZXdwb3J0LnVucHJvamVjdChbZXZlbnQub2Zmc2V0WCwgZXZlbnQub2Zmc2V0WV0pO1xuICB9XG5cbiAgX2hhbmRsZURlY2tHTEV2ZW50KGV2ZW50OiBPYmplY3QpIHtcbiAgICBjb25zdCB7IGRlY2tnbCwgcHJvcHM6IHsgb25NYXBNb3VzZUV2ZW50LCBzZWxlY3Rpb25UeXBlIH0gfSA9IHRoaXM7XG4gICAgbGV0IHNlbmRNYXBFdmVudCA9IHRydWU7XG4gICAgbGV0IGN1cnNvciA9ICdhdXRvJztcblxuICAgIGlmIChldmVudCAmJiBkZWNrZ2wgJiYgc2VsZWN0aW9uVHlwZSkge1xuICAgICAgaWYgKCF0aGlzLl9kZWNrRHJhd2VyKSB0aGlzLl9kZWNrRHJhd2VyID0gbmV3IERlY2tEcmF3ZXIodGhpcyk7XG5cbiAgICAgIGNvbnN0IGxuZ0xhdCA9IHRoaXMuX2dldE1vdXNlR3JvdW5kUG9zaXRpb24oZXZlbnQpO1xuICAgICAgaWYgKCF0aGlzLmFsbG93RXZlbnQobG5nTGF0LCBldmVudCkpIHJldHVybjtcblxuICAgICAgY29uc3QgZHJhd2VyUmVzdWx0ID0gdGhpcy5fZGVja0RyYXdlci5oYW5kbGVFdmVudChldmVudCwgbG5nTGF0LCBzZWxlY3Rpb25UeXBlKTtcbiAgICAgIGlmIChkcmF3ZXJSZXN1bHQucmVkcmF3KSB0aGlzLmZvcmNlVXBkYXRlKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGV2ZW50ICYmIGRlY2tnbCAmJiAoIWV2ZW50LmJ1dHRvbnMgfHwgZXZlbnQudHlwZSAhPT0gJ21vdXNlbW92ZScpKSB7XG4gICAgICAvLyBUT0RPOiBzb3J0IGJ5IG1vdXNlIHByaW9yaXR5XG4gICAgICBjb25zdCBsYXllcklkcyA9IGRlY2tnbC5wcm9wcy5sYXllcnNcbiAgICAgICAgLmZpbHRlcihsID0+IGwgJiYgbC5wcm9wcyAmJiBsLnByb3BzLm5lYnVsYUxheWVyICYmIGwucHJvcHMubmVidWxhTGF5ZXIuZW5hYmxlUGlja2luZylcbiAgICAgICAgLm1hcChsID0+IGwuaWQpO1xuXG4gICAgICBjb25zdCBwaWNraW5nSW5mbyA9IGRlY2tnbC5xdWVyeU9iamVjdCh7XG4gICAgICAgIHg6IGV2ZW50Lm9mZnNldFgsXG4gICAgICAgIHk6IGV2ZW50Lm9mZnNldFksXG4gICAgICAgIHJhZGl1czogNSxcbiAgICAgICAgbGF5ZXJJZHNcbiAgICAgIH0pO1xuICAgICAgdGhpcy5xdWVyeU9iamVjdEV2ZW50cy5lbWl0KCdwaWNrJywgeyBldmVudCwgcGlja2luZ0luZm8gfSk7XG4gICAgICBpZiAocGlja2luZ0luZm8pIHtcbiAgICAgICAgc2VuZE1hcEV2ZW50ID0gZmFsc2U7XG5cbiAgICAgICAgY29uc3QgeyBpbmRleCwgbG5nTGF0IH0gPSBwaWNraW5nSW5mbztcbiAgICAgICAgaWYgKCF0aGlzLmFsbG93RXZlbnQobG5nTGF0LCBldmVudCkpIHJldHVybjtcblxuICAgICAgICBjb25zdCB7IGxheWVyOiBkZWNrTGF5ZXIsIG9iamVjdCB9ID0gcGlja2luZ0luZm87XG4gICAgICAgIGNvbnN0IG9yaWdpbmFsID1cbiAgICAgICAgICBvYmplY3Qub3JpZ2luYWwgfHxcbiAgICAgICAgICAoZGVja0xheWVyLnByb3BzLm5lYnVsYUxheWVyICYmXG4gICAgICAgICAgICBkZWNrTGF5ZXIucHJvcHMubmVidWxhTGF5ZXIuZGVja0NhY2hlICYmXG4gICAgICAgICAgICBkZWNrTGF5ZXIucHJvcHMubmVidWxhTGF5ZXIuZGVja0NhY2hlLm9yaWdpbmFsc1tpbmRleF0pO1xuXG4gICAgICAgIGlmIChvcmlnaW5hbCkge1xuICAgICAgICAgIHRoaXMuZGVja2dsTW91c2VPdmVySW5mbyA9IHsgb3JpZ2luYWxMYXllcjogZGVja0xheWVyLnByb3BzLm5lYnVsYUxheWVyLCBpbmRleCB9O1xuICAgICAgICAgIGNvbnN0IG5lYnVsYU1vdXNlRXZlbnQgPSBuZXcgTGF5ZXJNb3VzZUV2ZW50KGV2ZW50LCB7XG4gICAgICAgICAgICBkYXRhOiBvcmlnaW5hbCxcbiAgICAgICAgICAgIG1ldGFkYXRhOiBvYmplY3QubWV0YWRhdGEsXG4gICAgICAgICAgICBncm91bmRQb2ludDogbG5nTGF0LFxuICAgICAgICAgICAgbmVidWxhOiB0aGlzXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZGVja0xheWVyLnByb3BzLm5lYnVsYUxheWVyLmVtaXQoZXZlbnQudHlwZSwgbmVidWxhTW91c2VFdmVudCk7XG4gICAgICAgICAgdGhpcy5mb3JjZVVwZGF0ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgY3Vyc29yID0gJ3BvaW50ZXInO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpIHtcbiAgICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZS5jdXJzb3IgPSBjdXJzb3I7XG4gICAgfVxuXG4gICAgaWYgKHNlbmRNYXBFdmVudCkge1xuICAgICAgdGhpcy5kZWNrZ2xNb3VzZU92ZXJJbmZvID0gbnVsbDtcblxuICAgICAgY29uc3QgbG5nTGF0ID0gdGhpcy5fZ2V0TW91c2VHcm91bmRQb3NpdGlvbihldmVudCk7XG4gICAgICBpZiAoIXRoaXMuYWxsb3dFdmVudChsbmdMYXQsIGV2ZW50KSkgcmV0dXJuO1xuXG4gICAgICAvLyBzZW5kIHRvIGxheWVycyBmaXJzdFxuICAgICAgY29uc3QgbmVidWxhTW91c2VFdmVudCA9IG5ldyBMYXllck1vdXNlRXZlbnQoZXZlbnQsIHtcbiAgICAgICAgZ3JvdW5kUG9pbnQ6IGxuZ0xhdCxcbiAgICAgICAgbmVidWxhOiB0aGlzXG4gICAgICB9KTtcbiAgICAgIHRoaXMuZ2V0QWxsTGF5ZXJzKClcbiAgICAgICAgLmZpbHRlcihsYXllciA9PiBsYXllciAmJiBsYXllci51c2VzTWFwRXZlbnRzKVxuICAgICAgICAuZm9yRWFjaChsYXllciA9PiBsYXllci5lbWl0KCdtYXBNb3VzZUV2ZW50JywgbmVidWxhTW91c2VFdmVudCkpO1xuXG4gICAgICBpZiAob25NYXBNb3VzZUV2ZW50KSB7XG4gICAgICAgIG9uTWFwTW91c2VFdmVudChldmVudCwgbG5nTGF0KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBnZXRFeHRyYURlY2tMYXllcnMoKTogT2JqZWN0W10ge1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuXG4gICAgaWYgKHRoaXMuX2RlY2tEcmF3ZXIpIHJlc3VsdC5wdXNoKC4uLnRoaXMuX2RlY2tEcmF3ZXIucmVuZGVyKCkpO1xuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIHJlbmRlckRlY2tMYXllcnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0QWxsTGF5ZXJzKClcbiAgICAgIC5tYXAobGF5ZXIgPT4gKGxheWVyIGluc3RhbmNlb2YgTmVidWxhTGF5ZXIgPyBsYXllci5yZW5kZXIoeyBuZWJ1bGE6IHRoaXMgfSkgOiBsYXllcikpXG4gICAgICAuZmlsdGVyKEJvb2xlYW4pO1xuICB9XG5cbiAgZ2V0QWxsTGF5ZXJzKCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuXG4gICAgdGhpcy5wcm9wcy5sYXllcnMuZmlsdGVyKEJvb2xlYW4pLmZvckVhY2gobGF5ZXIgPT4ge1xuICAgICAgcmVzdWx0LnB1c2gobGF5ZXIpO1xuICAgICAgLy8gT25seSBOZWJ1bGFMYXllcnMgaGF2ZSBoZWxwZXJzLCBEZWNrIEdMIGxheWVycyBkb24ndC5cbiAgICAgIGlmIChsYXllciBpbnN0YW5jZW9mIE5lYnVsYUxheWVyKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKC4uLmxheWVyLmhlbHBlckxheWVycyk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gcmVzdWx0LmZpbHRlcihCb29sZWFuKTtcbiAgfVxuXG4gIGdldFJlbmRlcmVkTGF5ZXJzKCkge1xuICAgIHJldHVybiBbLi4udGhpcy5yZW5kZXJEZWNrTGF5ZXJzKCksIC4uLnRoaXMuZ2V0RXh0cmFEZWNrTGF5ZXJzKCldO1xuICB9XG5cbiAgdXBkYXRlQW5kR2V0UmVuZGVyZWRMYXllcnMobGF5ZXJzOiBPYmplY3RbXSwgdmlld3BvcnQ6IFdlYk1lcmNhdG9yVmlld3BvcnQsIGNvbnRhaW5lcjogT2JqZWN0KSB7XG4gICAgaWYgKHRoaXMuaW5pdGVkKSB7XG4gICAgICB0aGlzLnVwZGF0ZVByb3BzKHsgbGF5ZXJzLCB2aWV3cG9ydCB9KTtcbiAgICAgIHRoaXMuZm9yY2VVcGRhdGUgPSAoKSA9PiBjb250YWluZXIuZm9yY2VVcGRhdGUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5pbml0ZWQgPSB0cnVlO1xuICAgICAgdGhpcy5pbml0KHsgbGF5ZXJzLCB2aWV3cG9ydCB9KTtcbiAgICAgIHRoaXMuZm9yY2VVcGRhdGUgPSAoKSA9PiBjb250YWluZXIuZm9yY2VVcGRhdGUoKTtcbiAgICAgIHRoaXMudXBkYXRlQWxsRGVja09iamVjdHMoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5nZXRSZW5kZXJlZExheWVycygpO1xuICB9XG5cbiAgc2V0RGVjayhkZWNrZ2w6IE9iamVjdCB8IG51bGwpIHtcbiAgICBpZiAoZGVja2dsKSB7XG4gICAgICB0aGlzLmRlY2tnbCA9IGRlY2tnbDtcbiAgICB9XG4gIH1cbn1cbiJdfQ==