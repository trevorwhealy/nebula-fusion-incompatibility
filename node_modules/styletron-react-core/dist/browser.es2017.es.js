import React, { Component, createElement } from 'react';
import createReactContext from 'create-react-context';

/* eslint-env browser */

/* global module */
function addDebugMetadata(instance, stackIndex) {
  const {
    stack,
    stacktrace,
    message
  } = new Error("stacktrace source");
  instance.debugStackInfo = {
    stack,
    stacktrace,
    message
  };
  instance.debugStackIndex = stackIndex;
}
class DebugEngine {
  constructor(worker) {
    if (!worker) {
      const workerBlob = new Blob([`importScripts("https://unpkg.com/css-to-js-sourcemap-worker@2.0.1/worker.js")`], {
        type: "application/javascript"
      });
      worker = new Worker(URL.createObjectURL(workerBlob));
      worker.postMessage({
        id: "init_wasm",
        url: "https://unpkg.com/css-to-js-sourcemap-worker@2.0.1/mappings.wasm"
      });
      worker.postMessage({
        id: "set_render_interval",
        interval: 120
      });

      if (module.hot) {
        module.hot.addStatusHandler(status => {
          if (status === "dispose") {
            worker.postMessage({
              id: "invalidate"
            });
          }
        });
      }
    }

    this.worker = worker;
    this.counter = 0;

    this.worker.onmessage = msg => {
      const {
        id,
        css
      } = msg.data;

      if (id === "render_css" && css) {
        const style = document.createElement("style");
        style.appendChild(document.createTextNode(css));
        document.head.appendChild(style);
      }
    };
  }

  debug({
    stackIndex,
    stackInfo
  }) {
    const className = `__debug-${this.counter++}`;
    this.worker.postMessage({
      id: "add_mapped_class",
      className,
      stackInfo,
      stackIndex
    });
    return className;
  }

}

const StyletronContext = createReactContext();
const HydrationContext = createReactContext(false);
const DebugEngineContext = createReactContext();

class DevProvider extends Component {
  constructor(props) {
    super();
    this.state = {
      hydrating: Boolean(props.debugAfterHydration)
    };
  }

  componentDidMount() {
    {
      if (this.state.hydrating === true) {
        this.setState({
          hydrating: false
        });
      }
    }
  }

  render() {
    return React.createElement(StyletronContext.Provider, {
      value: this.props.value
    }, React.createElement(DebugEngineContext.Provider, {
      value: this.props.debug
    }, React.createElement(HydrationContext.Provider, {
      value: this.state.hydrating
    }, this.props.children)));
  }

}

const Provider = true && process.env.NODE_ENV !== "production" ? DevProvider : StyletronContext.Provider;
function DevConsumer(props) {
  return React.createElement(StyletronContext.Consumer, null, styletronEngine => React.createElement(DebugEngineContext.Consumer, null, debugEngine => React.createElement(HydrationContext.Consumer, null, hydrating => props.children(styletronEngine, debugEngine, hydrating))));
}
const Consumer = true && process.env.NODE_ENV !== "production" ? DevConsumer : StyletronContext.Consumer;
function createStyled({
  getInitialStyle,
  driver,
  wrapper
}) {
  return function styled(base, styleArg) {
    const baseStyletron = {
      reducers: [],
      // TODO: use typed generic instead of coercion once
      // https://github.com/facebook/flow/issues/6157 is resolved
      base: base,
      driver,
      getInitialStyle,
      wrapper
    };

    if (true && process.env.NODE_ENV !== "production") {
      addDebugMetadata(baseStyletron, 2);
    }

    return createStyledElementComponent(autoComposeShallow(baseStyletron, styleArg));
  };
}
function withTransform(component, transformer) {
  const styletron = component.__STYLETRON__;

  if (true && process.env.NODE_ENV !== "production") {
    addDebugMetadata(styletron, 2);
  }

  return createStyledElementComponent(composeDynamic(styletron, {
    assignCommutative: false,
    reducer: transformer
  }));
}
function withStyle(component, styleArg) {
  const styletron = component.__STYLETRON__;

  if (true && process.env.NODE_ENV !== "production") {
    addDebugMetadata(styletron, 2);
  }

  return createStyledElementComponent(autoComposeShallow(styletron, styleArg));
}
function withStyleDeep(component, styleArg) {
  const styletron = component.__STYLETRON__;

  if (true && process.env.NODE_ENV !== "production") {
    addDebugMetadata(styletron, 2);
  }

  return createStyledElementComponent(autoComposeDeep(styletron, styleArg));
}
function withWrapper(component, wrapper) {
  const styletron = component.__STYLETRON__;
  const composed = {
    getInitialStyle: styletron.getInitialStyle,
    base: styletron.base,
    driver: styletron.driver,
    wrapper: wrapper,
    reducers: styletron.reducers
  };

  if (true && process.env.NODE_ENV !== "production") {
    addDebugMetadata(composed, 2);
  }

  return createStyledElementComponent(composed);
}
function autoComposeShallow(styletron, styleArg) {
  if (typeof styleArg === "function") {
    return dynamicComposeShallow(styletron, styleArg);
  } // TODO: investigate how to eliminate this casting


  return staticComposeShallow(styletron, styleArg);
}
function autoComposeDeep(styletron, styleArg) {
  if (typeof styleArg === "function") {
    return dynamicComposeDeep(styletron, styleArg);
  } // TODO: investigate how to eliminate this casting


  return staticComposeDeep(styletron, styleArg);
}
function staticComposeShallow(styletron, style) {
  return composeStatic(styletron, {
    reducer: createShallowMergeReducer(style),
    assignCommutative: true
  });
}
function staticComposeDeep(styletron, style) {
  return composeStatic(styletron, {
    reducer: createDeepMergeReducer(style),
    assignCommutative: true
  });
}
function dynamicComposeShallow(styletron, styleFn) {
  return composeDynamic(styletron, {
    assignCommutative: false,
    reducer: toMergeReducer(styleFn, shallowMerge)
  });
}
function dynamicComposeDeep(styletron, styleFn) {
  return composeDynamic(styletron, {
    assignCommutative: false,
    reducer: toMergeReducer(styleFn, deepMerge)
  });
}
function toMergeReducer(fn, mergeFn) {
  return (style, props) => mergeFn(style, fn(props));
}
function createShallowMergeReducer(style) {
  // TODO: make this casting unnecessary
  function shallowMergeReducer(inputStyle) {
    return shallowMerge(inputStyle, style);
  }

  shallowMergeReducer.factory = createShallowMergeReducer;
  shallowMergeReducer.style = style;
  return shallowMergeReducer;
}
function createDeepMergeReducer(style) {
  // TODO: make this casting unnecessary
  function deepMergeReducer(inputStyle) {
    return deepMerge(inputStyle, style);
  }

  deepMergeReducer.factory = createDeepMergeReducer;
  deepMergeReducer.style = style;
  return deepMergeReducer;
}
function composeStatic(styletron, reducer) {
  if (styletron.reducers.length === 0) {
    // TODO: remove this casting
    const style = reducer.reducer(styletron.getInitialStyle(), {});
    return {
      reducers: styletron.reducers,
      base: styletron.base,
      driver: styletron.driver,
      debugStackIndex: styletron.debugStackIndex,
      debugStackInfo: styletron.debugStackInfo,
      wrapper: styletron.wrapper,
      getInitialStyle: () => style
    };
  } else {
    const last = styletron.reducers[0];

    if (last.assignCommutative === true && reducer.assignCommutative === true) {
      // TODO: remove prop argument for static reducers
      const composed = reducer.reducer(last.reducer.style, {});
      return {
        getInitialStyle: styletron.getInitialStyle,
        base: styletron.base,
        debugStackIndex: styletron.debugStackIndex,
        debugStackInfo: styletron.debugStackInfo,
        driver: styletron.driver,
        wrapper: styletron.wrapper,
        reducers: [{
          assignCommutative: true,
          reducer: last.reducer.factory(composed)
        }].concat(styletron.reducers.slice(1))
      };
    }

    return composeDynamic(styletron, reducer);
  }
}
function composeDynamic(styletron, reducer) {
  return {
    getInitialStyle: styletron.getInitialStyle,
    base: styletron.base,
    debugStackIndex: styletron.debugStackIndex,
    debugStackInfo: styletron.debugStackInfo,
    driver: styletron.driver,
    wrapper: styletron.wrapper,
    reducers: [reducer].concat(styletron.reducers)
  };
}
function createStyledElementComponent({
  reducers,
  base,
  driver,
  debugStackInfo,
  debugStackIndex,
  wrapper,
  getInitialStyle
}) {
  // TODO: make casting not necessary
  function omitPrefixedKeys(source) {
    const result = {};

    for (const key in source) {
      if (key[0] !== "$") {
        result[key] = source[key];
      }
    }

    return result;
  }

  if (process.env.NODE_ENV !== "production" && true) {
    var debugClassName;
  }

  function StyledElement(props) {
    return React.createElement(Consumer, null, (styletron, debugEngine, hydrating) => {
      if (process.env.NODE_ENV !== "production" && styletron === void 0) {
        throw new Error(`
A Styletron styled component was rendered, but no Styletron engine instance was provided in React context.

Did you forget to provide a Styletron engine instance to React context via using the Styletron provider component?

Note: Providers and Consumers must come from the exact same React.createContext call to work.
If your app has multiple instances of the "styletron-react-core" package in your node_module tree,
your Provider may be coming from a different React.createContext call, which means the styled components
will not recieve the provided engine instance. This scenario can arise, for example, when using "npm link".
`);
      }

      const elementProps = omitPrefixedKeys(props);
      const style = resolveStyle(getInitialStyle, reducers, props);
      const styleClassString = driver(style, styletron);
      const element = props.$as ? props.$as : base;
      elementProps.className = props.className ? `${props.className} ${styleClassString}` : styleClassString;

      if (process.env.NODE_ENV !== "production" && true && debugEngine && !hydrating) {
        if (!debugClassName) {
          debugClassName = debugEngine.debug({
            stackInfo: debugStackInfo,
            stackIndex: debugStackIndex
          });
        }

        const joined = `${debugClassName} ${elementProps.className}`;
        elementProps.className = joined;
      }

      if (props.$ref) {
        elementProps.ref = props.$ref;
      }

      return createElement(element, elementProps);
    });
  }

  const Wrapped = wrapper(StyledElement);
  Wrapped.__STYLETRON__ = {
    base,
    reducers,
    driver,
    wrapper,
    getInitialStyle
  };

  if (process.env.NODE_ENV !== "production") {
    let displayName;

    if (typeof base === "string") {
      displayName = base;
    } else if (base.displayName) {
      displayName = base.displayName;
    } else if (base.name) {
      displayName = base.name;
    } else {
      displayName = "Unknown";
    }

    Wrapped.displayName = `Styled(${displayName})`;
  }

  return Wrapped;
}
function resolveStyle(getInitialStyle, reducers, props) {
  let result = getInitialStyle();
  let i = reducers.length;

  while (i--) {
    result = reducers[i].reducer(result, props);
  }

  return result;
}
function isObject(x) {
  return typeof x === "object" && x !== null;
}
function deepMerge(a, b) {
  const result = assign({}, a);

  for (const key in b) {
    const val = b[key];

    if (isObject(val) && isObject(a[key])) {
      result[key] = deepMerge(a[key], val);
    } else {
      result[key] = val;
    }
  } // TODO: make this casting unecessary


  return result;
}
function shallowMerge(a, b) {
  // TODO: make this casting unecessary
  return assign(assign({}, a), b);
}
function assign(target, source) {
  for (const key in source) {
    target[key] = source[key];
  }

  return target;
}

export { DebugEngine, Provider, DevConsumer, createStyled, withTransform, withStyle, withStyleDeep, withWrapper, autoComposeShallow, autoComposeDeep, staticComposeShallow, staticComposeDeep, dynamicComposeShallow, dynamicComposeDeep, toMergeReducer, createShallowMergeReducer, createDeepMergeReducer, composeStatic, composeDynamic, createStyledElementComponent, resolveStyle, isObject, deepMerge, shallowMerge, assign };
//# sourceMappingURL=browser.es2017.es.js.map
