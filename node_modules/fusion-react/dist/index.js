'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var React = require('react');
var React__default = _interopDefault(React);
var PropTypes = _interopDefault(require('prop-types'));
var reactIs = require('react-is');
var server = require('react-dom/server');
var FusionApp = require('fusion-core');
var FusionApp__default = _interopDefault(FusionApp);

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
const REACT_PREPARE = '@__REACT_PREPARE__@';

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
const prepared = (sideEffect, opts = {}) => OriginalComponent => {
  opts = Object.assign({
    boundary: false,
    defer: false,
    componentDidMount: true,
    componentWillReceiveProps: false,
    componentDidUpdate: false,
    contextTypes: {},
    forceUpdate: false
  }, opts);
  const prep = {
    prepare: (...args) => Promise.resolve(sideEffect(...args)),
    defer: opts.defer
  }; // Disable eslint for deprecated componentWillReceiveProps
  // eslint-disable-next-line react/no-deprecated

  class PreparedComponent extends React.Component {
    // $FlowFixMe
    constructor(props, context) {
      super(props, context); // $FlowFixMe

      this[REACT_PREPARE] = prep;
    }

    componentDidMount() {
      if (opts.componentDidMount) {
        Promise.resolve(sideEffect(this.props, this.context)).then(() => {
          if (opts.forceUpdate) {
            this.forceUpdate();
          }
        });
      }
    } // $FlowFixMe


    UNSAFE_componentWillReceiveProps(nextProps, nextContext) {
      if (opts.componentWillReceiveProps) {
        sideEffect(nextProps, nextContext);
      }
    }

    componentDidUpdate() {
      if (opts.componentDidUpdate) {
        sideEffect(this.props, this.context);
      }
    }

    render() {
      return React__default.createElement(OriginalComponent, this.props);
    }

  }

  const displayName = OriginalComponent.displayName || OriginalComponent.name || '';
  PreparedComponent.contextTypes = opts.contextTypes;
  PreparedComponent.displayName = `PreparedComponent(${displayName})`;
  return PreparedComponent;
}; // $FlowFixMe


function isPrepared(CustomComponent) {
  return CustomComponent[REACT_PREPARE] && typeof CustomComponent[REACT_PREPARE].prepare === 'function';
} // $FlowFixMe


function getPrepare(CustomComponent) {
  return CustomComponent[REACT_PREPARE] || {};
}

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
const storeShape = PropTypes.shape({
  dispatch: PropTypes.func.isRequired
}); // $FlowFixMe

const dispatched = (prepareUsingDispatch, opts = {}) => OriginalComponent => {
  const prepare = (props, context) => {
    return prepareUsingDispatch(props, context.store.dispatch);
  };

  const contextTypes = Object.assign({}, opts && opts.contextTypes ? opts.contextTypes : {}, {
    store: storeShape
  });
  const preparedOpts = Object.assign({}, opts, {
    contextTypes
  });
  return prepared(prepare, preparedOpts)(OriginalComponent);
};

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
function isReactCompositeComponent(type) {
  if (typeof type !== 'function') {
    return false;
  }

  if (typeof type.prototype !== 'object') {
    return false;
  }

  if (typeof type.prototype.render !== 'function') {
    return false;
  }

  return true;
}

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
function renderCompositeElementInstance(instance) {
  const childContext = Object.assign({}, instance.context, instance.getChildContext ? instance.getChildContext() : {});

  if (instance.componentWillMount) {
    instance.componentWillMount();
  } else if (instance.UNSAFE_componentWillMount) {
    instance.UNSAFE_componentWillMount();
  }

  const children = instance.render();
  return [children, childContext];
}

function prepareComponentInstance(instance) {
  if (!isPrepared(instance)) {
    return Promise.resolve({});
  }

  const prepareConfig = getPrepare(instance); // If the component is deferred, skip the prepare step

  if (prepareConfig.defer) {
    return Promise.resolve(prepareConfig);
  } // $FlowFixMe


  return prepareConfig.prepare(instance.props, instance.context).then(() => {
    return prepareConfig;
  });
}

function prepareElement(element, context) {
  if (element === null || typeof element !== 'object') {
    return Promise.resolve([null, context]);
  }

  const {
    type,
    props
  } = element;

  if (reactIs.isContextConsumer(element)) {
    return Promise.resolve([props.children(type._currentValue), context]);
  }

  if (reactIs.isContextProvider(element)) {
    type._context._currentValue = props.value;
    return Promise.resolve([props.children, context]);
  }

  if (typeof type === 'string' || reactIs.isFragment(element) || reactIs.isForwardRef(element)) {
    return Promise.resolve([props.children, context]);
  }

  if (!isReactCompositeComponent(type)) {
    return Promise.resolve([type(props, context), context]);
  }

  const CompositeComponent = type;
  const instance = new CompositeComponent(props, context);
  instance.props = props;
  instance.context = context;

  if (instance.componentWillUnmount && false) {
    context.__UNMOUNTS__.push(() => instance.componentWillUnmount());
  }

  return prepareComponentInstance(instance).then(prepareConfig => {
    // Stop traversing if the component is defer or boundary
    if (prepareConfig.defer || prepareConfig.boundary) {
      return Promise.resolve([null, context]);
    }

    return renderCompositeElementInstance(instance);
  });
}

function _prepare(element, context) {
  return prepareElement(element, context).then(([children, childContext]) => {
    return Promise.all(React__default.Children.toArray(children).map(child => _prepare(child, childContext)));
  });
}

function prepare(element, context = {}) {
  context.__IS_PREPARE__ = true;
  context.__UNMOUNTS__ = [];
  return _prepare(element, context).then(() => {
    context.__IS_PREPARE__ = false;

    context.__UNMOUNTS__.forEach(fn => {
      return fn();
    });
  });
}

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
const CHUNKS_KEY = '__CHUNK_IDS';
const contextTypes = {
  splitComponentLoaders: PropTypes.array.isRequired
};

{
  // $FlowFixMe
  contextTypes.preloadChunks = PropTypes.array.isRequired;
} // $FlowFixMe


function withAsyncComponent({
  defer,
  load,
  LoadingComponent,
  ErrorComponent
}) {
  let AsyncComponent = null;
  let error = null;
  let chunkIds = [];

  function WithAsyncComponent(props) {
    if (error) {
      return React__default.createElement(ErrorComponent, {
        error: error
      });
    }

    if (!AsyncComponent) {
      return React__default.createElement(LoadingComponent, null);
    }

    return React__default.createElement(AsyncComponent, props);
  }

  return prepared((props, context) => {
    if (AsyncComponent) {
      {
        chunkIds.forEach(chunkId => {
          context.preloadChunks.push(chunkId);
        });
      }

      return Promise.resolve(AsyncComponent);
    }

    let componentPromise;

    try {
      componentPromise = load();
    } catch (e) {
      componentPromise = Promise.reject(e);
    } // $FlowFixMe


    chunkIds = componentPromise[CHUNKS_KEY] || [];

    {
      chunkIds.forEach(chunkId => {
        context.preloadChunks.push(chunkId);
      });
    }

    const loadPromises = [componentPromise, ...context.splitComponentLoaders.map(loader => loader(chunkIds))];
    return Promise.all(loadPromises).then(([asyncComponent]) => {
      // Note: .default is toolchain specific, breaks w/ CommonJS exports
      AsyncComponent = asyncComponent.default;
    }).catch(err => {
      error = err;
       // log error
    });
  }, {
    defer,
    contextTypes,
    forceUpdate: true
  })(WithAsyncComponent);
}

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
// to visit the minimum number of nodes

var exclude = prepared(Promise.resolve(), {
  componentDidMount: false,
  componentWillReceiveProps: false,
  componentDidUpdate: false,
  defer: true
});

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
class PrepareProvider extends React__default.Component {
  constructor(props, context) {
    super(props, context);
    this.splitComponentLoaders = [];
    this.preloadChunks = props.preloadChunks;
  }

  getChildContext() {
    return {
      splitComponentLoaders: this.splitComponentLoaders,
      preloadChunks: this.preloadChunks
    };
  }

  render() {
    return React__default.Children.only(this.props.children);
  }

}

PrepareProvider.childContextTypes = {
  splitComponentLoaders: PropTypes.array.isRequired,
  preloadChunks: PropTypes.array.isRequired
};

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
const middleware = function (ctx, next) {
  if (true && !ctx.element) {
    return next();
  }

  ctx.element = React__default.createElement(PrepareProvider, {
    preloadChunks: ctx.preloadChunks
  }, ctx.element);
  return next();
};

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
const prepareTyped = prepare;
const preparedTyped = prepared;
const splitTyped = withAsyncComponent;
const excludeTyped = exclude;

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

/* eslint-env node */
var serverRender = (el => `<div id='root'>${server.renderToString(el)}</div>`);

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

/* eslint-env browser */

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
var Provider = {
  create: name => {
    class Provider extends React.Component {
      getChildContext() {
        return {
          [name]: this.props.provides
        };
      }

      render() {
        return React.Children.only(this.props.children);
      }

    }

    Provider.childContextTypes = _objectSpread({}, Provider.childContextTypes || {}, {
      [name]: PropTypes.any.isRequired
    });
    Provider.displayName = name.replace(/^./, c => c.toUpperCase()) + 'Provider';
    return Provider;
  }
};

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
var plugin = {
  create: (name, plugin, provider) => {
    if (plugin.__plugin__ === undefined) {
      plugin = FusionApp.createPlugin(plugin);
    }

    if (!plugin.__plugin__) {
      throw new Error('Provided plugin does not match FusionPlugin<TDeps, TService>');
    }

    let originalMiddleware = plugin.middleware;
    const ProviderComponent = provider || Provider.create(name);

    plugin.middleware = (deps, provides) => {
      let nextMiddleware = originalMiddleware && originalMiddleware(deps, provides);

      const mw = function (ctx, next) {
        if (ctx.element) {
          ctx.element = React.createElement(ProviderComponent, {
            provides,
            ctx
          }, ctx.element);
        }

        if (nextMiddleware) {
          return nextMiddleware(ctx, next);
        }

        return next();
      };

      return mw;
    };

    return plugin;
  }
};

function _objectSpread$1(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty$1(target, key, source[key]); }); } return target; }

function _defineProperty$1(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
var hoc = {
  create: (name, mapProvidesToProps) => {
    const mapProvides = mapProvidesToProps ? mapProvidesToProps : provides => ({
      [name]: provides
    });
    return Component => {
      class HOC extends React.Component {
        constructor(props, ctx) {
          super(props, ctx);
          this.provides = ctx[name];
        }

        render() {
          const props = _objectSpread$1({}, this.props, mapProvides(this.provides));

          return React.createElement(Component, props);
        }

      }

      const displayName = Component.displayName || Component.name;
      HOC.displayName = 'With' + name.replace(/^./, c => c.toUpperCase()) + '(' + displayName + ')';
      HOC.contextTypes = {
        [name]: PropTypes.any.isRequired
      };
      return HOC;
    };
  }
};

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

/* eslint-env browser */
class App extends FusionApp__default {
  constructor(root, render) {
    const renderer = FusionApp.createPlugin({
      provides() {
        return el => {
          return prepareTyped(el).then(() => {
            if (render) {
              return render(el);
            }

            return serverRender(el);
          });
        };
      },

      middleware() {
        return middleware;
      }

    });
    super(root, renderer);
  }

}

exports.default = App;
exports.ProviderPlugin = plugin;
exports.ProvidedHOC = hoc;
exports.Provider = Provider;
exports.dispatched = dispatched;
exports.prepare = prepareTyped;
exports.prepared = preparedTyped;
exports.split = splitTyped;
exports.exclude = excludeTyped;
exports.middleware = middleware;
//# sourceMappingURL=index.js.map
