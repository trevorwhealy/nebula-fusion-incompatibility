import React__default, { Component, createElement, Children } from 'react';
import PropTypes from 'prop-types';
import { isFragment, isContextConsumer, isContextProvider, isForwardRef } from 'react-is';
import ReactDOM from 'react-dom';
import FusionApp, { createPlugin } from 'fusion-core';

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
var REACT_PREPARE = '@__REACT_PREPARE__@';

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
var prepared = function prepared(sideEffect, opts) {
  if (opts === void 0) {
    opts = {};
  }

  return function (OriginalComponent) {
    opts = Object.assign({
      boundary: false,
      defer: false,
      componentDidMount: true,
      componentWillReceiveProps: false,
      componentDidUpdate: false,
      contextTypes: {},
      forceUpdate: false
    }, opts);
    var prep = {
      prepare: function prepare() {
        return Promise.resolve(sideEffect.apply(void 0, arguments));
      },
      defer: opts.defer
    }; // Disable eslint for deprecated componentWillReceiveProps
    // eslint-disable-next-line react/no-deprecated

    var PreparedComponent =
    /*#__PURE__*/
    function (_Component) {
      _inheritsLoose(PreparedComponent, _Component);

      // $FlowFixMe
      function PreparedComponent(props, context) {
        var _this;

        _this = _Component.call(this, props, context) || this; // $FlowFixMe

        _this[REACT_PREPARE] = prep;
        return _this;
      }

      var _proto = PreparedComponent.prototype;

      _proto.componentDidMount = function componentDidMount() {
        var _this2 = this;

        if (opts.componentDidMount) {
          Promise.resolve(sideEffect(this.props, this.context)).then(function () {
            if (opts.forceUpdate) {
              _this2.forceUpdate();
            }
          });
        }
      }; // $FlowFixMe


      _proto.UNSAFE_componentWillReceiveProps = function UNSAFE_componentWillReceiveProps(nextProps, nextContext) {
        if (opts.componentWillReceiveProps) {
          sideEffect(nextProps, nextContext);
        }
      };

      _proto.componentDidUpdate = function componentDidUpdate() {
        if (opts.componentDidUpdate) {
          sideEffect(this.props, this.context);
        }
      };

      _proto.render = function render() {
        return React__default.createElement(OriginalComponent, this.props);
      };

      return PreparedComponent;
    }(Component);

    var displayName = OriginalComponent.displayName || OriginalComponent.name || '';
    PreparedComponent.contextTypes = opts.contextTypes;
    PreparedComponent.displayName = "PreparedComponent(" + displayName + ")";
    return PreparedComponent;
  };
}; // $FlowFixMe


function isPrepared(CustomComponent) {
  return CustomComponent[REACT_PREPARE] && typeof CustomComponent[REACT_PREPARE].prepare === 'function';
} // $FlowFixMe


function getPrepare(CustomComponent) {
  return CustomComponent[REACT_PREPARE] || {};
}

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
var storeShape = PropTypes.shape({
  dispatch: PropTypes.func.isRequired
}); // $FlowFixMe

var dispatched = function dispatched(prepareUsingDispatch, opts) {
  if (opts === void 0) {
    opts = {};
  }

  return function (OriginalComponent) {
    var prepare = function prepare(props, context) {
      return prepareUsingDispatch(props, context.store.dispatch);
    };

    var contextTypes = Object.assign({}, opts && opts.contextTypes ? opts.contextTypes : {}, {
      store: storeShape
    });
    var preparedOpts = Object.assign({}, opts, {
      contextTypes: contextTypes
    });
    return prepared(prepare, preparedOpts)(OriginalComponent);
  };
};

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
function isReactCompositeComponent(type) {
  if (typeof type !== 'function') {
    return false;
  }

  if (_typeof(type.prototype) !== 'object') {
    return false;
  }

  if (typeof type.prototype.render !== 'function') {
    return false;
  }

  return true;
}

function _typeof$1(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof$1 = function _typeof(obj) { return typeof obj; }; } else { _typeof$1 = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof$1(obj); }

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
function renderCompositeElementInstance(instance) {
  var childContext = Object.assign({}, instance.context, instance.getChildContext ? instance.getChildContext() : {});

  if (instance.componentWillMount) {
    instance.componentWillMount();
  } else if (instance.UNSAFE_componentWillMount) {
    instance.UNSAFE_componentWillMount();
  }

  var children = instance.render();
  return [children, childContext];
}

function prepareComponentInstance(instance) {
  if (!isPrepared(instance)) {
    return Promise.resolve({});
  }

  var prepareConfig = getPrepare(instance); // If the component is deferred, skip the prepare step

  if (prepareConfig.defer) {
    return Promise.resolve(prepareConfig);
  } // $FlowFixMe


  return prepareConfig.prepare(instance.props, instance.context).then(function () {
    return prepareConfig;
  });
}

function prepareElement(element, context) {
  if (element === null || _typeof$1(element) !== 'object') {
    return Promise.resolve([null, context]);
  }

  var type = element.type,
      props = element.props;

  if (isContextConsumer(element)) {
    return Promise.resolve([props.children(type._currentValue), context]);
  }

  if (isContextProvider(element)) {
    type._context._currentValue = props.value;
    return Promise.resolve([props.children, context]);
  }

  if (typeof type === 'string' || isFragment(element) || isForwardRef(element)) {
    return Promise.resolve([props.children, context]);
  }

  if (!isReactCompositeComponent(type)) {
    return Promise.resolve([type(props, context), context]);
  }

  var CompositeComponent = type;
  var instance = new CompositeComponent(props, context);
  instance.props = props;
  instance.context = context;

  if (instance.componentWillUnmount && true) {
    context.__UNMOUNTS__.push(function () {
      return instance.componentWillUnmount();
    });
  }

  return prepareComponentInstance(instance).then(function (prepareConfig) {
    // Stop traversing if the component is defer or boundary
    if (prepareConfig.defer || prepareConfig.boundary) {
      return Promise.resolve([null, context]);
    }

    return renderCompositeElementInstance(instance);
  });
}

function _prepare(element, context) {
  return prepareElement(element, context).then(function (_ref) {
    var children = _ref[0],
        childContext = _ref[1];
    return Promise.all(React__default.Children.toArray(children).map(function (child) {
      return _prepare(child, childContext);
    }));
  });
}

function prepare(element, context) {
  if (context === void 0) {
    context = {};
  }

  context.__IS_PREPARE__ = true;
  context.__UNMOUNTS__ = [];
  return _prepare(element, context).then(function () {
    context.__IS_PREPARE__ = false;

    context.__UNMOUNTS__.forEach(function (fn) {
      return fn();
    });
  });
}

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
var CHUNKS_KEY = '__CHUNK_IDS';
var contextTypes = {
  splitComponentLoaders: PropTypes.array.isRequired
};

function withAsyncComponent(_ref) {
  var defer = _ref.defer,
      load = _ref.load,
      LoadingComponent = _ref.LoadingComponent,
      ErrorComponent = _ref.ErrorComponent;
  var AsyncComponent = null;
  var error = null;
  var chunkIds = [];

  function WithAsyncComponent(props) {
    if (error) {
      return React__default.createElement(ErrorComponent, {
        error: error
      });
    }

    if (!AsyncComponent) {
      return React__default.createElement(LoadingComponent, null);
    }

    return React__default.createElement(AsyncComponent, props);
  }

  return prepared(function (props, context) {
    if (AsyncComponent) {
      return Promise.resolve(AsyncComponent);
    }

    var componentPromise;

    try {
      componentPromise = load();
    } catch (e) {
      componentPromise = Promise.reject(e);
    } // $FlowFixMe


    chunkIds = componentPromise[CHUNKS_KEY] || [];

    var loadPromises = [componentPromise].concat(context.splitComponentLoaders.map(function (loader) {
      return loader(chunkIds);
    }));
    return Promise.all(loadPromises).then(function (_ref2) {
      var asyncComponent = _ref2[0];
      // Note: .default is toolchain specific, breaks w/ CommonJS exports
      AsyncComponent = asyncComponent.default;
    }).catch(function (err) {
      error = err;
      setTimeout(function () {
        throw err;
      }); // log error
    });
  }, {
    defer: defer,
    contextTypes: contextTypes,
    forceUpdate: true
  })(WithAsyncComponent);
}

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
// to visit the minimum number of nodes

var exclude = prepared(Promise.resolve(), {
  componentDidMount: false,
  componentWillReceiveProps: false,
  componentDidUpdate: false,
  defer: true
});

function _inheritsLoose$1(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
var PrepareProvider =
/*#__PURE__*/
function (_React$Component) {
  _inheritsLoose$1(PrepareProvider, _React$Component);

  function PrepareProvider(props, context) {
    var _this;

    _this = _React$Component.call(this, props, context) || this;
    _this.splitComponentLoaders = [];
    _this.preloadChunks = props.preloadChunks;
    return _this;
  }

  var _proto = PrepareProvider.prototype;

  _proto.getChildContext = function getChildContext() {
    return {
      splitComponentLoaders: this.splitComponentLoaders,
      preloadChunks: this.preloadChunks
    };
  };

  _proto.render = function render() {
    return React__default.Children.only(this.props.children);
  };

  return PrepareProvider;
}(React__default.Component);

PrepareProvider.childContextTypes = {
  splitComponentLoaders: PropTypes.array.isRequired,
  preloadChunks: PropTypes.array.isRequired
};

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
var middleware = function middleware(ctx, next) {
  ctx.element = React__default.createElement(PrepareProvider, {
    preloadChunks: ctx.preloadChunks
  }, ctx.element);
  return next();
};

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
var prepareTyped = prepare;
var preparedTyped = prepared;
var splitTyped = withAsyncComponent;
var excludeTyped = exclude;

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

/* eslint-env node */

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

/* eslint-env browser */
var clientRender = (function (el) {
  var domElement = document.getElementById('root');

  if (!domElement) {
    throw new Error("Could not find 'root' element");
  }

  return ReactDOM.hydrate ? ReactDOM.hydrate(el, domElement) : ReactDOM.render(el, domElement);
});

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _inheritsLoose$2(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
var Provider = {
  create: function create(name) {
    var _objectSpread2;

    var Provider =
    /*#__PURE__*/
    function (_React$Component) {
      _inheritsLoose$2(Provider, _React$Component);

      function Provider() {
        return _React$Component.apply(this, arguments) || this;
      }

      var _proto = Provider.prototype;

      _proto.getChildContext = function getChildContext() {
        var _ref;

        return _ref = {}, _ref[name] = this.props.provides, _ref;
      };

      _proto.render = function render() {
        return Children.only(this.props.children);
      };

      return Provider;
    }(Component);

    Provider.childContextTypes = _objectSpread({}, Provider.childContextTypes || {}, (_objectSpread2 = {}, _objectSpread2[name] = PropTypes.any.isRequired, _objectSpread2));
    Provider.displayName = name.replace(/^./, function (c) {
      return c.toUpperCase();
    }) + 'Provider';
    return Provider;
  }
};

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
var plugin = {
  create: function create(name, plugin, provider) {
    if (plugin.__plugin__ === undefined) {
      plugin = createPlugin(plugin);
    }

    if (!plugin.__plugin__) {
      throw new Error('Provided plugin does not match FusionPlugin<TDeps, TService>');
    }

    var originalMiddleware = plugin.middleware;
    var ProviderComponent = provider || Provider.create(name);

    plugin.middleware = function (deps, provides) {
      var nextMiddleware = originalMiddleware && originalMiddleware(deps, provides);

      var mw = function mw(ctx, next) {
        if (ctx.element) {
          ctx.element = createElement(ProviderComponent, {
            provides: provides,
            ctx: ctx
          }, ctx.element);
        }

        if (nextMiddleware) {
          return nextMiddleware(ctx, next);
        }

        return next();
      };

      return mw;
    };

    return plugin;
  }
};

function _objectSpread$1(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty$1(target, key, source[key]); }); } return target; }

function _defineProperty$1(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _inheritsLoose$3(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
var hoc = {
  create: function create(name, mapProvidesToProps) {
    var mapProvides = mapProvidesToProps ? mapProvidesToProps : function (provides) {
      var _ref;

      return _ref = {}, _ref[name] = provides, _ref;
    };
    return function (Component$$1) {
      var _HOC$contextTypes;

      var HOC =
      /*#__PURE__*/
      function (_React$Component) {
        _inheritsLoose$3(HOC, _React$Component);

        function HOC(props, ctx) {
          var _this;

          _this = _React$Component.call(this, props, ctx) || this;
          _this.provides = ctx[name];
          return _this;
        }

        var _proto = HOC.prototype;

        _proto.render = function render() {
          var props = _objectSpread$1({}, this.props, mapProvides(this.provides));

          return createElement(Component$$1, props);
        };

        return HOC;
      }(Component);

      var displayName = Component$$1.displayName || Component$$1.name;
      HOC.displayName = 'With' + name.replace(/^./, function (c) {
        return c.toUpperCase();
      }) + '(' + displayName + ')';
      HOC.contextTypes = (_HOC$contextTypes = {}, _HOC$contextTypes[name] = PropTypes.any.isRequired, _HOC$contextTypes);
      return HOC;
    };
  }
};

function _inheritsLoose$4(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

/* eslint-env browser */
var App =
/*#__PURE__*/
function (_FusionApp) {
  _inheritsLoose$4(App, _FusionApp);

  function App(root, render) {
    var renderer = createPlugin({
      provides: function provides() {
        return function (el) {
          return prepareTyped(el).then(function () {
            if (render) {
              return render(el);
            }

            return clientRender(el);
          });
        };
      },
      middleware: function middleware$$1() {
        return middleware;
      }
    });
    return _FusionApp.call(this, root, renderer) || this;
  }

  return App;
}(FusionApp);

export default App;
export { plugin as ProviderPlugin, hoc as ProvidedHOC, Provider, dispatched, prepareTyped as prepare, preparedTyped as prepared, splitTyped as split, excludeTyped as exclude, middleware };
//# sourceMappingURL=browser.es5.es.js.map
