{"version":3,"sources":["../../../../../src/shadertools/src/lib/assemble-shaders.js"],"names":["VERTEX_SHADER","FRAGMENT_SHADER","resolveModules","getShaderModule","getPlatformShaderDefines","getVersionDefines","injectShader","assert","SHADER_TYPE","FRAGMENT_SHADER_PROLOGUE","assembleShaders","gl","opts","vs","fs","modules","assembleShader","Object","assign","source","type","getUniforms","assembleGetUniforms","assembleModuleMap","id","defines","inject","prologue","log","isVertex","sourceLines","split","glslVersion","versionLine","coreSource","indexOf","slice","join","assembledSource","getShaderName","getApplicationDefines","injectStandardStubs","module","name","checkDeprecations","moduleSource","getModuleSource","uniforms","moduleUniforms","result","moduleName","shaderModule","injectShaderName","count","sourceText","define","value","Number","isFinite","toUpperCase"],"mappings":"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","sourcesContent":["import {VERTEX_SHADER, FRAGMENT_SHADER} from './constants';\nimport {resolveModules, getShaderModule} from './resolve-modules';\nimport {getPlatformShaderDefines, getVersionDefines} from './platform-defines';\nimport injectShader from './inject-shader';\nimport assert from '../utils/assert';\n\nconst SHADER_TYPE = {\n  [VERTEX_SHADER]: 'vertex',\n  [FRAGMENT_SHADER]: 'fragment'\n};\n\n// Precision prologue to inject before functions are injected in shader\n// TODO - extract any existing prologue in the fragment source and move it up...\nconst FRAGMENT_SHADER_PROLOGUE = `\\\nprecision highp float;\n\n`;\n\n// Inject a list of modules\nexport function assembleShaders(gl, opts = {}) {\n  const {vs, fs} = opts;\n  const modules = resolveModules(opts.modules || []);\n  return {\n    gl,\n    vs: assembleShader(gl, Object.assign({}, opts, {source: vs, type: VERTEX_SHADER, modules})),\n    fs: assembleShader(gl, Object.assign({}, opts, {source: fs, type: FRAGMENT_SHADER, modules})),\n    getUniforms: assembleGetUniforms(modules),\n    modules: assembleModuleMap(modules)\n  };\n}\n\n// Pulls together complete source code for either a vertex or a fragment shader\n// adding prologues, requested module chunks, and any final injections.\nfunction assembleShader(gl, {\n  id,\n  source,\n  type,\n  modules = [],\n  defines = {},\n  inject = {},\n  prologue = true,\n  log\n}) {\n  assert(typeof source === 'string', 'shader source must be a string');\n\n  const isVertex = type === VERTEX_SHADER;\n\n  const sourceLines = source.split('\\n');\n  let glslVersion = 100;\n  let versionLine = '';\n  let coreSource = source;\n  // Extract any version directive string from source.\n  // TODO : keep all pre-processor statements at the begining of the shader.\n  if (sourceLines[0].indexOf('#version ') === 0) {\n    glslVersion = 300; // TODO - regexp that matches atual version number\n    versionLine = sourceLines[0];\n    coreSource = sourceLines.slice(1).join('\\n');\n  }\n\n  // Add platform defines (use these to work around platform-specific bugs and limitations)\n  // Add common defines (GLSL version compatibility, feature detection)\n  // Add precision declaration for fragment shaders\n  let assembledSource = prologue ? `\\\n${versionLine}\n${getShaderName({id, source, type})}\n${getPlatformShaderDefines(gl)}\n${getVersionDefines(gl, glslVersion, !isVertex)}\n${getApplicationDefines(defines)}\n${isVertex ? '' : FRAGMENT_SHADER_PROLOGUE}\n` : `${versionLine}\n`;\n\n  // Add source of dependent modules in resolved order\n  let injectStandardStubs = false;\n  for (const module of modules) {\n    switch (module.name) {\n    case 'inject':\n      injectStandardStubs = true;\n      break;\n\n    default:\n      module.checkDeprecations(coreSource, log);\n      const moduleSource = module.getModuleSource(type, glslVersion);\n      // Add the module source, and a #define that declares it presence\n      assembledSource += moduleSource;\n    }\n  }\n\n  // Add the version directive and actual source of this shader\n  assembledSource += coreSource;\n\n  // Apply any requested shader injections\n  assembledSource = injectShader(assembledSource, type, inject, injectStandardStubs);\n\n  return assembledSource;\n}\n\n// Returns a combined `getUniforms` covering the options for all the modules,\n// the created function will pass on options to the inidividual `getUniforms`\n// function of each shader module and combine the results into one object that\n// can be passed to setUniforms.\nfunction assembleGetUniforms(modules) {\n\n  return function getUniforms(opts) {\n    const uniforms = {};\n    for (const module of modules) {\n      // `modules` is already sorted by dependency level. This guarantees that\n      // modules have access to the uniforms that are generated by their dependencies.\n      const moduleUniforms = module.getUniforms(opts, uniforms);\n      Object.assign(uniforms, moduleUniforms);\n    }\n    return uniforms;\n  };\n\n}\n\n// Returns a map with module names as keys, resolving to their module definitions\n// The presence of a key indicates that the module is available in this program,\n// whether directly included, or through a dependency of some other module\nfunction assembleModuleMap(modules) {\n  const result = {};\n  for (const moduleName of modules) {\n    const shaderModule = getShaderModule(moduleName);\n    result[moduleName] = shaderModule;\n  }\n  return result;\n}\n\n// Generate \"glslify-compatible\" SHADER_NAME defines\n// These are understood by the GLSL error parsing function\n// If id is provided and no SHADER_NAME constant is present in source, create one\nfunction getShaderName({id, source, type}) {\n  const injectShaderName = id && typeof id === 'string' && source.indexOf('SHADER_NAME') === -1;\n  return injectShaderName ? `\n#define SHADER_NAME ${id}_${SHADER_TYPE[type]}\n\n` : '';\n}\n\n// Generates application defines from an object\nfunction getApplicationDefines(defines = {}) {\n  let count = 0;\n  let sourceText = '';\n  for (const define in defines) {\n    if (count === 0) {\n      sourceText += '\\n// APPLICATION DEFINES\\n';\n    }\n    count++;\n\n    const value = defines[define];\n    if (value || Number.isFinite(value)) {\n      sourceText += `#define ${define.toUpperCase()} ${defines[define]}\\n`;\n    }\n  }\n  if (count === 0) {\n    sourceText += '\\n';\n  }\n  return sourceText;\n}\n"],"file":"assemble-shaders.js"}