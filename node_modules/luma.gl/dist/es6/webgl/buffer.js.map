{"version":3,"sources":["../../../src/webgl/buffer.js"],"names":["GL","Resource","assertWebGL2Context","getGLTypeFromTypedArray","getTypedArrayFromGLType","Accessor","log","assert","DEBUG_DATA_LENGTH","Buffer","constructor","gl","props","ArrayBuffer","isView","data","stubRemovedMethods","target","webgl2","COPY_READ_BUFFER","ARRAY_BUFFER","initialize","Object","seal","removed","setAccessor","opts","accessor","updateAccessor","update","bytes","usage","STATIC_DRAW","type","byteLength","Float32Array","bytesUsed","debugData","slice","COPY_WRITE_BUFFER","bindBuffer","handle","bufferData","setProps","setData","subData","offset","srcOffset","length","undefined","bufferSubData","copyData","sourceBuffer","readOffset","writeOffset","size","copyBufferSubData","getData","dstData","srcByteOffset","dstOffset","ArrayType","FLOAT","clamped","sourceAvailableElementCount","_getAvailableElementCount","dstElementOffset","dstAvailableElementCount","dstElementCount","Math","min","copyElementCount","getBufferSubData","bind","index","UNIFORM_BUFFER","TRANSFORM_FEEDBACK_BUFFER","bindBufferBase","bindBufferRange","getElementCount","BYTES_PER_ELEMENT","unbind","isIndexedBuffer","getDebugData","changed","invalidateDebugData","sourceElementOffset","_createHandle","createBuffer","_deleteHandle","deleteBuffer","_getParameter","pname","value","getBufferParameter"],"mappings":"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","sourcesContent":["import GL from '../constants';\nimport Resource from './resource';\nimport {assertWebGL2Context} from '../webgl-utils';\nimport {getGLTypeFromTypedArray, getTypedArrayFromGLType} from '../webgl-utils/typed-array-utils';\nimport Accessor from './accessor';\nimport {log} from '../utils';\nimport assert from '../utils/assert';\n\nconst DEBUG_DATA_LENGTH = 10;\n\nexport default class Buffer extends Resource {\n\n  constructor(gl, props = {}) {\n    super(gl, props);\n\n    // Supports signature `new Buffer(gl, new Float32Array(...)`\n    if (ArrayBuffer.isView(props)) {\n      props = {data: props};\n    }\n\n    this.stubRemovedMethods('Buffer', 'v6.0', ['layout', 'setLayout', 'getIndexedParameter']);\n\n    // In WebGL1, need to make sure we use GL.ELEMENT_ARRAY_BUFFER when initializing element buffers\n    // otherwise buffer type will lock to generic (non-element) buffer\n    // In WebGL2, we can use GL.COPY_READ_BUFFER which avoids locking the type here\n    this.target = props.target || (this.gl.webgl2 ? GL.COPY_READ_BUFFER : GL.ARRAY_BUFFER);\n    this.initialize(props);\n    Object.seal(this);\n  }\n\n  get data() {\n    log.removed('Buffer.data', 'N/A', 'v6.0');\n    return null;\n  }\n\n  // Stores the accessor of data with the buffer, makes it easy to e.g. set it as an attribute later\n  // {accessor,type,size = 1,offset = 0,stride = 0,normalized = false,integer = false,instanced = 0}\n  setAccessor(opts) {\n    this.accessor = opts;\n    return this;\n  }\n\n  updateAccessor(opts) {\n    this.accessor.update(opts);\n    return this;\n  }\n\n  // Creates and initializes the buffer object's data store.\n  initialize(props = {}) {\n    let {\n      data,\n      bytes\n    } = props;\n\n    const {\n      usage = GL.STATIC_DRAW\n    } = props;\n\n    let type;\n    if (data) {\n      // infer type from typed array\n      type = getGLTypeFromTypedArray(data);\n      bytes = data.byteLength;\n      assert(type);\n    } else if (!bytes || bytes === 0) {\n      // Workaround needed for Safari (#291):\n      // gl.bufferData with size (second argument) equal to 0 crashes.\n      // hence create zero sized array.\n      bytes = 0;\n      data = new Float32Array(0);\n    }\n\n    this.usage = usage;\n    this.bytes = bytes;\n    this.bytesUsed = bytes;\n\n    this.debugData = data ? data.slice(0, DEBUG_DATA_LENGTH) : null;\n\n    // Call after type is determined\n    this.setAccessor(new Accessor(type ? {type} : {}, props, props.accessor));\n\n    // Create the buffer - binding it here for the first time locks the type\n    // In WebGL2, use GL.COPY_WRITE_BUFFER to avoid locking the type\n    const target = this.gl.webgl2 ? GL.COPY_WRITE_BUFFER : this.target;\n    this.gl.bindBuffer(target, this.handle);\n    this.gl.bufferData(target, data || bytes, usage);\n    this.gl.bindBuffer(target, null);\n\n    return this;\n  }\n\n  setProps(props) {\n    if ('data' in props) {\n      this.setData(props);\n    }\n    return this;\n  }\n\n  setData(opts) {\n    return this.initialize(opts);\n  }\n\n  // Updates a subset of a buffer object's data store.\n  // Data (Typed Array or ArrayBuffer), length is inferred unless provided\n  // Offset into buffer\n  // WebGL2 only: Offset into srcData\n  // WebGL2 only: Number of bytes to be copied\n  subData({data, offset = 0, srcOffset = 0, length} = {}) {\n    assert(data);\n\n    // Create the buffer - binding it here for the first time locks the type\n    // In WebGL2, use GL.COPY_WRITE_BUFFER to avoid locking the type\n    const target = this.gl.webgl2 ? GL.COPY_WRITE_BUFFER : this.target;\n    this.gl.bindBuffer(target, this.handle);\n    // WebGL2: subData supports additional srcOffset and length parameters\n    if (srcOffset !== 0 || length !== undefined) {\n      assertWebGL2Context(this.gl);\n      this.gl.bufferSubData(this.target, offset, data, srcOffset, length || 0);\n    } else {\n      this.gl.bufferSubData(target, offset, data);\n    }\n    this.gl.bindBuffer(target, null);\n\n    // TODO - update local `data` if offsets are right\n    this.debugData = null;\n\n    return this;\n  }\n\n  // WEBGL2 ONLY: Copies part of the data of another buffer into this buffer\n  copyData({sourceBuffer, readOffset = 0, writeOffset = 0, size}) {\n    const {gl} = this;\n    assertWebGL2Context(gl);\n\n    // Use GL.COPY_READ_BUFFER+GL.COPY_WRITE_BUFFER avoid disturbing other targets and locking type\n    gl.bindBuffer(GL.COPY_READ_BUFFER, sourceBuffer.handle);\n    gl.bindBuffer(GL.COPY_WRITE_BUFFER, this.handle);\n    gl.copyBufferSubData(GL.COPY_READ_BUFFER, GL.COPY_WRITE_BUFFER, readOffset, writeOffset, size);\n    gl.bindBuffer(GL.COPY_READ_BUFFER, null);\n    gl.bindBuffer(GL.COPY_WRITE_BUFFER, null);\n\n    // TODO - update local `data` if offsets are 0\n    this.debugData = null;\n\n    return this;\n  }\n\n  // WEBGL2 ONLY: Reads data from buffer into an ArrayBufferView or SharedArrayBuffer.\n  getData({dstData = null, srcByteOffset = 0, dstOffset = 0, length = 0} = {}) {\n    assertWebGL2Context(this.gl);\n\n    const ArrayType = getTypedArrayFromGLType(this.accessor.type || GL.FLOAT, {clamped: false});\n    const sourceAvailableElementCount = this._getAvailableElementCount(srcByteOffset);\n\n    const dstElementOffset = dstOffset;\n\n    let dstAvailableElementCount;\n    let dstElementCount;\n    if (dstData) {\n      dstElementCount = dstData.length;\n      dstAvailableElementCount = dstElementCount - dstElementOffset;\n    } else {\n      // Allocate ArrayBufferView with enough size to copy all eligible data.\n      dstAvailableElementCount =\n        Math.min(sourceAvailableElementCount, length || sourceAvailableElementCount);\n      dstElementCount = dstElementOffset + dstAvailableElementCount;\n    }\n\n    const copyElementCount = Math.min(sourceAvailableElementCount, dstAvailableElementCount);\n    length = length || copyElementCount;\n    assert(length <= copyElementCount);\n    dstData = dstData || new ArrayType(dstElementCount);\n\n    // Use GL.COPY_READ_BUFFER to avoid disturbing other targets and locking type\n    this.gl.bindBuffer(GL.COPY_READ_BUFFER, this.handle);\n    this.gl.getBufferSubData(GL.COPY_READ_BUFFER, srcByteOffset, dstData, dstOffset, length);\n    this.gl.bindBuffer(GL.COPY_READ_BUFFER, null);\n\n    // TODO - update local `data` if offsets are 0\n\n    return dstData;\n  }\n\n  /**\n   * Binds a buffer to a given binding point (target).\n   *   GL.TRANSFORM_FEEDBACK_BUFFER and GL.UNIFORM_BUFFER take an index, and optionally a range.\n   * @param {Glenum} target - target for the bind operation.\n   * @param {GLuint} index= - the index of the target.\n   *   - GL.TRANSFORM_FEEDBACK_BUFFER and GL.UNIFORM_BUFFER need an index to affect state\n   * @param {GLuint} offset=0 - the index of the target.\n   *   - GL.UNIFORM_BUFFER: `offset` must be aligned to GL.UNIFORM_BUFFER_OFFSET_ALIGNMENT.\n   * @param {GLuint} size= - the index of the target.\n   *   - GL.UNIFORM_BUFFER: `size` must be a minimum of GL.UNIFORM_BLOCK_SIZE_DATA.\n   * @returns {Buffer} - Returns itself for chaining.\n   */\n  bind({\n    target = this.target, index = this.accessor && this.accessor.index, offset = 0, size\n  } = {}) {\n    // NOTE: While GL.TRANSFORM_FEEDBACK_BUFFER and GL.UNIFORM_BUFFER could\n    // be used as direct binding points, they will not affect transform feedback or\n    // uniform buffer state. Instead indexed bindings need to be made.\n    const type = (target === GL.UNIFORM_BUFFER || target === GL.TRANSFORM_FEEDBACK_BUFFER) ?\n      (size !== undefined ? 'ranged' : 'indexed') : 'non-indexed';\n\n    switch (type) {\n    case 'indexed':\n      assertWebGL2Context(this.gl);\n      assert(offset === 0); // Make sure offset wasn't supplied\n      this.gl.bindBufferBase(target, index, this.handle);\n      break;\n    case 'ranged':\n      assertWebGL2Context(this.gl);\n      this.gl.bindBufferRange(target, index, this.handle, offset, size);\n      break;\n    case 'non-indexed':\n      this.gl.bindBuffer(target, this.handle);\n      break;\n    default:\n      assert(false);\n    }\n\n    return this;\n  }\n\n  // returns number of elements in the buffer\n  getElementCount() {\n    const ArrayType = getTypedArrayFromGLType(this.accessor.type || GL.FLOAT, {clamped: false});\n    return this.bytes / ArrayType.BYTES_PER_ELEMENT;\n  }\n\n  unbind({target = this.target, index = this.accessor && this.accessor.index} = {}) {\n    const isIndexedBuffer = target === GL.UNIFORM_BUFFER || target === GL.TRANSFORM_FEEDBACK_BUFFER;\n    if (isIndexedBuffer) {\n      this.gl.bindBufferBase(target, index, null);\n    } else {\n      this.gl.bindBuffer(target, null);\n    }\n    return this;\n  }\n\n  // PRIVATE METHODS\n\n  // Returns a short initial data array\n  getDebugData() {\n    if (!this.debugData) {\n      this.debugData = this.getData({length: DEBUG_DATA_LENGTH});\n      return {data: this.debugData, changed: true};\n    }\n    return {data: this.debugData, changed: false};\n  }\n\n  invalidateDebugData() {\n    this.debugData = null;\n  }\n\n  _getAvailableElementCount(srcByteOffset) {\n    const ArrayType = getTypedArrayFromGLType(this.accessor.type || GL.FLOAT, {clamped: false});\n    const sourceElementOffset = srcByteOffset / ArrayType.BYTES_PER_ELEMENT;\n    return this.getElementCount() - sourceElementOffset;\n  }\n\n  // RESOURCE METHODS\n\n  _createHandle() {\n    return this.gl.createBuffer();\n  }\n\n  _deleteHandle() {\n    this.gl.deleteBuffer(this.handle);\n  }\n\n  _getParameter(pname) {\n    this.gl.bindBuffer(this.target, this.handle);\n    const value = this.gl.getBufferParameter(this.target, pname);\n    this.gl.bindBuffer(this.target, null);\n    return value;\n  }\n}\n"],"file":"buffer.js"}