{"version":3,"sources":["../../../src/webgl/framebuffer.js"],"names":["Resource","Texture2D","Renderbuffer","Buffer","clear","clearBuffer","withParameters","getFeatures","getTypedArrayFromGLType","getGLTypeFromTypedArray","glFormatToComponents","glTypeToBytes","isWebGL2","assertWebGL2Context","flipRows","scalePixels","log","assert","GL","ERR_MULTIPLE_RENDERTARGETS","Framebuffer","gl","getParameter","MAX_COLOR_ATTACHMENTS","MAX_DRAW_BUFFERS","colorBufferFloat","colorBufferHalfFloat","supported","getExtension","luma","defaultFramebuffer","id","handle","attachments","opts","width","height","readBuffer","COLOR_ATTACHMENT0","drawBuffers","initialize","Object","seal","color","depth","stencil","check","attachment","target","object","Array","isArray","resize","_createDefaultAttachments","update","clearAttachments","checkStatus","attach","prevHandle","bindFramebuffer","FRAMEBUFFER","_setReadBuffer","_setDrawBuffers","undefined","drawingBufferWidth","drawingBufferHeight","attachmentPoint","newAttachments","keys","forEach","key","assign","descriptor","_unattach","_attachRenderbuffer","renderbuffer","texture","layer","level","_attachTexture","filter","status","checkFramebufferStatus","FRAMEBUFFER_COMPLETE","Error","_getFrameBufferStatus","value","drawBuffer","x","y","format","RGBA","type","pixelArray","FRONT","UNSIGNED_BYTE","ArrayType","clamped","components","readPixels","buffer","byteOffset","byteCount","bytes","size","bind","PIXEL_PACK_BUFFER","framebuffer","unbind","maxHeight","Number","MAX_SAFE_INTEGER","data","canvas","document","createElement","context","getContext","imageData","createImageData","set","putImageData","toDataURL","image","dataUrl","readDataUrl","Image","src","xoffset","yoffset","zoffset","mipmapLevel","prevBuffer","isFinite","TEXTURE_2D","TEXTURE_CUBE_MAP","copyTexSubImage2D","TEXTURE_2D_ARRAY","TEXTURE_3D","copyTexSubImage3D","srcFramebuffer","srcX0","srcY0","srcX1","srcY1","dstX0","dstY0","dstX1","dstY1","mask","NEAREST","COLOR_BUFFER_BIT","DEPTH_BUFFER_BIT","STENCIL_BUFFER_BIT","prevDrawHandle","DRAW_FRAMEBUFFER","prevReadHandle","READ_FRAMEBUFFER","blitFramebuffer","invalidateAll","invalidateFramebuffer","pname","_getAttachmentParameterFallback","bindTexture","getFramebufferAttachmentParameter","parameters","constructor","ATTACHMENT_PARAMETERS","values","getAttachmentParameter","window","open","copyToDataUrl","priority","message","defaultAttachments","pixels","mipmaps","TEXTURE_MIN_FILTER","TEXTURE_MAG_FILTER","TEXTURE_WRAP_S","CLAMP_TO_EDGE","TEXTURE_WRAP_T","DEPTH_ATTACHMENT","DEPTH_COMPONENT16","bindRenderbuffer","RENDERBUFFER","framebufferRenderbuffer","framebufferTextureLayer","face","mapIndexToCubeMapFace","framebufferTexture2D","BACK","ext","drawBuffersWEBGL","length","caps","FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER","webgl2","FRAMEBUFFER_ATTACHMENT_RED_SIZE","FRAMEBUFFER_ATTACHMENT_GREEN_SIZE","FRAMEBUFFER_ATTACHMENT_BLUE_SIZE","FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE","FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE","FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE","FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE","UNSIGNED_INT","FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING","EXT_sRGB","LINEAR","createFramebuffer","deleteFramebuffer","STENCIL_ATTACHMENT","TEXTURE_CUBE_MAP_POSITIVE_X","STATUS"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,OAAOA,QAAP,MAAqB,YAArB;AACA,OAAOC,SAAP,MAAsB,cAAtB;AACA,OAAOC,YAAP,MAAyB,gBAAzB;AACA,OAAOC,MAAP,MAAmB,UAAnB;AACA,SAAQC,eAAR,EAAeC,WAAf,QAAiC,SAAjC;AAEA,SAAQC,cAAR,QAA6B,kBAA7B;AACA,SAAQC,WAAR,QAA0B,mCAA1B;AAEA,SAAQC,uBAAR,EAAiCC,uBAAjC,QAA+D,kCAA/D;AACA,SAAQC,oBAAR,EAA8BC,aAA9B,QAAkD,6BAAlD;AACA,SAAQC,QAAR,EAAkBC,mBAAlB,QAA4C,gBAA5C;AACA,SAAQC,QAAR,EAAkBC,WAAlB,QAAoC,gBAApC;AAEA,SAAQC,WAAR,QAAkB,UAAlB;AACA,OAAOC,MAAP,MAAmB,iBAAnB;AAEA,OAAOC,EAAP,MAAe,cAAf;AAEA,IAAMC,6BAA6B,uCAAnC;;IAEqBC,W;;;;;;;wBA0BS;AAC1B,aAAO,KAAKC,EAAL,CAAQC,YAAR,CAAqB,KAAKD,EAAL,CAAQE,qBAA7B,CAAP;AACD;;;wBAEsB;AACrB,aAAO,KAAKF,EAAL,CAAQC,YAAR,CAAqB,KAAKD,EAAL,CAAQG,gBAA7B,CAAP;AACD;;;gCA9BkBH,E,EAGX;AAAA,qFAAJ,EAAI;AAAA,UAFNI,gBAEM,QAFNA,gBAEM;AAAA,UADNC,oBACM,QADNA,oBACM;;AACN,UAAIC,YAAY,IAAhB;AACAA,kBAAYF,oBACVJ,GAAGO,YAAH,CAAgBhB,SAASS,EAAT,IAAe,wBAAf,GAA0C,0BAA1D,CADF;AAEAM,kBAAYD,wBACVL,GAAGO,YAAH,CAAgBhB,SAASS,EAAT,IAAe,wBAAf,GAA0C,6BAA1D,CADF;AAEA,aAAOM,SAAP;AACD,K,CAED;;;;0CAC6BN,E,EAAI;AAC/BA,SAAGQ,IAAH,GAAUR,GAAGQ,IAAH,IAAW,EAArB;AACAR,SAAGQ,IAAH,CAAQC,kBAAR,GAA6BT,GAAGQ,IAAH,CAAQC,kBAAR,IAA8B,IAAIV,WAAJ,CAAgBC,EAAhB,EAAoB;AAC7EU,YAAI,qBADyE;AAE7EC,gBAAQ,IAFqE;AAG7EC,qBAAa;AAHgE,OAApB,CAA3D,CAF+B,CAO/B;;AACA,aAAOZ,GAAGQ,IAAH,CAAQC,kBAAf;AACD;;;AAUD,uBAAYT,EAAZ,EAA2B;AAAA;;AAAA,QAAXa,IAAW,uEAAJ,EAAI;;AAAA;;AACzB,sHAAMb,EAAN,EAAUa,IAAV,GADyB,CAGzB;;AACA,UAAKC,KAAL,GAAa,IAAb;AACA,UAAKC,MAAL,GAAc,IAAd;AACA,UAAKH,WAAL,GAAmB,EAAnB;AACA,UAAKI,UAAL,GAAkBnB,GAAGoB,iBAArB;AACA,UAAKC,WAAL,GAAmB,CAACrB,GAAGoB,iBAAJ,CAAnB;;AACA,UAAKE,UAAL,CAAgBN,IAAhB;;AAEAO,WAAOC,IAAP;AAXyB;AAY1B;;;;sCA4BE;AAAA,8BATDP,KASC;AAAA,UATDA,KASC,4BATO,CASP;AAAA,+BARDC,MAQC;AAAA,UARDA,MAQC,6BARQ,CAQR;AAAA,oCAPDH,WAOC;AAAA,UAPDA,WAOC,kCAPa,IAOb;AAAA,8BANDU,KAMC;AAAA,UANDA,KAMC,4BANO,IAMP;AAAA,8BALDC,KAKC;AAAA,UALDA,KAKC,4BALO,IAKP;AAAA,gCAJDC,OAIC;AAAA,UAJDA,OAIC,8BAJS,KAIT;AAAA,8BAHDC,KAGC;AAAA,UAHDA,KAGC,4BAHO,IAGP;AAAA,UAFDT,UAEC,SAFDA,UAEC;AAAA,UADDE,WACC,SADDA,WACC;AACDtB,aAAOkB,SAAS,CAAT,IAAcC,UAAU,CAA/B,EAAkC,sCAAlC,EADC,CAGD;;AACA,WAAKD,KAAL,GAAaA,KAAb;AACA,WAAKC,MAAL,GAAcA,MAAd,CALC,CAOD;AACA;;AACA,UAAIH,WAAJ,EAAiB;AACf,aAAK,IAAMc,UAAX,IAAyBd,WAAzB,EAAsC;AACpC,cAAMe,SAASf,YAAYc,UAAZ,CAAf;AACA,cAAME,SAASC,MAAMC,OAAN,CAAcH,MAAd,IAAwBA,OAAO,CAAP,CAAxB,GAAoCA,MAAnD;AACAC,iBAAOG,MAAP,CAAc;AAACjB,wBAAD;AAAQC;AAAR,WAAd;AACD;AACF,OAND,MAMO;AACL;AACAH,sBAAc,KAAKoB,yBAAL,CAA+B;AAACV,sBAAD;AAAQC,sBAAR;AAAeC,0BAAf;AAAwBV,sBAAxB;AAA+BC;AAA/B,SAA/B,CAAd;AACD;;AAED,WAAKkB,MAAL,CAAY;AAACC,0BAAkB,IAAnB;AAAyBtB,gCAAzB;AAAsCI,8BAAtC;AAAkDE;AAAlD,OAAZ,EApBC,CAsBD;;AACA,UAAIN,eAAea,KAAnB,EAA0B;AACxB,aAAKU,WAAL;AACD;AACF;;;kCAOE;AAAA,oCAJDvB,WAIC;AAAA,UAJDA,WAIC,kCAJa,EAIb;AAAA,UAHDI,UAGC,SAHDA,UAGC;AAAA,UAFDE,WAEC,SAFDA,WAEC;AAAA,wCADDgB,gBACC;AAAA,UADDA,gBACC,sCADkB,KAClB;AACD,WAAKE,MAAL,CAAYxB,WAAZ,EAAyB;AAACsB;AAAD,OAAzB;AADC,UAGMlC,EAHN,GAGY,IAHZ,CAGMA,EAHN,EAID;;AACA,UAAMqC,aAAarC,GAAGsC,eAAH,CAAmBzC,GAAG0C,WAAtB,EAAmC,KAAK5B,MAAxC,CAAnB;;AACA,UAAIK,UAAJ,EAAgB;AACd,aAAKwB,cAAL,CAAoBxB,UAApB;AACD;;AACD,UAAIE,WAAJ,EAAiB;AACf,aAAKuB,eAAL,CAAqBvB,WAArB;AACD;;AACDlB,SAAGsC,eAAH,CAAmBzC,GAAG0C,WAAtB,EAAmCF,cAAc,IAAjD;AAEA,aAAO,IAAP;AACD,K,CAED;;;;6BAC6B;AAAA,sFAAJ,EAAI;AAAA,UAArBvB,KAAqB,SAArBA,KAAqB;AAAA,UAAdC,MAAc,SAAdA,MAAc;;AAC3B;AACA,UAAI,KAAKJ,MAAL,KAAgB,IAApB,EAA0B;AACxBf,eAAOkB,UAAU4B,SAAV,IAAuB3B,WAAW2B,SAAzC;AACA,aAAK5B,KAAL,GAAa,KAAKd,EAAL,CAAQ2C,kBAArB;AACA,aAAK5B,MAAL,GAAc,KAAKf,EAAL,CAAQ4C,mBAAtB;AACA,eAAO,IAAP;AACD;;AAED,UAAI9B,UAAU4B,SAAd,EAAyB;AACvB5B,gBAAQ,KAAKd,EAAL,CAAQ2C,kBAAhB;AACD;;AACD,UAAI5B,WAAW2B,SAAf,EAA0B;AACxB3B,iBAAS,KAAKf,EAAL,CAAQ4C,mBAAjB;AACD;;AAED,UAAI9B,UAAU,KAAKA,KAAf,IAAwBC,WAAW,KAAKA,MAA5C,EAAoD;AAClDpB,aAAIA,GAAJ,CAAQ,CAAR,iCAAmC,KAAKe,EAAxC,iBAAiDI,KAAjD,cAA0DC,MAA1D;AACD;;AACD,WAAK,IAAM8B,eAAX,IAA8B,KAAKjC,WAAnC,EAAgD;AAC9C,aAAKA,WAAL,CAAiBiC,eAAjB,EAAkCd,MAAlC,CAAyC;AAACjB,sBAAD;AAAQC;AAAR,SAAzC;AACD;;AACD,WAAKD,KAAL,GAAaA,KAAb;AACA,WAAKC,MAAL,GAAcA,MAAd;AACA,aAAO,IAAP;AACD,K,CAED;;;;2BACOH,W,EAEC;AAAA;;AAAA,sFAAJ,EAAI;AAAA,wCADNsB,gBACM;AAAA,UADNA,gBACM,sCADa,KACb;;AACN,UAAMY,iBAAiB,EAAvB,CADM,CAGN;;AACA,UAAIZ,gBAAJ,EAAsB;AACpBd,eAAO2B,IAAP,CAAY,KAAKnC,WAAjB,EAA8BoC,OAA9B,CAAsC,eAAO;AAC3CF,yBAAeG,GAAf,IAAsB,IAAtB;AACD,SAFD;AAGD,OARK,CAUN;;;AACA7B,aAAO8B,MAAP,CAAcJ,cAAd,EAA8BlC,WAA9B;AAEA,UAAMyB,aAAa,KAAKrC,EAAL,CAAQsC,eAAR,CAAwBzC,GAAG0C,WAA3B,EAAwC,KAAK5B,MAA7C,CAAnB,CAbM,CAeN;;AACA,WAAK,IAAMe,UAAX,IAAyBoB,cAAzB,EAAyC;AACvC;AACAlD,eAAO8B,eAAe,WAAtB,EAAmC,uCAAnC;AAEA,YAAMyB,aAAaL,eAAepB,UAAf,CAAnB;AACA,YAAIE,SAASuB,UAAb;;AACA,YAAI,CAACvB,MAAL,EAAa;AACX,eAAKwB,SAAL,CAAe;AAAC1B;AAAD,WAAf;AACD,SAFD,MAEO,gBAAIE,MAAJ,EAAsB/C,YAAtB,GAAoC;AACzC,eAAKwE,mBAAL,CAAyB;AAAC3B,kCAAD;AAAa4B,0BAAc1B;AAA3B,WAAzB;AACD,SAFM,MAEA,IAAIC,MAAMC,OAAN,CAAcqB,UAAd,CAAJ,EAA+B;AAAA,2CACIA,UADJ;AAAA,cAC7BI,OAD6B;AAAA;AAAA,cACpBC,KADoB,6BACZ,CADY;AAAA;AAAA,cACTC,KADS,8BACD,CADC;;AAEpC7B,mBAAS2B,OAAT;;AACA,eAAKG,cAAL,CAAoB;AAAChC,kCAAD;AAAa6B,4BAAb;AAAsBC,wBAAtB;AAA6BC;AAA7B,WAApB;AACD,SAJM,MAIA;AACL,eAAKC,cAAL,CAAoB;AAAChC,kCAAD;AAAa6B,qBAAS3B,MAAtB;AAA8B4B,mBAAO,CAArC;AAAwCC,mBAAO;AAA/C,WAApB;AACD,SAhBsC,CAkBvC;;;AACA,YAAI7B,MAAJ,EAAY;AACVA,iBAAOG,MAAP,CAAc;AAACjB,mBAAO,KAAKA,KAAb;AAAoBC,oBAAQ,KAAKA;AAAjC,WAAd;AACD;AACF;;AAED,WAAKf,EAAL,CAAQsC,eAAR,CAAwBzC,GAAG0C,WAA3B,EAAwCF,cAAc,IAAtD,EAxCM,CA0CN;;AACAjB,aAAO8B,MAAP,CAAc,KAAKtC,WAAnB,EAAgCA,WAAhC;AACAQ,aAAO2B,IAAP,CAAY,KAAKnC,WAAjB,EAA8B+C,MAA9B,CAAqC;AAAA,eAAO,CAAC,OAAK/C,WAAL,CAAiBqC,GAAjB,CAAR;AAAA,OAArC,EAAoED,OAApE,CAA4E,eAAO;AACjF,eAAO,OAAKpC,WAAL,CAAiBqC,GAAjB,CAAP;AACD,OAFD;AAGD;;;kCAEa;AAAA,UACLjD,EADK,GACC,IADD,CACLA,EADK;AAEZ,UAAMqC,aAAarC,GAAGsC,eAAH,CAAmBzC,GAAG0C,WAAtB,EAAmC,KAAK5B,MAAxC,CAAnB;AACA,UAAMiD,SAAS5D,GAAG6D,sBAAH,CAA0BhE,GAAG0C,WAA7B,CAAf;AACAvC,SAAGsC,eAAH,CAAmBzC,GAAG0C,WAAtB,EAAmCF,cAAc,IAAjD;;AACA,UAAIuB,WAAW5D,GAAG8D,oBAAlB,EAAwC;AACtC,cAAM,IAAIC,KAAJ,CAAUC,sBAAsBJ,MAAtB,CAAV,CAAN;AACD;;AACD,aAAO,IAAP;AACD;;;4BAOO;AAAA,sFAAJ,EAAI;AAAA,UAJNtC,KAIM,SAJNA,KAIM;AAAA,UAHNC,KAGM,SAHNA,KAGM;AAAA,UAFNC,OAEM,SAFNA,OAEM;AAAA,oCADNN,WACM;AAAA,UADNA,WACM,kCADQ,EACR;;AACN;AACA,UAAMmB,aAAa,KAAKrC,EAAL,CAAQsC,eAAR,CAAwBzC,GAAG0C,WAA3B,EAAwC,KAAK5B,MAA7C,CAAnB;;AAEA,UAAIW,SAASC,KAAT,IAAkBC,OAAtB,EAA+B;AAC7BzC,eAAM,KAAKiB,EAAX,EAAe;AAACsB,sBAAD;AAAQC,sBAAR;AAAeC;AAAf,SAAf;AACD;;AAEDN,kBAAY8B,OAAZ,CAAoB,UAACiB,KAAD,EAAQC,UAAR,EAAuB;AACzClF,oBAAY;AAACkF,gCAAD;AAAaD;AAAb,SAAZ;AACD,OAFD;AAIA,WAAKjE,EAAL,CAAQsC,eAAR,CAAwBzC,GAAG0C,WAA3B,EAAwCF,cAAc,IAAtD;AAEA,aAAO,IAAP;AACD,K,CAED;AACA;AACA;AACA;;;;sCAUG;AAAA,0BARD8B,CAQC;AAAA,UARDA,CAQC,wBARG,CAQH;AAAA,0BAPDC,CAOC;AAAA,UAPDA,CAOC,wBAPG,CAOH;AAAA,8BANDtD,KAMC;AAAA,UANDA,KAMC,4BANO,KAAKA,KAMZ;AAAA,+BALDC,MAKC;AAAA,UALDA,MAKC,6BALQ,KAAKA,MAKb;AAAA,+BAJDsD,MAIC;AAAA,UAJDA,MAIC,6BAJQxE,GAAGyE,IAIX;AAAA,UAHDC,IAGC,SAHDA,IAGC;AAAA,mCAFDC,UAEC;AAAA,UAFDA,UAEC,iCAFY,IAEZ;AAAA,mCADD9C,UACC;AAAA,UADDA,UACC,iCADY7B,GAAGoB,iBACf;AAAA,UACMjB,EADN,GACY,IADZ,CACMA,EADN,EAGD;;AACA,UAAI0B,eAAe7B,GAAGoB,iBAAlB,IAAuC,KAAKN,MAAL,KAAgB,IAA3D,EAAiE;AAC/De,qBAAa7B,GAAG4E,KAAhB;AACD,OANA,CAQD;;;AACA,UAAI,CAACD,UAAL,EAAiB;AACf;AACAD,eAAOA,QAAQvE,GAAG0E,aAAlB;AACA,YAAMC,YAAYxF,wBAAwBoF,IAAxB,EAA8B;AAACK,mBAAS;AAAV,SAA9B,CAAlB;AACA,YAAMC,aAAaxF,qBAAqBgF,MAArB,CAAnB,CAJe,CAKf;;AACAG,qBAAaA,cAAc,IAAIG,SAAJ,CAAc7D,QAAQC,MAAR,GAAiB8D,UAA/B,CAA3B;AACD,OAhBA,CAkBD;;;AACAN,aAAOA,QAAQnF,wBAAwBoF,UAAxB,CAAf;AAEA,UAAMnC,aAAa,KAAKrC,EAAL,CAAQsC,eAAR,CAAwBzC,GAAG0C,WAA3B,EAAwC,KAAK5B,MAA7C,CAAnB;AACA,WAAKX,EAAL,CAAQ8E,UAAR,CAAmBX,CAAnB,EAAsBC,CAAtB,EAAyBtD,KAAzB,EAAgCC,MAAhC,EAAwCsD,MAAxC,EAAgDE,IAAhD,EAAsDC,UAAtD;AACA,WAAKxE,EAAL,CAAQsC,eAAR,CAAwBzC,GAAG0C,WAA3B,EAAwCF,cAAc,IAAtD;AAEA,aAAOmC,UAAP;AACD,K,CAED;AACA;;;;8CAUG;AAAA,0BARDL,CAQC;AAAA,UARDA,CAQC,wBARG,CAQH;AAAA,0BAPDC,CAOC;AAAA,UAPDA,CAOC,wBAPG,CAOH;AAAA,8BANDtD,KAMC;AAAA,UANDA,KAMC,4BANO,KAAKA,KAMZ;AAAA,+BALDC,MAKC;AAAA,UALDA,MAKC,6BALQ,KAAKA,MAKb;AAAA,+BAJDsD,MAIC;AAAA,UAJDA,MAIC,6BAJQxE,GAAGyE,IAIX;AAAA,UAHDC,IAGC,SAHDA,IAGC;AAAA,+BAFDQ,MAEC;AAAA,UAFDA,MAEC,6BAFQ,IAER;AAAA,mCADDC,UACC;AAAA,UADDA,UACC,iCADY,CACZ;AAAA,UACMhF,EADN,GACY,IADZ,CACMA,EADN,EAGD;;AACAR,0BAAoBQ,EAApB,EAJC,CAMD;;AACAuE,aAAOA,SAASQ,SAASA,OAAOR,IAAhB,GAAuB1E,GAAG6E,aAAnC,CAAP;;AAEA,UAAI,CAACK,MAAL,EAAa;AACX;AACA,YAAMF,aAAaxF,qBAAqBgF,MAArB,CAAnB;AACA,YAAMY,YAAY3F,cAAciF,IAAd,CAAlB;AACA,YAAMW,QAAQF,aAAclE,QAAQC,MAAR,GAAiB8D,UAAjB,GAA8BI,SAA1D;AACAF,iBAAS,IAAIjG,MAAJ,CAAWkB,EAAX,EAAe;AACtBkF,sBADsB;AAEtBX,oBAFsB;AAGtBY,gBAAMN;AAHgB,SAAf,CAAT;AAKD;;AAEDE,aAAOK,IAAP,CAAY;AAACzD,gBAAQ9B,GAAGwF;AAAZ,OAAZ;AACApG,qBAAee,EAAf,EAAmB;AAACsF,qBAAa;AAAd,OAAnB,EAAwC,YAAM;AAC5CtF,WAAG8E,UAAH,CAAcX,CAAd,EAAiBC,CAAjB,EAAoBtD,KAApB,EAA2BC,MAA3B,EAAmCsD,MAAnC,EAA2CE,IAA3C,EAAiDS,UAAjD;AACD,OAFD;AAGAD,aAAOQ,MAAP,CAAc;AAAC5D,gBAAQ9B,GAAGwF;AAAZ,OAAd;AAEA,aAAON,MAAP;AACD,K,CAED;;;;oCAIQ;AAAA,sFAAJ,EAAI;AAAA,mCAFNrD,UAEM;AAAA,UAFNA,UAEM,iCAFO7B,GAAGoB,iBAEV;AAAA,kCADNuE,SACM;AAAA,UADNA,SACM,gCADMC,OAAOC,gBACb;;AACN,UAAIC,OAAO,KAAKb,UAAL,CAAgB;AAACpD;AAAD,OAAhB,CAAX,CADM,CAGN;;AAHM,UAIDZ,KAJC,GAIgB,IAJhB,CAIDA,KAJC;AAAA,UAIMC,MAJN,GAIgB,IAJhB,CAIMA,MAJN;;AAKN,aAAOA,SAASyE,SAAhB,EAA2B;AAAA,2BACA9F,YAAY;AAACiG,oBAAD;AAAO7E,sBAAP;AAAcC;AAAd,SAAZ,CADA;;AACvB4E,YADuB,gBACvBA,IADuB;AACjB7E,aADiB,gBACjBA,KADiB;AACVC,cADU,gBACVA,MADU;AAE1B,OAPK,CASN;;;AACAtB,eAAS;AAACkG,kBAAD;AAAO7E,oBAAP;AAAcC;AAAd,OAAT;AAEA;;AACA,UAAM6E,SAASC,SAASC,aAAT,CAAuB,QAAvB,CAAf;AACAF,aAAO9E,KAAP,GAAeA,KAAf;AACA8E,aAAO7E,MAAP,GAAgBA,MAAhB;AACA,UAAMgF,UAAUH,OAAOI,UAAP,CAAkB,IAAlB,CAAhB,CAhBM,CAkBN;;AACA,UAAMC,YAAYF,QAAQG,eAAR,CAAwBpF,KAAxB,EAA+BC,MAA/B,CAAlB;AACAkF,gBAAUN,IAAV,CAAeQ,GAAf,CAAmBR,IAAnB;AACAI,cAAQK,YAAR,CAAqBH,SAArB,EAAgC,CAAhC,EAAmC,CAAnC;AAEA,aAAOL,OAAOS,SAAP,EAAP;AACD,K,CAED;;;;kCAKQ;AAAA,uFAAJ,EAAI;AAAA,gCAHNC,KAGM;AAAA,UAHNA,KAGM,6BAHE,IAGF;AAAA,qCAFN5E,UAEM;AAAA,UAFNA,UAEM,kCAFO7B,GAAGoB,iBAEV;AAAA,oCADNuE,SACM;AAAA,UADNA,SACM,iCADMC,OAAOC,gBACb;;AACN;AACA,UAAMa,UAAU,KAAKC,WAAL,CAAiB;AAAC9E;AAAD,OAAjB,CAAhB;AACA4E,cAAQA,SAAS,IAAIG,KAAJ,EAAjB;AACAH,YAAMI,GAAN,GAAYH,OAAZ;AACA,aAAOD,KAAP;AACD,K,CAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;0CAgBG;AAAA,UAbD/C,OAaC,UAbDA,OAaC;AAAA,UAZD5B,MAYC,UAZDA,MAYC;AAAA,kCAXDgF,OAWC;AAAA,UAXDA,OAWC,+BAXS,CAWT;AAAA,kCAVDC,OAUC;AAAA,UAVDA,OAUC,+BAVS,CAUT;AAAA,kCATDC,OASC;AAAA,UATDA,OASC,+BATS,CAST;AAAA,sCARDC,WAQC;AAAA,UARDA,WAQC,mCARa,CAQb;AAAA,qCALDpF,UAKC;AAAA,UALDA,UAKC,kCALY7B,GAAGoB,iBAKf;AAAA,4BAJDkD,CAIC;AAAA,UAJDA,CAIC,yBAJG,CAIH;AAAA,4BAHDC,CAGC;AAAA,UAHDA,CAGC,yBAHG,CAGH;AAAA,UAFDtD,KAEC,UAFDA,KAEC;AAAA,UADDC,MACC,UADDA,MACC;AAAA,UACMf,EADN,GACY,IADZ,CACMA,EADN;AAED,UAAMqC,aAAarC,GAAGsC,eAAH,CAAmBzC,GAAG0C,WAAtB,EAAmC,KAAK5B,MAAxC,CAAnB;AACA,UAAMoG,aAAa/G,GAAGgB,UAAH,CAAcU,UAAd,CAAnB;AAEAZ,cAAQ2E,OAAOuB,QAAP,CAAgBlG,KAAhB,IAAyBA,KAAzB,GAAiCyC,QAAQzC,KAAjD;AACAC,eAAS0E,OAAOuB,QAAP,CAAgBjG,MAAhB,IAA0BA,MAA1B,GAAmCwC,QAAQxC,MAApD,CANC,CAQD;;AACA,cAAQwC,QAAQ5B,MAAhB;AACA,aAAK9B,GAAGoH,UAAR;AACA,aAAKpH,GAAGqH,gBAAR;AACElH,aAAGmH,iBAAH,CACExF,UAAU4B,QAAQ5B,MADpB,EAEEmF,WAFF,EAGEH,OAHF,EAIEC,OAJF,EAKEzC,CALF,EAMEC,CANF,EAOEtD,KAPF,EAQEC,MARF;AAUA;;AACF,aAAKlB,GAAGuH,gBAAR;AACA,aAAKvH,GAAGwH,UAAR;AACErH,aAAGsH,iBAAH,CACE3F,UAAU4B,QAAQ5B,MADpB,EAEEmF,WAFF,EAGEH,OAHF,EAIEC,OAJF,EAKEC,OALF,EAME1C,CANF,EAOEC,CAPF,EAQEtD,KARF,EASEC,MATF;AAWA;;AACF;AA5BA;;AA+BAf,SAAGgB,UAAH,CAAc+F,UAAd;AACA/G,SAAGsC,eAAH,CAAmBzC,GAAG0C,WAAtB,EAAmCF,cAAc,IAAjD;AACA,aAAOkB,OAAP;AACD,K,CAED;AAEA;;;;iCAWG;AAAA,UATDgE,cASC,UATDA,cASC;AAAA,qCARD7F,UAQC;AAAA,UARDA,UAQC,kCARY7B,GAAGoB,iBAQf;AAAA,+BAPDuG,KAOC;AAAA,UAPDA,KAOC,4BAPO,CAOP;AAAA,+BAPUC,KAOV;AAAA,UAPUA,KAOV,4BAPkB,CAOlB;AAAA,UAPqBC,KAOrB,UAPqBA,KAOrB;AAAA,UAP4BC,KAO5B,UAP4BA,KAO5B;AAAA,+BANDC,KAMC;AAAA,UANDA,KAMC,4BANO,CAMP;AAAA,+BANUC,KAMV;AAAA,UANUA,KAMV,4BANkB,CAMlB;AAAA,UANqBC,KAMrB,UANqBA,KAMrB;AAAA,UAN4BC,KAM5B,UAN4BA,KAM5B;AAAA,gCALDzG,KAKC;AAAA,UALDA,KAKC,6BALO,IAKP;AAAA,gCAJDC,KAIC;AAAA,UAJDA,KAIC,6BAJO,KAIP;AAAA,kCAHDC,OAGC;AAAA,UAHDA,OAGC,+BAHS,KAGT;AAAA,+BAFDwG,IAEC;AAAA,UAFDA,IAEC,4BAFM,CAEN;AAAA,iCADDrE,MACC;AAAA,UADDA,MACC,8BADQ9D,GAAGoI,OACX;AAAA,UACMjI,EADN,GACY,IADZ,CACMA,EADN;AAEDR,0BAAoBQ,EAApB;;AAEA,UAAI,CAACuH,eAAe5G,MAAhB,IAA0Be,eAAe7B,GAAGoB,iBAAhD,EAAmE;AACjES,qBAAa7B,GAAG4E,KAAhB;AACD;;AAED,UAAInD,KAAJ,EAAW;AACT0G,gBAAQnI,GAAGqI,gBAAX;AACD;;AACD,UAAI3G,KAAJ,EAAW;AACTyG,gBAAQnI,GAAGsI,gBAAX;AACD;;AACD,UAAI3G,OAAJ,EAAa;AACXwG,gBAAQnI,GAAGuI,kBAAX;AACD;;AACDxI,aAAOoI,IAAP;AAEAN,cAAQA,UAAUhF,SAAV,GAAsB6E,eAAezG,KAArC,GAA6C4G,KAArD;AACAC,cAAQA,UAAUjF,SAAV,GAAsB6E,eAAexG,MAArC,GAA8C4G,KAAtD;AACAG,cAAQA,UAAUpF,SAAV,GAAsB,KAAK5B,KAA3B,GAAmCgH,KAA3C;AACAC,cAAQA,UAAUrF,SAAV,GAAsB,KAAK3B,MAA3B,GAAoCgH,KAA5C;AAEA,UAAMM,iBAAiBrI,GAAGsC,eAAH,CAAmBzC,GAAGyI,gBAAtB,EAAwC,KAAK3H,MAA7C,CAAvB;AACA,UAAM4H,iBAAiBvI,GAAGsC,eAAH,CAAmBzC,GAAG2I,gBAAtB,EAAwCjB,eAAe5G,MAAvD,CAAvB;AACAX,SAAGgB,UAAH,CAAcU,UAAd;AACA1B,SAAGyI,eAAH,CAAmBjB,KAAnB,EAA0BC,KAA1B,EAAiCC,KAAjC,EAAwCC,KAAxC,EAA+CC,KAA/C,EAAsDC,KAAtD,EAA6DC,KAA7D,EAAoEC,KAApE,EAA2EC,IAA3E,EAAiFrE,MAAjF;AACA3D,SAAGgB,UAAH,CAAc,KAAKA,UAAnB;AACAhB,SAAGsC,eAAH,CAAmBzC,GAAG2I,gBAAtB,EAAwCD,kBAAkB,IAA1D;AACAvI,SAAGsC,eAAH,CAAmBzC,GAAGyI,gBAAtB,EAAwCD,kBAAkB,IAA1D;AAEA,aAAO,IAAP;AACD,K,CAED;;;;uCAC4D;AAAA,sCAAhDzH,WAAgD;AAAA,UAAhDA,WAAgD,mCAAlC,EAAkC;AAAA,4BAA9BuD,CAA8B;AAAA,UAA9BA,CAA8B,yBAA1B,CAA0B;AAAA,4BAAvBC,CAAuB;AAAA,UAAvBA,CAAuB,yBAAnB,CAAmB;AAAA,UAAhBtD,KAAgB,UAAhBA,KAAgB;AAAA,UAATC,MAAS,UAATA,MAAS;AAAA,UACnDf,EADmD,GAC7C,IAD6C,CACnDA,EADmD;AAE1DR,0BAAoBQ,EAApB;AACA,UAAMqC,aAAarC,GAAGsC,eAAH,CAAmBzC,GAAG2I,gBAAtB,EAAwC,KAAK7H,MAA7C,CAAnB;AACA,UAAM+H,gBAAgBvE,MAAM,CAAN,IAAWC,MAAM,CAAjB,IAAsBtD,UAAU4B,SAAhC,IAA6C3B,WAAW2B,SAA9E;;AACA,UAAIgG,aAAJ,EAAmB;AACjB1I,WAAG2I,qBAAH,CAAyB9I,GAAG2I,gBAA5B,EAA8C5H,WAA9C;AACD,OAFD,MAEO;AACLZ,WAAG2I,qBAAH,CAAyB9I,GAAG2I,gBAA5B,EAA8C5H,WAA9C,EAA2DuD,CAA3D,EAA8DC,CAA9D,EAAiEtD,KAAjE,EAAwEC,MAAxE;AACD;;AACDf,SAAGsC,eAAH,CAAmBzC,GAAG2I,gBAAtB,EAAwCnG,UAAxC;AACA,aAAO,IAAP;AACD,K,CAED;AACA;;;;6CACwE;AAAA,uFAAJ,EAAI;AAAA,qCAAhDX,UAAgD;AAAA,UAAhDA,UAAgD,kCAAnC7B,GAAGoB,iBAAgC;AAAA,UAAb2H,KAAa,UAAbA,KAAa;;AACtE,UAAI3E,QAAQ,KAAK4E,+BAAL,CAAqCD,KAArC,CAAZ;;AACA,UAAI3E,UAAU,IAAd,EAAoB;AAClB,aAAKjE,EAAL,CAAQ8I,WAAR,CAAoBjJ,GAAG0C,WAAvB,EAAoC,KAAK5B,MAAzC;AACAsD,gBAAQ,KAAKjE,EAAL,CAAQ+I,iCAAR,CAA0ClJ,GAAG0C,WAA7C,EAA0Db,UAA1D,EAAsEkH,KAAtE,CAAR;AACA,aAAK5I,EAAL,CAAQ8I,WAAR,CAAoBjJ,GAAG0C,WAAvB,EAAoC,IAApC;AACD;;AACD,aAAO0B,KAAP;AACD;;;8CAKC;AAAA,UAFAvC,UAEA,uEAFa7B,GAAGoB,iBAEhB;AAAA,UADA+H,UACA,uEADa,KAAKC,WAAL,CAAiBC,qBAAjB,IAA0C,EACvD;AACA,UAAMC,SAAS,EAAf;;AACA,WAAK,IAAMP,KAAX,IAAoBI,UAApB,EAAgC;AAC9BG,eAAOP,KAAP,IAAgB,KAAKQ,sBAAL,CAA4BR,KAA5B,CAAhB;AACD;;AACD,aAAO,IAAP;AACD,K,CAED;AAEA;;;;2BACO;AACL;AACA,UAAI,OAAOS,MAAP,KAAkB,WAAtB,EAAmC;AACjCA,eAAOC,IAAP,CAAY,KAAKC,aAAL,EAAZ,EAAkC,oBAAlC;AACD;;AACD,aAAO,IAAP;AACD;;;0BAE+B;AAAA,UAA5BC,QAA4B,uEAAjB,CAAiB;AAAA,UAAdC,OAAc,uEAAJ,EAAI;;AAC9B,UAAID,WAAW7J,KAAI6J,QAAf,IAA2B,OAAOH,MAAP,KAAkB,WAAjD,EAA8D;AAC5D,eAAO,IAAP;AACD;;AACDI,gBAAUA,iCAA0B,KAAK/I,EAA/B,CAAV;AACA,UAAM4F,QAAQ,KAAKiD,aAAL,CAAmB;AAAC/D,mBAAW;AAAZ,OAAnB,CAAd;;AACA7F,WAAI2G,KAAJ,CAAU;AAACkD,0BAAD;AAAWC,wBAAX;AAAoBnD;AAApB,OAAV,EAAsCmD,OAAtC;;AACA,aAAO,IAAP;AACD,K,CAED;;;;2BACqC;AAAA,uFAAJ,EAAI;AAAA,iCAA/B9H,MAA+B;AAAA,UAA/BA,MAA+B,8BAAtB9B,GAAG0C,WAAmB;;AACnC,WAAKvC,EAAL,CAAQsC,eAAR,CAAwBX,MAAxB,EAAgC,KAAKhB,MAArC;AACA,aAAO,IAAP;AACD;;;6BAEsC;AAAA,uFAAJ,EAAI;AAAA,iCAA/BgB,MAA+B;AAAA,UAA/BA,MAA+B,8BAAtB9B,GAAG0C,WAAmB;;AACrC,WAAKvC,EAAL,CAAQsC,eAAR,CAAwBX,MAAxB,EAAgC,IAAhC;AACA,aAAO,IAAP;AACD,K,CAED;;;;sDAEkE;AAAA,UAAvCL,KAAuC,UAAvCA,KAAuC;AAAA,UAAhCC,KAAgC,UAAhCA,KAAgC;AAAA,UAAzBC,OAAyB,UAAzBA,OAAyB;AAAA,UAAhBV,KAAgB,UAAhBA,KAAgB;AAAA,UAATC,MAAS,UAATA,MAAS;AAChE,UAAI2I,qBAAqB,IAAzB,CADgE,CAGhE;;AACA,UAAIpI,KAAJ,EAAW;AAAA;;AACToI,6BAAqBA,sBAAsB,EAA3C;AACAA,2BAAmB7J,GAAGoB,iBAAtB,IAA2C,IAAIrC,SAAJ,CAAc,KAAKoB,EAAnB,EAAuB;AAChE2J,kBAAQ,IADwD;AAClD;AACdtF,kBAAQxE,GAAGyE,IAFqD;AAGhEC,gBAAM1E,GAAG6E,aAHuD;AAIhE5D,sBAJgE;AAKhEC,wBALgE;AAMhE;AACA;AACA;AACA6I,mBAAS,KATuD;AAUhE;AACA;AACAZ,sEACGnJ,GAAGgK,kBADN,EAC2BhK,GAAGoI,OAD9B,gCAEGpI,GAAGiK,kBAFN,EAE2BjK,GAAGoI,OAF9B,gCAGGpI,GAAGkK,cAHN,EAGuBlK,GAAGmK,aAH1B,gCAIGnK,GAAGoK,cAJN,EAIuBpK,GAAGmK,aAJ1B;AAZgE,SAAvB,CAA3C;AAmBD,OAzB+D,CA2BhE;;;AACA,UAAIzI,KAAJ,EAAW;AACTmI,6BAAqBA,sBAAsB,EAA3C;AACAA,2BAAmB7J,GAAGqK,gBAAtB,IACE,IAAIrL,YAAJ,CAAiB,KAAKmB,EAAtB,EAA0B;AAACqE,kBAAQxE,GAAGsK,iBAAZ;AAA+BrJ,sBAA/B;AAAsCC;AAAtC,SAA1B,CADF;AAED,OAhC+D,CAkChE;;;AAEA,aAAO2I,kBAAP;AACD;;;sCAEuB;AAAA,UAAbhI,UAAa,UAAbA,UAAa;AACtB,WAAK1B,EAAL,CAAQoK,gBAAR,CAAyBvK,GAAGwK,YAA5B,EAA0C,KAAK1J,MAA/C;AACA,WAAKX,EAAL,CAAQsK,uBAAR,CAAgCzK,GAAG0C,WAAnC,EAAgDb,UAAhD,EAA4D7B,GAAGwK,YAA/D,EAA6E,IAA7E;AACA,aAAO,KAAKzJ,WAAL,CAAiBc,UAAjB,CAAP;AACD;;;gDAEsE;AAAA,qCAAlDA,UAAkD;AAAA,UAAlDA,UAAkD,kCAArC7B,GAAGoB,iBAAkC;AAAA,UAAfqC,YAAe,UAAfA,YAAe;AAAA,UAC9DtD,EAD8D,GACxD,IADwD,CAC9DA,EAD8D,EAErE;AACA;;AACAA,SAAGsK,uBAAH,CAA2BzK,GAAG0C,WAA9B,EAA2Cb,UAA3C,EAAuD7B,GAAGwK,YAA1D,EAAwE/G,aAAa3C,MAArF,EAJqE,CAKrE;AACA;;AAEA,WAAKC,WAAL,CAAiBc,UAAjB,IAA+B4B,YAA/B;AACD,K,CAED;AACA;;;;2CAC2E;AAAA,qCAA3D5B,UAA2D;AAAA,UAA3DA,UAA2D,kCAA9C7B,GAAGoB,iBAA2C;AAAA,UAAxBsC,OAAwB,UAAxBA,OAAwB;AAAA,UAAfC,KAAe,UAAfA,KAAe;AAAA,UAARC,KAAQ,UAARA,KAAQ;AAAA,UAClEzD,EADkE,GAC5D,IAD4D,CAClEA,EADkE;AAEzEA,SAAG8I,WAAH,CAAevF,QAAQ5B,MAAvB,EAA+B4B,QAAQ5C,MAAvC;;AAEA,cAAQ4C,QAAQ5B,MAAhB;AACA,aAAK9B,GAAGuH,gBAAR;AACA,aAAKvH,GAAGwH,UAAR;AACErH,aAAGuK,uBAAH,CAA2B1K,GAAG0C,WAA9B,EAA2Cb,UAA3C,EAAuD6B,QAAQ5B,MAA/D,EAAuE8B,KAAvE,EAA8ED,KAA9E;AACA;;AAEF,aAAK3D,GAAGqH,gBAAR;AACE;AACA,cAAMsD,OAAOC,sBAAsBjH,KAAtB,CAAb;AACAxD,aAAG0K,oBAAH,CAAwB7K,GAAG0C,WAA3B,EAAwCb,UAAxC,EAAoD8I,IAApD,EAA0DjH,QAAQ5C,MAAlE,EAA0E8C,KAA1E;AACA;;AAEF,aAAK5D,GAAGoH,UAAR;AACEjH,aAAG0K,oBAAH,CAAwB7K,GAAG0C,WAA3B,EAAwCb,UAAxC,EAAoD7B,GAAGoH,UAAvD,EAAmE1D,QAAQ5C,MAA3E,EAAmF8C,KAAnF;AACA;;AAEF;AACE7D,iBAAO,KAAP,EAAc,sBAAd;AAjBF;;AAoBAI,SAAG8I,WAAH,CAAevF,QAAQ5B,MAAvB,EAA+B,IAA/B;AACA,WAAKf,WAAL,CAAiBc,UAAjB,IAA+B6B,OAA/B;AACD,K,CAED;;;;mCACevD,E,EAAIgB,U,EAAY;AAC7B,UAAIzB,SAASS,EAAT,CAAJ,EAAkB;AAChBA,WAAGgB,UAAH,CAAcA,UAAd;AACD,OAFD,MAEO;AACL;AACApB,eAAOoB,eAAenB,GAAGoB,iBAAlB,IAAuCD,eAAenB,GAAG8K,IAAhE,EACE7K,0BADF;AAED;;AACD,WAAKkB,UAAL,GAAkBA,UAAlB;AACD,K,CAED;;;;oCACgBhB,E,EAAIkB,W,EAAa;AAC/B,UAAI3B,SAASS,EAAT,CAAJ,EAAkB;AAChBA,WAAGkB,WAAH,CAAeA,WAAf;AACD,OAFD,MAEO;AACL,YAAM0J,MAAM5K,GAAGO,YAAH,CAAgB,oBAAhB,CAAZ;;AACA,YAAIqK,GAAJ,EAAS;AACPA,cAAIC,gBAAJ,CAAqB3J,WAArB;AACD,SAFD,MAEO;AACL;AACAtB,iBAAOsB,YAAY4J,MAAZ,KAAuB,CAAvB,KACJ5J,YAAY,CAAZ,MAAmBrB,GAAGoB,iBAAtB,IAA2CC,YAAY,CAAZ,MAAmBrB,GAAG8K,IAD7D,CAAP,EAEE7K,0BAFF;AAGD;AACF;;AACD,WAAKoB,WAAL,GAAmBA,WAAnB;AACD,K,CAED;AACA;;AACA;;;;oDACgC0H,K,EAAO;AACrC,UAAMmC,OAAO7L,YAAY,KAAKc,EAAjB,CAAb;;AAEA,cAAQ4I,KAAR;AACA,aAAK/I,GAAGmL,oCAAR;AAA8C;AAC5C,iBAAO,CAACD,KAAKE,MAAN,GAAe,CAAf,GAAmB,IAA1B;;AACF,aAAKpL,GAAGqL,+BAAR,CAHA,CAGyC;;AACzC,aAAKrL,GAAGsL,iCAAR,CAJA,CAI2C;;AAC3C,aAAKtL,GAAGuL,gCAAR,CALA,CAK0C;;AAC1C,aAAKvL,GAAGwL,iCAAR,CANA,CAM2C;;AAC3C,aAAKxL,GAAGyL,iCAAR,CAPA,CAO2C;;AAC3C,aAAKzL,GAAG0L,mCAAR;AAA6C;AAC3C,iBAAO,CAACR,KAAKE,MAAN,GAAe,CAAf,GAAmB,IAA1B;;AACF,aAAKpL,GAAG2L,qCAAR;AAA+C;AAC7C,iBAAO,CAACT,KAAKE,MAAN,GAAepL,GAAG4L,YAAlB,GAAiC,IAAxC;;AACF,aAAK5L,GAAG6L,qCAAR;AACE,iBAAO,CAACX,KAAKE,MAAN,IAAgB,CAACF,KAAKY,QAAtB,GAAiC9L,GAAG+L,MAApC,GAA6C,IAApD;;AACF;AACE,iBAAO,IAAP;AAfF;AAiBD;AACD;AAEA;;;;oCAEgB;AACd,aAAO,KAAK5L,EAAL,CAAQ6L,iBAAR,EAAP;AACD;;;oCAEe;AACd,WAAK7L,EAAL,CAAQ8L,iBAAR,CAA0B,KAAKnL,MAA/B;AACD;;;gCAEWA,M,EAAQ;AAClB,aAAO,KAAKX,EAAL,CAAQsC,eAAR,CAAwBzC,GAAG0C,WAA3B,EAAwC5B,MAAxC,CAAP;AACD;;;wBAnpBW;AACV,aAAO,KAAKC,WAAL,CAAiBf,GAAGoB,iBAApB,KAA0C,IAAjD;AACD;;;wBAEa;AACZ,aAAO,KAAKL,WAAL,CAAiBf,GAAGoB,iBAApB,KAA0C,IAAjD;AACD;;;wBAEW;AACV,aAAO,KAAKL,WAAL,CAAiBf,GAAGqK,gBAApB,KAAyC,IAAhD;AACD;;;wBAEa;AACZ,aAAO,KAAKtJ,WAAL,CAAiBf,GAAGkM,kBAApB,KAA2C,IAAlD;AACD;;;;EA9DsCpN,Q,GAssBzC;AAEA;;;SAxsBqBoB,W;;AAysBrB,SAAS0K,qBAAT,CAA+BjH,KAA/B,EAAsC;AACpC;AACA;AACA,SAAOA,QAAQ3D,GAAGmM,2BAAX,GACLxI,QAAQ3D,GAAGmM,2BADN,GAELxI,KAFF;AAGD,C,CAED;AACA;;;AACA,SAASQ,qBAAT,CAA+BJ,MAA/B,EAAuC;AACrC;AACA,MAAMqI,SAASlM,YAAYkM,MAAZ,IAAsB,EAArC;AACA,SAAOA,OAAOrI,MAAP,iCAAuCA,MAAvC,CAAP;AACD","sourcesContent":["import Resource from './resource';\nimport Texture2D from './texture-2d';\nimport Renderbuffer from './renderbuffer';\nimport Buffer from './buffer';\nimport {clear, clearBuffer} from './clear';\n\nimport {withParameters} from '../webgl-context';\nimport {getFeatures} from '../webgl-context/context-features';\n\nimport {getTypedArrayFromGLType, getGLTypeFromTypedArray} from '../webgl-utils/typed-array-utils';\nimport {glFormatToComponents, glTypeToBytes} from '../webgl-utils/format-utils';\nimport {isWebGL2, assertWebGL2Context} from '../webgl-utils';\nimport {flipRows, scalePixels} from '../webgl-utils';\n\nimport {log} from '../utils';\nimport assert from '../utils/assert';\n\nimport GL from '../constants';\n\nconst ERR_MULTIPLE_RENDERTARGETS = 'Multiple render targets not supported';\n\nexport default class Framebuffer extends Resource {\n\n  static isSupported(gl, {\n    colorBufferFloat,    // Whether floating point textures can be rendered and read\n    colorBufferHalfFloat // Whether half float textures can be rendered and read\n  } = {}) {\n    let supported = true;\n    supported = colorBufferFloat &&\n      gl.getExtension(isWebGL2(gl) ? 'EXT_color_buffer_float' : 'WEBGL.color_buffer_float');\n    supported = colorBufferHalfFloat &&\n      gl.getExtension(isWebGL2(gl) ? 'EXT_color_buffer_float' : 'EXT_color_buffer_half_float');\n    return supported;\n  }\n\n  // Create a Framebuffer wrapper for the default framebuffer (target === null)\n  static getDefaultFramebuffer(gl) {\n    gl.luma = gl.luma || {};\n    gl.luma.defaultFramebuffer = gl.luma.defaultFramebuffer || new Framebuffer(gl, {\n      id: 'default-framebuffer',\n      handle: null,\n      attachments: {}\n    });\n    // TODO - can we query for and get a handle to the GL.FRONT renderbuffer?\n    return gl.luma.defaultFramebuffer;\n  }\n\n  get MAX_COLOR_ATTACHMENTS() {\n    return this.gl.getParameter(this.gl.MAX_COLOR_ATTACHMENTS);\n  }\n\n  get MAX_DRAW_BUFFERS() {\n    return this.gl.getParameter(this.gl.MAX_DRAW_BUFFERS);\n  }\n\n  constructor(gl, opts = {}) {\n    super(gl, opts);\n\n    // Public members\n    this.width = null;\n    this.height = null;\n    this.attachments = {};\n    this.readBuffer = GL.COLOR_ATTACHMENT0;\n    this.drawBuffers = [GL.COLOR_ATTACHMENT0];\n    this.initialize(opts);\n\n    Object.seal(this);\n  }\n\n  get color() {\n    return this.attachments[GL.COLOR_ATTACHMENT0] || null;\n  }\n\n  get texture() {\n    return this.attachments[GL.COLOR_ATTACHMENT0] || null;\n  }\n\n  get depth() {\n    return this.attachments[GL.DEPTH_ATTACHMENT] || null;\n  }\n\n  get stencil() {\n    return this.attachments[GL.STENCIL_ATTACHMENT] || null;\n  }\n\n  initialize({\n    width = 1,\n    height = 1,\n    attachments = null,\n    color = true,\n    depth = true,\n    stencil = false,\n    check = true,\n    readBuffer,\n    drawBuffers\n  }) {\n    assert(width >= 0 && height >= 0, 'Width and height need to be integers');\n\n    // Store actual width and height for diffing\n    this.width = width;\n    this.height = height;\n\n    // Resize any provided attachments - note that resize only resizes if needed\n    // Note: A framebuffer has no separate size, it is defined by its attachments (which must agree)\n    if (attachments) {\n      for (const attachment in attachments) {\n        const target = attachments[attachment];\n        const object = Array.isArray(target) ? target[0] : target;\n        object.resize({width, height});\n      }\n    } else {\n      // Create any requested default attachments\n      attachments = this._createDefaultAttachments({color, depth, stencil, width, height});\n    }\n\n    this.update({clearAttachments: true, attachments, readBuffer, drawBuffers});\n\n    // Checks that framebuffer was properly set up, if not, throws an explanatory error\n    if (attachments && check) {\n      this.checkStatus();\n    }\n  }\n\n  update({\n    attachments = {},\n    readBuffer,\n    drawBuffers,\n    clearAttachments = false\n  }) {\n    this.attach(attachments, {clearAttachments});\n\n    const {gl} = this;\n    // Multiple render target support, set read buffer and draw buffers\n    const prevHandle = gl.bindFramebuffer(GL.FRAMEBUFFER, this.handle);\n    if (readBuffer) {\n      this._setReadBuffer(readBuffer);\n    }\n    if (drawBuffers) {\n      this._setDrawBuffers(drawBuffers);\n    }\n    gl.bindFramebuffer(GL.FRAMEBUFFER, prevHandle || null);\n\n    return this;\n  }\n\n  // Attachment resize is expected to be a noop if size is same\n  resize({width, height} = {}) {\n    // for default framebuffer, just update the stored size\n    if (this.handle === null) {\n      assert(width === undefined && height === undefined);\n      this.width = this.gl.drawingBufferWidth;\n      this.height = this.gl.drawingBufferHeight;\n      return this;\n    }\n\n    if (width === undefined) {\n      width = this.gl.drawingBufferWidth;\n    }\n    if (height === undefined) {\n      height = this.gl.drawingBufferHeight;\n    }\n\n    if (width !== this.width && height !== this.height) {\n      log.log(2, `Resizing framebuffer ${this.id} to ${width}x${height}`);\n    }\n    for (const attachmentPoint in this.attachments) {\n      this.attachments[attachmentPoint].resize({width, height});\n    }\n    this.width = width;\n    this.height = height;\n    return this;\n  }\n\n  // Attach from a map of attachments\n  attach(attachments, {\n    clearAttachments = false\n  } = {}) {\n    const newAttachments = {};\n\n    // Any current attachments need to be removed, add null values to map\n    if (clearAttachments) {\n      Object.keys(this.attachments).forEach(key => {\n        newAttachments[key] = null;\n      });\n    }\n\n    // Overlay the new attachments\n    Object.assign(newAttachments, attachments);\n\n    const prevHandle = this.gl.bindFramebuffer(GL.FRAMEBUFFER, this.handle);\n\n    // Walk the attachments\n    for (const attachment in newAttachments) {\n      // Ensure key is not undefined\n      assert(attachment !== 'undefined', 'Misspelled framebuffer binding point?');\n\n      const descriptor = newAttachments[attachment];\n      let object = descriptor;\n      if (!object) {\n        this._unattach({attachment});\n      } else if (object instanceof Renderbuffer) {\n        this._attachRenderbuffer({attachment, renderbuffer: object});\n      } else if (Array.isArray(descriptor)) {\n        const [texture, layer = 0, level = 0] = descriptor;\n        object = texture;\n        this._attachTexture({attachment, texture, layer, level});\n      } else {\n        this._attachTexture({attachment, texture: object, layer: 0, level: 0});\n      }\n\n      // Resize objects\n      if (object) {\n        object.resize({width: this.width, height: this.height});\n      }\n    }\n\n    this.gl.bindFramebuffer(GL.FRAMEBUFFER, prevHandle || null);\n\n    // Assign to attachments and remove any nulls to get a clean attachment map\n    Object.assign(this.attachments, attachments);\n    Object.keys(this.attachments).filter(key => !this.attachments[key]).forEach(key => {\n      delete this.attachments[key];\n    });\n  }\n\n  checkStatus() {\n    const {gl} = this;\n    const prevHandle = gl.bindFramebuffer(GL.FRAMEBUFFER, this.handle);\n    const status = gl.checkFramebufferStatus(GL.FRAMEBUFFER);\n    gl.bindFramebuffer(GL.FRAMEBUFFER, prevHandle || null);\n    if (status !== gl.FRAMEBUFFER_COMPLETE) {\n      throw new Error(_getFrameBufferStatus(status));\n    }\n    return this;\n  }\n\n  clear({\n    color,\n    depth,\n    stencil,\n    drawBuffers = []\n  } = {}) {\n    // Bind framebuffer and delegate to global clear functions\n    const prevHandle = this.gl.bindFramebuffer(GL.FRAMEBUFFER, this.handle);\n\n    if (color || depth || stencil) {\n      clear(this.gl, {color, depth, stencil});\n    }\n\n    drawBuffers.forEach((value, drawBuffer) => {\n      clearBuffer({drawBuffer, value});\n    });\n\n    this.gl.bindFramebuffer(GL.FRAMEBUFFER, prevHandle || null);\n\n    return this;\n  }\n\n  // NOTE: Slow requires roundtrip to GPU\n  // App can provide pixelArray or have it auto allocated by this method\n  // @returns {Uint8Array|Uint16Array|FloatArray} - pixel array,\n  //  newly allocated by this method unless provided by app.\n  readPixels({\n    x = 0,\n    y = 0,\n    width = this.width,\n    height = this.height,\n    format = GL.RGBA,\n    type, // Auto deduced from pixelArray or gl.UNSIGNED_BYTE\n    pixelArray = null,\n    attachment = GL.COLOR_ATTACHMENT0 // TODO - support gl.readBuffer\n  }) {\n    const {gl} = this;\n\n    // TODO - Set and unset gl.readBuffer\n    if (attachment === GL.COLOR_ATTACHMENT0 && this.handle === null) {\n      attachment = GL.FRONT;\n    }\n\n    // Deduce type and allocated pixelArray if needed\n    if (!pixelArray) {\n      // Allocate pixel array if not already available, using supplied type\n      type = type || gl.UNSIGNED_BYTE;\n      const ArrayType = getTypedArrayFromGLType(type, {clamped: false});\n      const components = glFormatToComponents(format);\n      // TODO - check for composite type (components = 1).\n      pixelArray = pixelArray || new ArrayType(width * height * components);\n    }\n\n    // Pixel array available, if necessary, deduce type from it.\n    type = type || getGLTypeFromTypedArray(pixelArray);\n\n    const prevHandle = this.gl.bindFramebuffer(GL.FRAMEBUFFER, this.handle);\n    this.gl.readPixels(x, y, width, height, format, type, pixelArray);\n    this.gl.bindFramebuffer(GL.FRAMEBUFFER, prevHandle || null);\n\n    return pixelArray;\n  }\n\n  // Reads data into provided buffer object asynchronously\n  // This function doesn't wait for copy to be complete, it programs GPU to perform a DMA transffer.\n  readPixelsToBuffer({\n    x = 0,\n    y = 0,\n    width = this.width,\n    height = this.height,\n    format = GL.RGBA,\n    type, // When not provided, auto deduced from buffer or GL.UNSIGNED_BYTE\n    buffer = null, // A new Buffer object is created when not provided.\n    byteOffset = 0 // byte offset in buffer object\n  }) {\n    const {gl} = this;\n\n    // Asynchronus read (PIXEL_PACK_BUFFER) is WebGL2 only feature\n    assertWebGL2Context(gl);\n\n    // deduce type if not available.\n    type = type || (buffer ? buffer.type : GL.UNSIGNED_BYTE);\n\n    if (!buffer) {\n      // Create new buffer with enough size\n      const components = glFormatToComponents(format);\n      const byteCount = glTypeToBytes(type);\n      const bytes = byteOffset + (width * height * components * byteCount);\n      buffer = new Buffer(gl, {\n        bytes,\n        type,\n        size: components\n      });\n    }\n\n    buffer.bind({target: GL.PIXEL_PACK_BUFFER});\n    withParameters(gl, {framebuffer: this}, () => {\n      gl.readPixels(x, y, width, height, format, type, byteOffset);\n    });\n    buffer.unbind({target: GL.PIXEL_PACK_BUFFER});\n\n    return buffer;\n  }\n\n  // Reads pixels as a dataUrl\n  copyToDataUrl({\n    attachment = GL.COLOR_ATTACHMENT0, // TODO - support gl.readBuffer\n    maxHeight = Number.MAX_SAFE_INTEGER\n  } = {}) {\n    let data = this.readPixels({attachment});\n\n    // Scale down\n    let {width, height} = this;\n    while (height > maxHeight) {\n      ({data, width, height} = scalePixels({data, width, height}));\n    }\n\n    // Flip to top down coordinate system\n    flipRows({data, width, height});\n\n    /* global document */\n    const canvas = document.createElement('canvas');\n    canvas.width = width;\n    canvas.height = height;\n    const context = canvas.getContext('2d');\n\n    // Copy the pixels to a 2D canvas\n    const imageData = context.createImageData(width, height);\n    imageData.data.set(data);\n    context.putImageData(imageData, 0, 0);\n\n    return canvas.toDataURL();\n  }\n\n  // Reads pixels into an HTML Image\n  copyToImage({\n    image = null,\n    attachment = GL.COLOR_ATTACHMENT0, // TODO - support gl.readBuffer\n    maxHeight = Number.MAX_SAFE_INTEGER\n  } = {}) {\n    /* global Image */\n    const dataUrl = this.readDataUrl({attachment});\n    image = image || new Image();\n    image.src = dataUrl;\n    return image;\n  }\n\n  // copyToFramebuffer({width, height}) {\n  //   const scaleX = width / this.width;\n  //   const scaleY = height / this.height;\n  //   const scale = Math.min(scaleX, scaleY);\n  //   width = width * scale;\n  //   height = height * scale;\n  //   const scaledFramebuffer = new Framebuffer(this.gl, {width, height});\n  //   this.blit();\n  // }\n\n  // Copy a rectangle from a framebuffer attachment into a texture (at an offset)\n  copyToTexture({\n    // Target\n    texture,\n    target, // for cubemaps\n    xoffset = 0,\n    yoffset = 0,\n    zoffset = 0,\n    mipmapLevel = 0,\n\n    // Source\n    attachment = GL.COLOR_ATTACHMENT0, // TODO - support gl.readBuffer\n    x = 0,\n    y = 0,\n    width, // defaults to texture width\n    height // defaults to texture height\n  }) {\n    const {gl} = this;\n    const prevHandle = gl.bindFramebuffer(GL.FRAMEBUFFER, this.handle);\n    const prevBuffer = gl.readBuffer(attachment);\n\n    width = Number.isFinite(width) ? width : texture.width;\n    height = Number.isFinite(height) ? height : texture.height;\n\n    // target\n    switch (texture.target) {\n    case GL.TEXTURE_2D:\n    case GL.TEXTURE_CUBE_MAP:\n      gl.copyTexSubImage2D(\n        target || texture.target,\n        mipmapLevel,\n        xoffset,\n        yoffset,\n        x,\n        y,\n        width,\n        height\n      );\n      break;\n    case GL.TEXTURE_2D_ARRAY:\n    case GL.TEXTURE_3D:\n      gl.copyTexSubImage3D(\n        target || texture.target,\n        mipmapLevel,\n        xoffset,\n        yoffset,\n        zoffset,\n        x,\n        y,\n        width,\n        height\n      );\n      break;\n    default:\n    }\n\n    gl.readBuffer(prevBuffer);\n    gl.bindFramebuffer(GL.FRAMEBUFFER, prevHandle || null);\n    return texture;\n  }\n\n  // WEBGL2 INTERFACE\n\n  // Copies a rectangle of pixels between framebuffers\n  blit({\n    srcFramebuffer,\n    attachment = GL.COLOR_ATTACHMENT0,\n    srcX0 = 0, srcY0 = 0, srcX1, srcY1,\n    dstX0 = 0, dstY0 = 0, dstX1, dstY1,\n    color = true,\n    depth = false,\n    stencil = false,\n    mask = 0,\n    filter = GL.NEAREST\n  }) {\n    const {gl} = this;\n    assertWebGL2Context(gl);\n\n    if (!srcFramebuffer.handle && attachment === GL.COLOR_ATTACHMENT0) {\n      attachment = GL.FRONT;\n    }\n\n    if (color) {\n      mask |= GL.COLOR_BUFFER_BIT;\n    }\n    if (depth) {\n      mask |= GL.DEPTH_BUFFER_BIT;\n    }\n    if (stencil) {\n      mask |= GL.STENCIL_BUFFER_BIT;\n    }\n    assert(mask);\n\n    srcX1 = srcX1 === undefined ? srcFramebuffer.width : srcX1;\n    srcY1 = srcY1 === undefined ? srcFramebuffer.height : srcY1;\n    dstX1 = dstX1 === undefined ? this.width : dstX1;\n    dstY1 = dstY1 === undefined ? this.height : dstY1;\n\n    const prevDrawHandle = gl.bindFramebuffer(GL.DRAW_FRAMEBUFFER, this.handle);\n    const prevReadHandle = gl.bindFramebuffer(GL.READ_FRAMEBUFFER, srcFramebuffer.handle);\n    gl.readBuffer(attachment);\n    gl.blitFramebuffer(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);\n    gl.readBuffer(this.readBuffer);\n    gl.bindFramebuffer(GL.READ_FRAMEBUFFER, prevReadHandle || null);\n    gl.bindFramebuffer(GL.DRAW_FRAMEBUFFER, prevDrawHandle || null);\n\n    return this;\n  }\n\n  // signals to the GL that it need not preserve all pixels of a specified region of the framebuffer\n  invalidate({attachments = [], x = 0, y = 0, width, height}) {\n    const {gl} = this;\n    assertWebGL2Context(gl);\n    const prevHandle = gl.bindFramebuffer(GL.READ_FRAMEBUFFER, this.handle);\n    const invalidateAll = x === 0 && y === 0 && width === undefined && height === undefined;\n    if (invalidateAll) {\n      gl.invalidateFramebuffer(GL.READ_FRAMEBUFFER, attachments);\n    } else {\n      gl.invalidateFramebuffer(GL.READ_FRAMEBUFFER, attachments, x, y, width, height);\n    }\n    gl.bindFramebuffer(GL.READ_FRAMEBUFFER, prevHandle);\n    return this;\n  }\n\n  // Return the value for `pname` of the specified attachment.\n  // The type returned is the type of the requested pname\n  getAttachmentParameter({attachment = GL.COLOR_ATTACHMENT0, pname} = {}) {\n    let value = this._getAttachmentParameterFallback(pname);\n    if (value === null) {\n      this.gl.bindTexture(GL.FRAMEBUFFER, this.handle);\n      value = this.gl.getFramebufferAttachmentParameter(GL.FRAMEBUFFER, attachment, pname);\n      this.gl.bindTexture(GL.FRAMEBUFFER, null);\n    }\n    return value;\n  }\n\n  getAttachmentParameters(\n    attachment = GL.COLOR_ATTACHMENT0,\n    parameters = this.constructor.ATTACHMENT_PARAMETERS || {}\n  ) {\n    const values = {};\n    for (const pname in parameters) {\n      values[pname] = this.getAttachmentParameter(pname);\n    }\n    return this;\n  }\n\n  // DEBUG\n\n  // Note: Will only work when called in an event handler\n  show() {\n    /* global window */\n    if (typeof window !== 'undefined') {\n      window.open(this.copyToDataUrl(), 'luma-debug-texture');\n    }\n    return this;\n  }\n\n  log(priority = 0, message = '') {\n    if (priority > log.priority || typeof window === 'undefined') {\n      return this;\n    }\n    message = message || `Framebuffer ${this.id}`;\n    const image = this.copyToDataUrl({maxHeight: 100});\n    log.image({priority, message, image}, message)();\n    return this;\n  }\n\n  // WEBGL INTERFACE\n  bind({target = GL.FRAMEBUFFER} = {}) {\n    this.gl.bindFramebuffer(target, this.handle);\n    return this;\n  }\n\n  unbind({target = GL.FRAMEBUFFER} = {}) {\n    this.gl.bindFramebuffer(target, null);\n    return this;\n  }\n\n  // PRIVATE METHODS\n\n  _createDefaultAttachments({color, depth, stencil, width, height}) {\n    let defaultAttachments = null;\n\n    // Add a color buffer if requested and not supplied\n    if (color) {\n      defaultAttachments = defaultAttachments || {};\n      defaultAttachments[GL.COLOR_ATTACHMENT0] = new Texture2D(this.gl, {\n        pixels: null, // reserves texture memory, but texels are undefined\n        format: GL.RGBA,\n        type: GL.UNSIGNED_BYTE,\n        width,\n        height,\n        // Note: Mipmapping can be disabled by texture resource when we resize the texture\n        // to a non-power-of-two dimenstion (NPOT texture) under WebGL1. To have consistant\n        // behavior we always disable mipmaps.\n        mipmaps: false,\n        // Set MIN and MAG filtering parameters so mipmaps are not used in sampling.\n        // Set WRAP modes that support NPOT textures too.\n        parameters: {\n          [GL.TEXTURE_MIN_FILTER]: GL.NEAREST,\n          [GL.TEXTURE_MAG_FILTER]: GL.NEAREST,\n          [GL.TEXTURE_WRAP_S]: GL.CLAMP_TO_EDGE,\n          [GL.TEXTURE_WRAP_T]: GL.CLAMP_TO_EDGE\n        }\n      });\n    }\n\n    // Add a depth buffer if requested and not supplied\n    if (depth) {\n      defaultAttachments = defaultAttachments || {};\n      defaultAttachments[GL.DEPTH_ATTACHMENT] =\n        new Renderbuffer(this.gl, {format: GL.DEPTH_COMPONENT16, width, height});\n    }\n\n    // TODO - handle stencil and combined depth and stencil\n\n    return defaultAttachments;\n  }\n\n  _unattach({attachment}) {\n    this.gl.bindRenderbuffer(GL.RENDERBUFFER, this.handle);\n    this.gl.framebufferRenderbuffer(GL.FRAMEBUFFER, attachment, GL.RENDERBUFFER, null);\n    delete this.attachments[attachment];\n  }\n\n  _attachRenderbuffer({attachment = GL.COLOR_ATTACHMENT0, renderbuffer}) {\n    const {gl} = this;\n    // TODO - is the bind needed?\n    // gl.bindRenderbuffer(GL.RENDERBUFFER, renderbuffer.handle);\n    gl.framebufferRenderbuffer(GL.FRAMEBUFFER, attachment, GL.RENDERBUFFER, renderbuffer.handle);\n    // TODO - is the unbind needed?\n    // gl.bindRenderbuffer(GL.RENDERBUFFER, null);\n\n    this.attachments[attachment] = renderbuffer;\n  }\n\n  // layer = 0 - index into Texture2DArray and Texture3D or face for `TextureCubeMap`\n  // level = 0 - mipmapLevel (must be 0 in WebGL1)\n  _attachTexture({attachment = GL.COLOR_ATTACHMENT0, texture, layer, level}) {\n    const {gl} = this;\n    gl.bindTexture(texture.target, texture.handle);\n\n    switch (texture.target) {\n    case GL.TEXTURE_2D_ARRAY:\n    case GL.TEXTURE_3D:\n      gl.framebufferTextureLayer(GL.FRAMEBUFFER, attachment, texture.target, level, layer);\n      break;\n\n    case GL.TEXTURE_CUBE_MAP:\n      // layer must be a cubemap face (or if index, converted to cube map face)\n      const face = mapIndexToCubeMapFace(layer);\n      gl.framebufferTexture2D(GL.FRAMEBUFFER, attachment, face, texture.handle, level);\n      break;\n\n    case GL.TEXTURE_2D:\n      gl.framebufferTexture2D(GL.FRAMEBUFFER, attachment, GL.TEXTURE_2D, texture.handle, level);\n      break;\n\n    default:\n      assert(false, 'Illegal texture type');\n    }\n\n    gl.bindTexture(texture.target, null);\n    this.attachments[attachment] = texture;\n  }\n\n  // Expects framebuffer to be bound\n  _setReadBuffer(gl, readBuffer) {\n    if (isWebGL2(gl)) {\n      gl.readBuffer(readBuffer);\n    } else {\n      // Setting to color attachment 0 is a noop, so allow it in WebGL1\n      assert(readBuffer === GL.COLOR_ATTACHMENT0 || readBuffer === GL.BACK,\n        ERR_MULTIPLE_RENDERTARGETS);\n    }\n    this.readBuffer = readBuffer;\n  }\n\n  // Expects framebuffer to be bound\n  _setDrawBuffers(gl, drawBuffers) {\n    if (isWebGL2(gl)) {\n      gl.drawBuffers(drawBuffers);\n    } else {\n      const ext = gl.getExtension('WEBGL.draw_buffers');\n      if (ext) {\n        ext.drawBuffersWEBGL(drawBuffers);\n      } else {\n        // Setting a single draw buffer to color attachment 0 is a noop, allow in WebGL1\n        assert(drawBuffers.length === 1 &&\n          (drawBuffers[0] === GL.COLOR_ATTACHMENT0 || drawBuffers[0] === GL.BACK),\n          ERR_MULTIPLE_RENDERTARGETS);\n      }\n    }\n    this.drawBuffers = drawBuffers;\n  }\n\n  // Attempt to provide workable defaults for WebGL2 symbols under WebGL1\n  // null means OK to query\n  /* eslint-disable complexity */\n  _getAttachmentParameterFallback(pname) {\n    const caps = getFeatures(this.gl);\n\n    switch (pname) {\n    case GL.FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER: // GLint\n      return !caps.webgl2 ? 0 : null;\n    case GL.FRAMEBUFFER_ATTACHMENT_RED_SIZE: // GLint\n    case GL.FRAMEBUFFER_ATTACHMENT_GREEN_SIZE: // GLint\n    case GL.FRAMEBUFFER_ATTACHMENT_BLUE_SIZE: // GLint\n    case GL.FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE: // GLint\n    case GL.FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE: // GLint\n    case GL.FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE: // GLint\n      return !caps.webgl2 ? 8 : null;\n    case GL.FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE: // GLenum\n      return !caps.webgl2 ? GL.UNSIGNED_INT : null;\n    case GL.FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING:\n      return !caps.webgl2 && !caps.EXT_sRGB ? GL.LINEAR : null;\n    default:\n      return null;\n    }\n  }\n  /* eslint-enable complexity */\n\n  // RESOURCE METHODS\n\n  _createHandle() {\n    return this.gl.createFramebuffer();\n  }\n\n  _deleteHandle() {\n    this.gl.deleteFramebuffer(this.handle);\n  }\n\n  _bindHandle(handle) {\n    return this.gl.bindFramebuffer(GL.FRAMEBUFFER, handle);\n  }\n}\n\n// PUBLIC METHODS\n\n// Map an index to a cube map face constant\nfunction mapIndexToCubeMapFace(layer) {\n  // TEXTURE_CUBE_MAP_POSITIVE_X is a big value (0x8515)\n  // if smaller assume layer is index, otherwise assume it is already a cube map face constant\n  return layer < GL.TEXTURE_CUBE_MAP_POSITIVE_X ?\n    layer + GL.TEXTURE_CUBE_MAP_POSITIVE_X :\n    layer;\n}\n\n// Helper METHODS\n// Get a string describing the framebuffer error if installed\nfunction _getFrameBufferStatus(status) {\n  // Use error mapping if installed\n  const STATUS = Framebuffer.STATUS || {};\n  return STATUS[status] || `Framebuffer error ${status}`;\n}\n"],"file":"framebuffer.js"}