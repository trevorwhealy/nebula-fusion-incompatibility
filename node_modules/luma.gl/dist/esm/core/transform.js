function _instanceof(left, right) { if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) { return right[Symbol.hasInstance](left); } else { return left instanceof right; } }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!_instanceof(instance, Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

import GL from '../constants';
import Model from './model';
import Buffer from '../webgl/buffer';
import TransformFeedback from '../webgl/transform-feedback';
import { isWebGL2, assertWebGL2Context, getShaderVersion } from '../webgl-utils';
import assert from '../utils/assert';
import { log } from '../utils';
var FS100 = 'void main() {}';
var FS300 = "#version 300 es\n".concat(FS100);

var Transform =
/*#__PURE__*/
function () {
  _createClass(Transform, null, [{
    key: "isSupported",
    value: function isSupported(gl) {
      // For now WebGL2 only
      return isWebGL2(gl);
    }
  }]);

  function Transform(gl) {
    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, Transform);

    assertWebGL2Context(gl);
    this.gl = gl;
    this.model = null;
    this.currentIndex = 0;
    this.sourceBuffers = new Array(2);
    this.feedbackBuffers = new Array(2);
    this.transformFeedbacks = new Array(2);
    this._buffersCreated = {};

    this._initialize(opts);

    Object.seal(this);
  } // Delete owned resources.


  _createClass(Transform, [{
    key: "delete",
    value: function _delete() {
      for (var name in this._buffersCreated) {
        this._buffersCreated[name].delete();
      }

      this.model.delete();
    }
  }, {
    key: "getBuffer",
    // Return Buffer object for given varying name.
    value: function getBuffer() {
      var varyingName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      assert(varyingName && this.feedbackBuffers[this.currentIndex][varyingName]);
      return this.feedbackBuffers[this.currentIndex][varyingName];
    } // Run one transform feedback loop.

  }, {
    key: "run",
    value: function run() {
      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref$uniforms = _ref.uniforms,
          uniforms = _ref$uniforms === void 0 ? {} : _ref$uniforms,
          _ref$unbindModels = _ref.unbindModels,
          unbindModels = _ref$unbindModels === void 0 ? [] : _ref$unbindModels;

      this.model.setAttributes(this.sourceBuffers[this.currentIndex]);
      this.model.transform({
        transformFeedback: this.transformFeedbacks[this.currentIndex],
        parameters: _defineProperty({}, GL.RASTERIZER_DISCARD, true),
        uniforms: uniforms,
        unbindModels: unbindModels
      });
    } // Swap source and destination buffers.

  }, {
    key: "swapBuffers",
    value: function swapBuffers() {
      assert(this.feedbackMap);
      this.currentIndex = (this.currentIndex + 1) % 2;
    } // Update some or all buffer bindings.

  }, {
    key: "update",
    value: function update(_ref2) {
      var _ref2$sourceBuffers = _ref2.sourceBuffers,
          sourceBuffers = _ref2$sourceBuffers === void 0 ? null : _ref2$sourceBuffers,
          _ref2$feedbackBuffers = _ref2.feedbackBuffers,
          feedbackBuffers = _ref2$feedbackBuffers === void 0 ? null : _ref2$feedbackBuffers,
          _ref2$elementCount = _ref2.elementCount,
          elementCount = _ref2$elementCount === void 0 ? this.elementCount : _ref2$elementCount;

      if (!sourceBuffers && !feedbackBuffers) {
        log.warn('Transform : no buffers updated')();
        return this;
      }

      this.model.setVertexCount(elementCount);

      for (var bufferName in feedbackBuffers) {
        assert(_instanceof(feedbackBuffers[bufferName], Buffer));
      }

      var currentIndex = this.currentIndex;
      Object.assign(this.sourceBuffers[currentIndex], sourceBuffers);
      Object.assign(this.feedbackBuffers[currentIndex], feedbackBuffers);

      this._createFeedbackBuffers({
        feedbackBuffers: feedbackBuffers
      });

      this.transformFeedbacks[currentIndex].setBuffers(this.feedbackBuffers[currentIndex]); // Buffer have changed, need to re-setup swap buffers.

      this._setupSwapBuffers();

      return this;
    } // Private

  }, {
    key: "_initialize",
    value: function _initialize(_ref3) {
      var _ref3$id = _ref3.id,
          id = _ref3$id === void 0 ? 'transform' : _ref3$id,
          vs = _ref3.vs,
          varyings = _ref3.varyings,
          _ref3$drawMode = _ref3.drawMode,
          drawMode = _ref3$drawMode === void 0 ? GL.POINTS : _ref3$drawMode,
          elementCount = _ref3.elementCount,
          sourceBuffers = _ref3.sourceBuffers,
          _ref3$feedbackBuffers = _ref3.feedbackBuffers,
          feedbackBuffers = _ref3$feedbackBuffers === void 0 ? null : _ref3$feedbackBuffers,
          _ref3$feedbackMap = _ref3.feedbackMap,
          feedbackMap = _ref3$feedbackMap === void 0 ? null : _ref3$feedbackMap,
          _ref3$destinationBuff = _ref3.destinationBuffers,
          destinationBuffers = _ref3$destinationBuff === void 0 ? null : _ref3$destinationBuff,
          _ref3$sourceDestinati = _ref3.sourceDestinationMap,
          sourceDestinationMap = _ref3$sourceDestinati === void 0 ? null : _ref3$sourceDestinati;

      if (destinationBuffers) {
        log.deprecated('destinationBuffers', 'feedbackBuffers')();
        feedbackBuffers = feedbackBuffers || destinationBuffers;
      }

      if (sourceDestinationMap) {
        log.deprecated('sourceDestinationMap', 'feedbackMap')();
        feedbackMap = feedbackMap || sourceDestinationMap;
      }

      assert(sourceBuffers && vs && elementCount >= 0); // If feedbackBuffers are not provided, sourceDestinationMap must be provided
      // to create destinaitonBuffers with layout of corresponding source buffer.

      assert(feedbackBuffers || feedbackMap, ' Transform needs feedbackBuffers or feedbackMap');

      for (var bufferName in feedbackBuffers || {}) {
        assert(_instanceof(feedbackBuffers[bufferName], Buffer));
      } // If varyings are not provided feedbackMap must be provided to deduce varyings


      assert(Array.isArray(varyings) || feedbackMap);
      var varyingsArray = varyings;

      if (!Array.isArray(varyings)) {
        varyingsArray = Object.values(feedbackMap);
      }

      this.feedbackMap = feedbackMap;

      this._setupBuffers({
        sourceBuffers: sourceBuffers,
        feedbackBuffers: feedbackBuffers
      });

      this._setupSwapBuffers();

      this._buildModel({
        id: id,
        vs: vs,
        varyings: varyingsArray,
        drawMode: drawMode,
        elementCount: elementCount
      });
    } // setup source and destination buffers

  }, {
    key: "_setupBuffers",
    value: function _setupBuffers(_ref4) {
      var _ref4$sourceBuffers = _ref4.sourceBuffers,
          sourceBuffers = _ref4$sourceBuffers === void 0 ? null : _ref4$sourceBuffers,
          _ref4$feedbackBuffers = _ref4.feedbackBuffers,
          feedbackBuffers = _ref4$feedbackBuffers === void 0 ? null : _ref4$feedbackBuffers;
      this.sourceBuffers[0] = Object.assign({}, sourceBuffers);
      this.feedbackBuffers[0] = Object.assign({}, feedbackBuffers);

      this._createFeedbackBuffers({
        feedbackBuffers: feedbackBuffers
      });

      this.sourceBuffers[1] = {};
      this.feedbackBuffers[1] = {};
    } // auto create any feedback buffers

  }, {
    key: "_createFeedbackBuffers",
    value: function _createFeedbackBuffers(_ref5) {
      var feedbackBuffers = _ref5.feedbackBuffers;

      if (!this.feedbackMap) {
        // feedbackMap required to auto create buffers.
        return;
      }

      var current = this.currentIndex;

      for (var sourceBufferName in this.feedbackMap) {
        var feedbackBufferName = this.feedbackMap[sourceBufferName];

        if (!feedbackBuffers || !feedbackBuffers[feedbackBufferName]) {
          // Create new buffer with same layout and settings as source buffer
          var sourceBuffer = this.sourceBuffers[current][sourceBufferName];
          var bytes = sourceBuffer.bytes,
              type = sourceBuffer.type,
              usage = sourceBuffer.usage,
              accessor = sourceBuffer.accessor;
          var buffer = new Buffer(this.gl, {
            bytes: bytes,
            type: type,
            usage: usage,
            accessor: accessor
          });

          if (this._buffersCreated[feedbackBufferName]) {
            this._buffersCreated[feedbackBufferName].delete();

            this._buffersCreated[feedbackBufferName] = buffer;
          }

          this.feedbackBuffers[current][feedbackBufferName] = buffer;
        }
      }
    } // setup buffers for swapping.
    // Second set of source and feedback objects are setup to point
    // to corresponding feedback and source buffers.

  }, {
    key: "_setupSwapBuffers",
    value: function _setupSwapBuffers() {
      if (!this.feedbackMap) {
        // feedbackMap required set up swap buffers.
        return;
      }

      var current = this.currentIndex;
      var next = (current + 1) % 2;

      for (var sourceBufferName in this.feedbackMap) {
        var feedbackBufferName = this.feedbackMap[sourceBufferName];
        this.sourceBuffers[next][sourceBufferName] = this.feedbackBuffers[current][feedbackBufferName];
        this.feedbackBuffers[next][feedbackBufferName] = this.sourceBuffers[current][sourceBufferName]; // make sure the new destination buffer is a Buffer object

        assert(_instanceof(this.feedbackBuffers[next][feedbackBufferName], Buffer));
      } // When triggered by `update()` TranformFeedback objects are already set up,
      // if so update buffers


      if (this.transformFeedbacks[next]) {
        this.transformFeedbacks[next].setBuffers(this.feedbackBuffers[next]);
      }
    } // build Model and TransformFeedback objects

  }, {
    key: "_buildModel",
    value: function _buildModel(_ref6) {
      var id = _ref6.id,
          vs = _ref6.vs,
          varyings = _ref6.varyings,
          drawMode = _ref6.drawMode,
          elementCount = _ref6.elementCount;
      // use a minimal fragment shader with matching version of vertex shader.
      var fs = getShaderVersion(vs) === 300 ? FS300 : FS100;
      this.model = new Model(this.gl, {
        id: id,
        vs: vs,
        fs: fs,
        varyings: varyings,
        drawMode: drawMode,
        vertexCount: elementCount
      });
      this.transformFeedbacks[0] = new TransformFeedback(this.gl, {
        program: this.model.program,
        buffers: this.feedbackBuffers[0]
      }); // If buffers are swappable setup second transform feedback object.

      if (this.feedbackMap) {
        this.transformFeedbacks[1] = new TransformFeedback(this.gl, {
          program: this.model.program,
          buffers: this.feedbackBuffers[1]
        });
      }
    }
  }, {
    key: "elementCount",
    get: function get() {
      return this.model.getVertexCount();
    }
  }]);

  return Transform;
}();

export { Transform as default };
//# sourceMappingURL=transform.js.map