"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = pickModels;

var _webgl = require("../webgl");

var _group = _interopRequireDefault(require("./group"));

var _assert = _interopRequireDefault(require("../utils/assert"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function getDevicePixelRatio() {
  return typeof window !== 'undefined' ? window.devicePixelRatio : 1;
}

function pickModels(gl, props) {
  var models = props.models,
      position = props.position,
      _props$uniforms = props.uniforms,
      uniforms = _props$uniforms === void 0 ? {} : _props$uniforms,
      _props$parameters = props.parameters,
      parameters = _props$parameters === void 0 ? {} : _props$parameters,
      settings = props.settings,
      _props$useDevicePixel = props.useDevicePixels,
      useDevicePixels = _props$useDevicePixel === void 0 ? true : _props$useDevicePixel,
      framebuffer = props.framebuffer,
      context = props.context;
  (0, _assert.default)((0, _webgl.isWebGL)(gl) && framebuffer && position);

  var _position = _slicedToArray(position, 2),
      x = _position[0],
      y = _position[1]; // Match our picking framebuffer with the size of the canvas drawing buffer


  framebuffer.resize({
    width: gl.canvas.width,
    height: gl.canvas.height
  }); // Compensate for devicePixelRatio
  // Note: this assumes the canvas framebuffer has been matched

  var dpr = useDevicePixels ? getDevicePixelRatio() : 1; // Reverse the y coordinate

  var deviceX = x * dpr;
  var deviceY = gl.canvas.height - y * dpr; // return withParameters(gl, {
  //   // framebuffer,
  //   // // We are only interested in one pixel, no need to render anything else
  //   // scissorTest: {x: deviceX, y: deviceY, w: 1, h: 1}
  // }, () => {

  var group = new _group.default({
    children: models
  });
  return group.traverseReverse(function (model) {
    if (model.pickable) {
      // Clear the frame buffer
      (0, _webgl.clear)(gl, {
        framebuffer: framebuffer,
        color: true,
        depth: true
      }); // Render picking colors

      /* eslint-disable camelcase */

      model.setUniforms({
        picking_uActive: 1
      });
      model.draw(Object.assign({}, props, {
        uniforms: uniforms,
        parameters: parameters,
        settings: settings,
        framebuffer: framebuffer,
        context: context
      }));
      model.setUniforms({
        picking_uActive: 0
      }); // Sample Read color in the central pixel, to be mapped as a picking color

      var color = framebuffer.readPixels({
        x: deviceX,
        y: deviceY,
        width: 1,
        height: 1,
        format: gl.RGBA,
        type: gl.UNSIGNED_BYTE
      });
      var isPicked = color[0] !== 0 || color[1] !== 0 || color[2] !== 0; // Add the information to the stack

      if (isPicked) {
        return {
          model: model,
          color: color,
          x: x,
          y: y,
          deviceX: deviceX,
          deviceY: deviceY
        };
      }
    }

    return null;
  }); // });
}
//# sourceMappingURL=pick-models.js.map