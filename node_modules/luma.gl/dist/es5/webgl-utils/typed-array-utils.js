"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getGLTypeFromTypedArray = getGLTypeFromTypedArray;
exports.getTypedArrayFromGLType = getTypedArrayFromGLType;
exports.flipRows = flipRows;
exports.scalePixels = scalePixels;

var _constants = _interopRequireDefault(require("../constants"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var ERR_TYPE_DEDUCTION = 'Failed to deduce GL constant from typed array'; // Converts TYPED ARRAYS to corresponding GL constant
// Used to auto deduce gl parameter types

function getGLTypeFromTypedArray(arrayOrType) {
  // If typed array, look up constructor
  var type = ArrayBuffer.isView(arrayOrType) ? arrayOrType.constructor : arrayOrType;

  switch (type) {
    case Float32Array:
      return _constants.default.FLOAT;

    case Uint16Array:
      return _constants.default.UNSIGNED_SHORT;

    case Uint32Array:
      return _constants.default.UNSIGNED_INT;

    case Uint8Array:
      return _constants.default.UNSIGNED_BYTE;

    case Uint8ClampedArray:
      return _constants.default.UNSIGNED_BYTE;

    case Int8Array:
      return _constants.default.BYTE;

    case Int16Array:
      return _constants.default.SHORT;

    case Int32Array:
      return _constants.default.INT;

    default:
      throw new Error(ERR_TYPE_DEDUCTION);
  }
} // Converts GL constant to corresponding TYPED ARRAY
// Used to auto deduce gl parameter types

/* eslint-disable complexity */


function getTypedArrayFromGLType(glType) {
  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      _ref$clamped = _ref.clamped,
      clamped = _ref$clamped === void 0 ? true : _ref$clamped;

  // Sorted in some order of likelihood to reduce amount of comparisons
  switch (glType) {
    case _constants.default.FLOAT:
      return Float32Array;

    case _constants.default.UNSIGNED_SHORT:
    case _constants.default.UNSIGNED_SHORT_5_6_5:
    case _constants.default.UNSIGNED_SHORT_4_4_4_4:
    case _constants.default.UNSIGNED_SHORT_5_5_5_1:
      return Uint16Array;

    case _constants.default.UNSIGNED_INT:
      return Uint32Array;

    case _constants.default.UNSIGNED_BYTE:
      return clamped ? Uint8ClampedArray : Uint8Array;

    case _constants.default.BYTE:
      return Int8Array;

    case _constants.default.SHORT:
      return Int16Array;

    case _constants.default.INT:
      return Int32Array;

    default:
      throw new Error('Failed to deduce typed array type from GL constant');
  }
}
/* eslint-enable complexity */
// Flip rows (can be used on arrays returned from `Framebuffer.readPixels`)
// https://stackoverflow.com/questions/41969562/
// how-can-i-flip-the-result-of-webglrenderingcontext-readpixels


function flipRows(_ref2) {
  var data = _ref2.data,
      width = _ref2.width,
      height = _ref2.height,
      _ref2$bytesPerPixel = _ref2.bytesPerPixel,
      bytesPerPixel = _ref2$bytesPerPixel === void 0 ? 4 : _ref2$bytesPerPixel,
      temp = _ref2.temp;
  var bytesPerRow = width * bytesPerPixel; // make a temp buffer to hold one row

  temp = temp || new Uint8Array(bytesPerRow);

  for (var y = 0; y < height / 2; ++y) {
    var topOffset = y * bytesPerRow;
    var bottomOffset = (height - y - 1) * bytesPerRow; // make copy of a row on the top half

    temp.set(data.subarray(topOffset, topOffset + bytesPerRow)); // copy a row from the bottom half to the top

    data.copyWithin(topOffset, bottomOffset, bottomOffset + bytesPerRow); // copy the copy of the top half row to the bottom half

    data.set(temp, bottomOffset);
  }
}

function scalePixels(_ref3) {
  var data = _ref3.data,
      width = _ref3.width,
      height = _ref3.height;
  var newWidth = Math.round(width / 2);
  var newHeight = Math.round(height / 2);
  var newData = new Uint8Array(newWidth * newHeight * 4);

  for (var y = 0; y < newHeight; y++) {
    for (var x = 0; x < newWidth; x++) {
      for (var c = 0; c < 4; c++) {
        newData[(y * newWidth + x) * 4 + c] = data[(y * 2 * width + x * 2) * 4 + c];
      }
    }
  }

  return {
    data: newData,
    width: newWidth,
    height: newHeight
  };
}
//# sourceMappingURL=typed-array-utils.js.map