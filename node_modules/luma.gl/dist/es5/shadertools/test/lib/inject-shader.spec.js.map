{"version":3,"sources":["../../../../../src/shadertools/test/lib/inject-shader.spec.js"],"names":["fixture","gl","VS_GLSL_TEMPLATE","VS_GLSL_RESOLVED","FS_GLSL_TEMPLATE","FS_GLSL_RESOLVED","INJECT","t","ok","injectShader","undefined","end","injectResult","equal","assembleResult","vs","fs","inject","prologue"],"mappings":";;AACA;;AACA;;AACA;;;;AAHA;AAKA,IAAMA,UAAU;AACdC,MAAI;AADU,CAAhB;AAIA,IAAMC,0MAAN;AAcA,IAAMC,sOAAN;AAeA,IAAMC,qMAAN;AAeA,IAAMC,sQAAN;AAkBA,IAAMC,SAAS;AACb,cAAY,8BADC;AAEb,cAAY,0BAFC;AAGb,oBAAkB,sCAHL;AAIb,kBAAgB;AAJH,CAAf;AAOA,wBAAK,qBAAL,EAA4B,aAAK;AAC/BC,IAAEC,EAAF,CAAKC,0BAAiBC,SAAtB,EAAiC,gCAAjC;AACAH,IAAEI,GAAF;AACD,CAHD;AAKA,wBAAK,2BAAL,EAAkC,aAAK;AACrC,MAAIC,YAAJ;AAEAA,iBAAe,2BAAaV,gBAAb,EAA+B,IAA/B,EAAqCI,MAArC,CAAf;AACAC,IAAEM,KAAF,CAAQD,YAAR,EAAsBT,gBAAtB,EAAwC,oBAAxC;AAEAS,iBAAe,2BAAaR,gBAAb,EAA+B,IAA/B,EAAqCE,MAArC,CAAf;AACAC,IAAEM,KAAF,CAAQD,YAAR,EAAsBP,gBAAtB,EAAwC,oBAAxC;AAEAE,IAAEI,GAAF;AACD,CAVD;AAYA,wBAAK,8BAAL,EAAqC,aAAK;AACxC,MAAMG,iBAAiB,2BAAgBd,QAAQC,EAAxB,EAA4B;AACjDc,QAAIb,gBAD6C;AAEjDc,QAAIZ,gBAF6C;AAGjDa,YAAQX,MAHyC;AAIjDY,cAAU;AAJuC,GAA5B,CAAvB;AAMAX,IAAEM,KAAF,CAAQC,eAAeC,EAAvB,EAA2BZ,gBAA3B,EAA6C,oBAA7C;AACAI,IAAEM,KAAF,CAAQC,eAAeE,EAAvB,EAA2BX,gBAA3B,EAA6C,oBAA7C;AAEAE,IAAEI,GAAF;AACD,CAXD","sourcesContent":["/* eslint-disable camelcase */\nimport injectShader from 'luma.gl/shadertools/src/lib/inject-shader';\nimport {assembleShaders, createGLContext} from 'luma.gl';\nimport test from 'tape-catch';\n\nconst fixture = {\n  gl: createGLContext()\n};\n\nconst VS_GLSL_TEMPLATE = `\\\n#version 300 es\n\nin vec4 positions;\nout vec4 vColor;\n\nvoid f(out float a, in float b) {}\n\nvoid main(void) {\n  gl_Position = positions;\n  vColor = vec4(1., 0., 0., 1.);\n}\n`;\n\nconst VS_GLSL_RESOLVED = `\\\n#version 300 es\nuniform float uNewUniform;\n\nin vec4 positions;\nout vec4 vColor;\n\nvoid f(out float a, in float b) {}\n\nvoid main(void) {\n  gl_Position = positions;\n  vColor = vec4(1., 0., 0., 1.);\n}\n`;\n\nconst FS_GLSL_TEMPLATE = `\\\n#version 300 es\n\nprecision highp float;\n\nout vec4 fragmentColor;\nin vec4 vColor;\n\nvoid f(out float a, in float b) {}\n\nvoid main(void) {\n  fragmentColor = vColor;\n}\n`;\n\nconst FS_GLSL_RESOLVED = `\\\n#version 300 es\nuniform bool uDiscard;\n\nprecision highp float;\n\nout vec4 fragmentColor;\nin vec4 vColor;\n\nvoid f(out float a, in float b) {}\n\nvoid main(void) {\n  if (uDiscard} { discard } else {\n  fragmentColor = vColor;\n  }\n}\n`;\n\nconst INJECT = {\n  'vs:#decl': 'uniform float uNewUniform;\\n',\n  'fs:#decl': 'uniform bool uDiscard;\\n',\n  'fs:#main-start': '  if (uDiscard} { discard } else {\\n',\n  'fs:#main-end': '  }\\n'\n};\n\ntest('injectShader#import', t => {\n  t.ok(injectShader !== undefined, 'injectShader import successful');\n  t.end();\n});\n\ntest('injectShader#injectShader', t => {\n  let injectResult;\n\n  injectResult = injectShader(VS_GLSL_TEMPLATE, 'vs', INJECT);\n  t.equal(injectResult, VS_GLSL_RESOLVED, 'correctly injected');\n\n  injectResult = injectShader(FS_GLSL_TEMPLATE, 'fs', INJECT);\n  t.equal(injectResult, FS_GLSL_RESOLVED, 'correctly injected');\n\n  t.end();\n});\n\ntest('injectShader#assembleShaders', t => {\n  const assembleResult = assembleShaders(fixture.gl, {\n    vs: VS_GLSL_TEMPLATE,\n    fs: FS_GLSL_TEMPLATE,\n    inject: INJECT,\n    prologue: false\n  });\n  t.equal(assembleResult.vs, VS_GLSL_RESOLVED, 'correctly injected');\n  t.equal(assembleResult.fs, FS_GLSL_RESOLVED, 'correctly injected');\n\n  t.end();\n});\n"],"file":"inject-shader.spec.js"}