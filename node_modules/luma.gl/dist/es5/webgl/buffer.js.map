{"version":3,"sources":["../../../src/webgl/buffer.js"],"names":["DEBUG_DATA_LENGTH","Buffer","gl","props","ArrayBuffer","isView","data","stubRemovedMethods","target","webgl2","GL","COPY_READ_BUFFER","ARRAY_BUFFER","initialize","Object","seal","opts","accessor","update","bytes","usage","STATIC_DRAW","type","byteLength","Float32Array","bytesUsed","debugData","slice","setAccessor","Accessor","COPY_WRITE_BUFFER","bindBuffer","handle","bufferData","setData","offset","srcOffset","length","undefined","bufferSubData","sourceBuffer","readOffset","writeOffset","size","copyBufferSubData","dstData","srcByteOffset","dstOffset","ArrayType","FLOAT","clamped","sourceAvailableElementCount","_getAvailableElementCount","dstElementOffset","dstAvailableElementCount","dstElementCount","Math","min","copyElementCount","getBufferSubData","index","UNIFORM_BUFFER","TRANSFORM_FEEDBACK_BUFFER","bindBufferBase","bindBufferRange","BYTES_PER_ELEMENT","isIndexedBuffer","getData","changed","sourceElementOffset","getElementCount","createBuffer","deleteBuffer","pname","value","getBufferParameter","log","removed","Resource"],"mappings":"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","sourcesContent":["import GL from '../constants';\nimport Resource from './resource';\nimport {assertWebGL2Context} from '../webgl-utils';\nimport {getGLTypeFromTypedArray, getTypedArrayFromGLType} from '../webgl-utils/typed-array-utils';\nimport Accessor from './accessor';\nimport {log} from '../utils';\nimport assert from '../utils/assert';\n\nconst DEBUG_DATA_LENGTH = 10;\n\nexport default class Buffer extends Resource {\n\n  constructor(gl, props = {}) {\n    super(gl, props);\n\n    // Supports signature `new Buffer(gl, new Float32Array(...)`\n    if (ArrayBuffer.isView(props)) {\n      props = {data: props};\n    }\n\n    this.stubRemovedMethods('Buffer', 'v6.0', ['layout', 'setLayout', 'getIndexedParameter']);\n\n    // In WebGL1, need to make sure we use GL.ELEMENT_ARRAY_BUFFER when initializing element buffers\n    // otherwise buffer type will lock to generic (non-element) buffer\n    // In WebGL2, we can use GL.COPY_READ_BUFFER which avoids locking the type here\n    this.target = props.target || (this.gl.webgl2 ? GL.COPY_READ_BUFFER : GL.ARRAY_BUFFER);\n    this.initialize(props);\n    Object.seal(this);\n  }\n\n  get data() {\n    log.removed('Buffer.data', 'N/A', 'v6.0');\n    return null;\n  }\n\n  // Stores the accessor of data with the buffer, makes it easy to e.g. set it as an attribute later\n  // {accessor,type,size = 1,offset = 0,stride = 0,normalized = false,integer = false,instanced = 0}\n  setAccessor(opts) {\n    this.accessor = opts;\n    return this;\n  }\n\n  updateAccessor(opts) {\n    this.accessor.update(opts);\n    return this;\n  }\n\n  // Creates and initializes the buffer object's data store.\n  initialize(props = {}) {\n    let {\n      data,\n      bytes\n    } = props;\n\n    const {\n      usage = GL.STATIC_DRAW\n    } = props;\n\n    let type;\n    if (data) {\n      // infer type from typed array\n      type = getGLTypeFromTypedArray(data);\n      bytes = data.byteLength;\n      assert(type);\n    } else if (!bytes || bytes === 0) {\n      // Workaround needed for Safari (#291):\n      // gl.bufferData with size (second argument) equal to 0 crashes.\n      // hence create zero sized array.\n      bytes = 0;\n      data = new Float32Array(0);\n    }\n\n    this.usage = usage;\n    this.bytes = bytes;\n    this.bytesUsed = bytes;\n\n    this.debugData = data ? data.slice(0, DEBUG_DATA_LENGTH) : null;\n\n    // Call after type is determined\n    this.setAccessor(new Accessor(type ? {type} : {}, props, props.accessor));\n\n    // Create the buffer - binding it here for the first time locks the type\n    // In WebGL2, use GL.COPY_WRITE_BUFFER to avoid locking the type\n    const target = this.gl.webgl2 ? GL.COPY_WRITE_BUFFER : this.target;\n    this.gl.bindBuffer(target, this.handle);\n    this.gl.bufferData(target, data || bytes, usage);\n    this.gl.bindBuffer(target, null);\n\n    return this;\n  }\n\n  setProps(props) {\n    if ('data' in props) {\n      this.setData(props);\n    }\n    return this;\n  }\n\n  setData(opts) {\n    return this.initialize(opts);\n  }\n\n  // Updates a subset of a buffer object's data store.\n  // Data (Typed Array or ArrayBuffer), length is inferred unless provided\n  // Offset into buffer\n  // WebGL2 only: Offset into srcData\n  // WebGL2 only: Number of bytes to be copied\n  subData({data, offset = 0, srcOffset = 0, length} = {}) {\n    assert(data);\n\n    // Create the buffer - binding it here for the first time locks the type\n    // In WebGL2, use GL.COPY_WRITE_BUFFER to avoid locking the type\n    const target = this.gl.webgl2 ? GL.COPY_WRITE_BUFFER : this.target;\n    this.gl.bindBuffer(target, this.handle);\n    // WebGL2: subData supports additional srcOffset and length parameters\n    if (srcOffset !== 0 || length !== undefined) {\n      assertWebGL2Context(this.gl);\n      this.gl.bufferSubData(this.target, offset, data, srcOffset, length || 0);\n    } else {\n      this.gl.bufferSubData(target, offset, data);\n    }\n    this.gl.bindBuffer(target, null);\n\n    // TODO - update local `data` if offsets are right\n    this.debugData = null;\n\n    return this;\n  }\n\n  // WEBGL2 ONLY: Copies part of the data of another buffer into this buffer\n  copyData({sourceBuffer, readOffset = 0, writeOffset = 0, size}) {\n    const {gl} = this;\n    assertWebGL2Context(gl);\n\n    // Use GL.COPY_READ_BUFFER+GL.COPY_WRITE_BUFFER avoid disturbing other targets and locking type\n    gl.bindBuffer(GL.COPY_READ_BUFFER, sourceBuffer.handle);\n    gl.bindBuffer(GL.COPY_WRITE_BUFFER, this.handle);\n    gl.copyBufferSubData(GL.COPY_READ_BUFFER, GL.COPY_WRITE_BUFFER, readOffset, writeOffset, size);\n    gl.bindBuffer(GL.COPY_READ_BUFFER, null);\n    gl.bindBuffer(GL.COPY_WRITE_BUFFER, null);\n\n    // TODO - update local `data` if offsets are 0\n    this.debugData = null;\n\n    return this;\n  }\n\n  // WEBGL2 ONLY: Reads data from buffer into an ArrayBufferView or SharedArrayBuffer.\n  getData({dstData = null, srcByteOffset = 0, dstOffset = 0, length = 0} = {}) {\n    assertWebGL2Context(this.gl);\n\n    const ArrayType = getTypedArrayFromGLType(this.accessor.type || GL.FLOAT, {clamped: false});\n    const sourceAvailableElementCount = this._getAvailableElementCount(srcByteOffset);\n\n    const dstElementOffset = dstOffset;\n\n    let dstAvailableElementCount;\n    let dstElementCount;\n    if (dstData) {\n      dstElementCount = dstData.length;\n      dstAvailableElementCount = dstElementCount - dstElementOffset;\n    } else {\n      // Allocate ArrayBufferView with enough size to copy all eligible data.\n      dstAvailableElementCount =\n        Math.min(sourceAvailableElementCount, length || sourceAvailableElementCount);\n      dstElementCount = dstElementOffset + dstAvailableElementCount;\n    }\n\n    const copyElementCount = Math.min(sourceAvailableElementCount, dstAvailableElementCount);\n    length = length || copyElementCount;\n    assert(length <= copyElementCount);\n    dstData = dstData || new ArrayType(dstElementCount);\n\n    // Use GL.COPY_READ_BUFFER to avoid disturbing other targets and locking type\n    this.gl.bindBuffer(GL.COPY_READ_BUFFER, this.handle);\n    this.gl.getBufferSubData(GL.COPY_READ_BUFFER, srcByteOffset, dstData, dstOffset, length);\n    this.gl.bindBuffer(GL.COPY_READ_BUFFER, null);\n\n    // TODO - update local `data` if offsets are 0\n\n    return dstData;\n  }\n\n  /**\n   * Binds a buffer to a given binding point (target).\n   *   GL.TRANSFORM_FEEDBACK_BUFFER and GL.UNIFORM_BUFFER take an index, and optionally a range.\n   * @param {Glenum} target - target for the bind operation.\n   * @param {GLuint} index= - the index of the target.\n   *   - GL.TRANSFORM_FEEDBACK_BUFFER and GL.UNIFORM_BUFFER need an index to affect state\n   * @param {GLuint} offset=0 - the index of the target.\n   *   - GL.UNIFORM_BUFFER: `offset` must be aligned to GL.UNIFORM_BUFFER_OFFSET_ALIGNMENT.\n   * @param {GLuint} size= - the index of the target.\n   *   - GL.UNIFORM_BUFFER: `size` must be a minimum of GL.UNIFORM_BLOCK_SIZE_DATA.\n   * @returns {Buffer} - Returns itself for chaining.\n   */\n  bind({\n    target = this.target, index = this.accessor && this.accessor.index, offset = 0, size\n  } = {}) {\n    // NOTE: While GL.TRANSFORM_FEEDBACK_BUFFER and GL.UNIFORM_BUFFER could\n    // be used as direct binding points, they will not affect transform feedback or\n    // uniform buffer state. Instead indexed bindings need to be made.\n    const type = (target === GL.UNIFORM_BUFFER || target === GL.TRANSFORM_FEEDBACK_BUFFER) ?\n      (size !== undefined ? 'ranged' : 'indexed') : 'non-indexed';\n\n    switch (type) {\n    case 'indexed':\n      assertWebGL2Context(this.gl);\n      assert(offset === 0); // Make sure offset wasn't supplied\n      this.gl.bindBufferBase(target, index, this.handle);\n      break;\n    case 'ranged':\n      assertWebGL2Context(this.gl);\n      this.gl.bindBufferRange(target, index, this.handle, offset, size);\n      break;\n    case 'non-indexed':\n      this.gl.bindBuffer(target, this.handle);\n      break;\n    default:\n      assert(false);\n    }\n\n    return this;\n  }\n\n  // returns number of elements in the buffer\n  getElementCount() {\n    const ArrayType = getTypedArrayFromGLType(this.accessor.type || GL.FLOAT, {clamped: false});\n    return this.bytes / ArrayType.BYTES_PER_ELEMENT;\n  }\n\n  unbind({target = this.target, index = this.accessor && this.accessor.index} = {}) {\n    const isIndexedBuffer = target === GL.UNIFORM_BUFFER || target === GL.TRANSFORM_FEEDBACK_BUFFER;\n    if (isIndexedBuffer) {\n      this.gl.bindBufferBase(target, index, null);\n    } else {\n      this.gl.bindBuffer(target, null);\n    }\n    return this;\n  }\n\n  // PRIVATE METHODS\n\n  // Returns a short initial data array\n  getDebugData() {\n    if (!this.debugData) {\n      this.debugData = this.getData({length: DEBUG_DATA_LENGTH});\n      return {data: this.debugData, changed: true};\n    }\n    return {data: this.debugData, changed: false};\n  }\n\n  invalidateDebugData() {\n    this.debugData = null;\n  }\n\n  _getAvailableElementCount(srcByteOffset) {\n    const ArrayType = getTypedArrayFromGLType(this.accessor.type || GL.FLOAT, {clamped: false});\n    const sourceElementOffset = srcByteOffset / ArrayType.BYTES_PER_ELEMENT;\n    return this.getElementCount() - sourceElementOffset;\n  }\n\n  // RESOURCE METHODS\n\n  _createHandle() {\n    return this.gl.createBuffer();\n  }\n\n  _deleteHandle() {\n    this.gl.deleteBuffer(this.handle);\n  }\n\n  _getParameter(pname) {\n    this.gl.bindBuffer(this.target, this.handle);\n    const value = this.gl.getBufferParameter(this.target, pname);\n    this.gl.bindBuffer(this.target, null);\n    return value;\n  }\n}\n"],"file":"buffer.js"}