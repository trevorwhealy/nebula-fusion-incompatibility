"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

function _instanceof(left, right) { if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) { return right[Symbol.hasInstance](left); } else { return left instanceof right; } }

function _classCallCheck(instance, Constructor) { if (!_instanceof(instance, Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var GL_FLOAT = 0x1406;

var Accessor =
/*#__PURE__*/
function () {
  _createClass(Accessor, null, [{
    key: "DEFAULTS",
    get: function get() {
      return {
        type: GL_FLOAT,
        size: 1,
        offset: 0,
        stride: 0,
        normalized: false,
        integer: false,
        instanced: 0
      };
    }
    /**
     * Store characteristics of a data accessor
     * This data can be used when updating vertex attributes with the associated buffer,
     * freeing the application from keeping track of this metadata.
     * @class
     * {type, size, offset, stride, normalized, integer, instanced}
     * @param {GLuint} size - number of values per element (1-4)
     * @param {GLuint} type - type of values (e.g. gl.FLOAT)
     * @param {GLbool} normalized=false - normalize integers to [-1,1] or [0,1]
     * @param {GLuint} integer=false - WebGL2 only, int-to-float conversion
     * @param {GLuint} stride=0 - supports strided arrays
     * @param {GLuint} offset=0 - supports strided arrays
     */

  }]);

  function Accessor() {
    var _this = this;

    _classCallCheck(this, Accessor);

    for (var _len = arguments.length, optsList = new Array(_len), _key = 0; _key < _len; _key++) {
      optsList[_key] = arguments[_key];
    }

    optsList.forEach(function (opts) {
      return _this._update(opts);
    });
  } // Combine with other accessors


  _createClass(Accessor, [{
    key: "getOptions",
    value: function getOptions() {
      var _this2 = this;

      var combinedOpts = Object.assign({}, Accessor.DEFAULTS, this);

      for (var _len2 = arguments.length, optsList = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        optsList[_key2] = arguments[_key2];
      }

      optsList.forEach(function (opts) {
        return _this2._update(opts, combinedOpts);
      });
      return combinedOpts;
    }
  }, {
    key: "update",
    value: function update(opts) {
      this._update(opts);

      return this;
    }
    /* eslint-disable complexity */

  }, {
    key: "_update",
    value: function _update() {
      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var target = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this;

      if (opts.type !== undefined) {
        target.type = opts.type;
      }

      if (opts.size !== undefined) {
        target.size = opts.size;
      }

      if (opts.offset !== undefined) {
        target.offset = opts.offset;
      }

      if (opts.stride !== undefined) {
        target.stride = opts.stride;
      }

      if (opts.normalized !== undefined) {
        target.normalized = opts.normalized;
      }

      if (opts.integer !== undefined) {
        target.integer = opts.integer;
      }

      if (opts.divisor !== undefined) {
        target.divisor = opts.divisor;
      } // Backwards compatibility


      if (opts.instanced !== undefined) {
        target.divisor = opts.instanced ? 1 : 0;
      }

      if (opts.isInstanced !== undefined) {
        target.divisor = opts.isInstanced ? 1 : 0;
      } // TODO - should this be supported?


      if (opts.index !== undefined) {
        target.index = opts.index ? 1 : 0;
      }

      return target;
    }
    /* eslint-enable complexity */

  }]);

  return Accessor;
}();

exports.default = Accessor;
//# sourceMappingURL=accessor.js.map